<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Interning LLVM handle to Managed wrappers | Llvm.NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Interning LLVM handle to Managed wrappers | Llvm.NET ">
    <meta name="generator" content="docfx 2.36.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../DragonSharp48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                <ul class="nav level1 navbar-nav">
                  <li class="">
                    <a href="../../api/index.html" title="API Documentation" class="">API Documentation</a>
                  </li>
                  <li class="">
                    <a href="../../articles/index.html" title="Articles" class="">Articles</a>
                  </li>
                  <li class="">
                    <a href="https://github.com/UbiquityDotNET/Llvm.NET" title="GitHub Repository" class="">GitHub Repository</a>
                  </li>
                  <li class="">
                    <a href="http://LLVM.org" title="LLVM.org" class="">LLVM.org</a>
                  </li>
                  <li class="">
                    <a href="http://releases.llvm.org/5.0.1/docs/index.html" title="LLVM Docs" class="">LLVM Docs</a>
                  </li>
                </ul>
            </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">LLVM-C API Handles</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="llvm-handles.html" title="Wrapping LLVM-C Handles" class="">Wrapping LLVM-C Handles</a>
                          </li>
                          <li class="active">
                            <a href="handleref-interning.html" title="Interning LLVM-C Handles" class="active">Interning LLVM-C Handles</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Marshaling LLVM types</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="marshal-string.html" title="Marshaling Strings" class="">Marshaling Strings</a>
                          </li>
                          <li class="">
                            <a href="marshal-LLVMBool.html" title="Marshaling LLVMBool" class="">Marshaling LLVMBool</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="interning-llvm-handle-to-managed-wrappers">Interning LLVM handle to Managed wrappers</h1>

<p>Many of the underlying object instances in LLVM are interned/uniqued. That is,
there will only be one instance of a type with a given value within some scope.</p>
<p>In LLVM the most common scope for uniqueing is the <a class="xref" href="../../api/Llvm.NET.Context.html">Context</a> type.
In essence this class is an interning class factory for the LLVM IR system for a given
thread. Most object instances are ultimately owned by the context or a 
<a class="xref" href="../../api/Llvm.NET.BitcodeModule.html">BitcodeModule</a>. LLVM-C APIs use opaque pointers for LLVM
objects. This is projected to the low level Llvm.NET.Native namespace as structs that wrap
an IntPtr to enforce some type safety. Furthermore, the LLVM-C API uses the highest level
of an object inheritance graph that it can when declaring the opaque type for the return
or arguments of functions. Thus, it is not possible to know the exact derived type from
the base opaque pointer alone.</p>
<p>In addition to opaque pointers an additional challenge exists in mapping such pointers
to projected instances. Any projection is essentially a wrapper around the opaque
pointer. However, when an API returns an opaque pointer the interop layer needs to
determine what to do with it. A naive first approach (actually used in Llvm.NET early
 versions) is to simply create a new instance of the wrapper type giving it the
opaque pointer to work from. This will work for a while, until the code needs to compare
two instances. Ordinarily reference types are compared with reference equality. However,
if two projected instances are the same then reference equality will fail. While it is
plausible to add equality checks via IEquatable, they are not without problems, particularly
with respect to computing the hash code when the type is fully mutable. Furthermore, for
instances that may be enumerated multiple times (i.e. in a tree traversal or visitor pattern)
multiple instances of wrappers for the same underlying instance would be created, thus wasting
memory.</p>
<p>To solve these problems Llvm.NET uses an interning approach that mirrors the underlying LLVM
implementation by maintaining a mapping of the raw opaque pointers to a single managed instance. This
means that whenever an interop API retrieves an opaque pointer it can look up the wrapper and
provide that to the caller. Thus, reference equality &quot;Just works&quot;. If there was no instance then
the interning system will create one. In order to create one it must know the concrete most
derived type for the opaque pointer to construct the wrapper type. The LLVM-C API generally defines
a reference handle type only for the top most base class rather than a distinct handle for each
derived type. Thus the mapping must know how to determine the correct derived type for the
projected wrapper. Fortunately, LLVM uses a custom type tagging mechanism to optimize such cases
internally (e.g. safe dynamic down casting by keeping a TypeKind value). While, the actual
implementation in LLVM is not as simplistic as that the details aren&#39;t relevant to the projection.
The projection wrapping can use the LLVM support to determine the correct type. Llvm.NET uses
this to manage the mapping and creation of types and consumers can remain blissfully ignorant
of these details.</p>
<h2 id="llvm-internal-implementation-of-interning">LLVM Internal implementation of interning</h2>
<p>Internally Llvm.NET uses a common Generic type LLvm.NET.HandleInterningMap&lt;THandle, TMappedType&gt; to
handle the interning. This type accepts a factory function and optional disposer function to
abstract the desired projected type factory and support for disposing items where the lifetime
is not implicitly managed by some container. </p>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/master/docfx/articles/InternalDetails/handleref-interning.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (C) 2017, Dot NET Foundation<br><strong>Build:</strong> 6.0.0-rc.0.0.ci-BLD.443750158
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
