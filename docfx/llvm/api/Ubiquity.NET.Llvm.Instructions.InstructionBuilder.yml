### YamlMime:ManagedReference
items:
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  commentId: T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  id: InstructionBuilder
  parent: Ubiquity.NET.Llvm.Instructions
  children:
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor(Ubiquity.NET.Llvm.IContext)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor(Ubiquity.NET.Llvm.Values.BasicBlock)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.ConstantInt)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock(Ubiquity.NET.Llvm.Values.BasicBlock)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.BasicBlock)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value})
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function,Ubiquity.NET.Llvm.Values.Value[])
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.IntPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.Predicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.RealPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Dispose
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue(Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg(Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze(Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.IPointerType)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke(Ubiquity.NET.Llvm.Values.Function,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value},Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad(Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg(Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not(Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode(Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd(Ubiquity.NET.Llvm.Values.BasicBlock)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore(Ubiquity.NET.Llvm.Instructions.Instruction)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume(Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return(Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(System.UInt32,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DILocalScope,Ubiquity.NET.Llvm.DebugInfo.DILocation)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(Ubiquity.NET.Llvm.DebugInfo.DILocation)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,System.UInt32)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  - Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  langs:
  - csharp
  - vb
  name: InstructionBuilder
  nameWithType: InstructionBuilder
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  type: Class
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: InstructionBuilder
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 9
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: LLVM Instruction builder allowing managed code to generate IR instructions
  example: []
  syntax:
    content: 'public sealed class InstructionBuilder : IDisposable'
    content.vb: Public NotInheritable Class InstructionBuilder Implements IDisposable
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Dispose
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Dispose
  id: Dispose
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Dispose()
  nameWithType: InstructionBuilder.Dispose()
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Dispose()
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Dispose
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 13
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
  example: []
  syntax:
    content: public void Dispose()
    content.vb: Public Sub Dispose()
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Dispose*
  implements:
  - System.IDisposable.Dispose
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor(Ubiquity.NET.Llvm.IContext)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor(Ubiquity.NET.Llvm.IContext)
  id: '#ctor(Ubiquity.NET.Llvm.IContext)'
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: InstructionBuilder(IContext)
  nameWithType: InstructionBuilder.InstructionBuilder(IContext)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InstructionBuilder(Ubiquity.NET.Llvm.IContext)
  type: Constructor
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: .ctor
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 17
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Initializes a new instance of the <xref href="Ubiquity.NET.Llvm.Instructions.InstructionBuilder" data-throw-if-not-resolved="false"></xref> class for a given <xref href="Ubiquity.NET.Llvm.ContextAlias" data-throw-if-not-resolved="false"></xref>
  example: []
  syntax:
    content: public InstructionBuilder(IContext context)
    parameters:
    - id: context
      type: Ubiquity.NET.Llvm.IContext
      description: ContextAlias used for creating instructions
    content.vb: Public Sub New(context As IContext)
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor*
  nameWithType.vb: InstructionBuilder.New(IContext)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.New(Ubiquity.NET.Llvm.IContext)
  name.vb: New(IContext)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor(Ubiquity.NET.Llvm.Values.BasicBlock)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor(Ubiquity.NET.Llvm.Values.BasicBlock)
  id: '#ctor(Ubiquity.NET.Llvm.Values.BasicBlock)'
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: InstructionBuilder(BasicBlock)
  nameWithType: InstructionBuilder.InstructionBuilder(BasicBlock)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InstructionBuilder(Ubiquity.NET.Llvm.Values.BasicBlock)
  type: Constructor
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: .ctor
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 25
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Initializes a new instance of the <xref href="Ubiquity.NET.Llvm.Instructions.InstructionBuilder" data-throw-if-not-resolved="false"></xref> class for a <xref href="Ubiquity.NET.Llvm.Values.BasicBlock" data-throw-if-not-resolved="false"></xref>
  example: []
  syntax:
    content: public InstructionBuilder(BasicBlock block)
    parameters:
    - id: block
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: Block this builder is initially attached to
    content.vb: Public Sub New(block As BasicBlock)
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor*
  nameWithType.vb: InstructionBuilder.New(BasicBlock)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.New(Ubiquity.NET.Llvm.Values.BasicBlock)
  name.vb: New(BasicBlock)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context
  commentId: P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context
  id: Context
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Context
  nameWithType: InstructionBuilder.Context
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context
  type: Property
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Context
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 32
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Gets the context this builder is creating instructions for
  example: []
  syntax:
    content: public IContext Context { get; }
    parameters: []
    return:
      type: Ubiquity.NET.Llvm.IContext
    content.vb: Public ReadOnly Property Context As IContext
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation
  commentId: P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation
  id: CurrentDebugLocation
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: CurrentDebugLocation
  nameWithType: InstructionBuilder.CurrentDebugLocation
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation
  type: Property
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: CurrentDebugLocation
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 35
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Gets or sets the current Debug Location for this <xref href="Ubiquity.NET.Llvm.Instructions.InstructionBuilder" data-throw-if-not-resolved="false"></xref>
  example: []
  syntax:
    content: public DILocation? CurrentDebugLocation { get; set; }
    parameters: []
    return:
      type: Ubiquity.NET.Llvm.DebugInfo.DILocation
    content.vb: Public Property CurrentDebugLocation As DILocation
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(System.UInt32,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DILocalScope,Ubiquity.NET.Llvm.DebugInfo.DILocation)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(System.UInt32,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DILocalScope,Ubiquity.NET.Llvm.DebugInfo.DILocation)
  id: SetDebugLocation(System.UInt32,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DILocalScope,Ubiquity.NET.Llvm.DebugInfo.DILocation)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: SetDebugLocation(uint, uint, DILocalScope, DILocation?)
  nameWithType: InstructionBuilder.SetDebugLocation(uint, uint, DILocalScope, DILocation?)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(uint, uint, Ubiquity.NET.Llvm.DebugInfo.DILocalScope, Ubiquity.NET.Llvm.DebugInfo.DILocation?)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: SetDebugLocation
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 47
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Set the current debug location for this <xref href="Ubiquity.NET.Llvm.Instructions.InstructionBuilder" data-throw-if-not-resolved="false"></xref>
  example: []
  syntax:
    content: public InstructionBuilder SetDebugLocation(uint line, uint col, DILocalScope scope, DILocation? inlinedAt = null)
    parameters:
    - id: line
      type: System.UInt32
      description: Source line
    - id: col
      type: System.UInt32
      description: Source column
    - id: scope
      type: Ubiquity.NET.Llvm.DebugInfo.DILocalScope
      description: <xref href="Ubiquity.NET.Llvm.DebugInfo.DILocalScope" data-throw-if-not-resolved="false"></xref> for the location
    - id: inlinedAt
      type: Ubiquity.NET.Llvm.DebugInfo.DILocation
      description: <xref href="Ubiquity.NET.Llvm.DebugInfo.DILocation" data-throw-if-not-resolved="false"></xref>the location is inlined into
    return:
      type: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
      description: This builder for fluent API usage
    content.vb: Public Function SetDebugLocation(line As UInteger, col As UInteger, scope As DILocalScope, inlinedAt As DILocation = Nothing) As InstructionBuilder
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation*
  nameWithType.vb: InstructionBuilder.SetDebugLocation(UInteger, UInteger, DILocalScope, DILocation)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(UInteger, UInteger, Ubiquity.NET.Llvm.DebugInfo.DILocalScope, Ubiquity.NET.Llvm.DebugInfo.DILocation)
  name.vb: SetDebugLocation(UInteger, UInteger, DILocalScope, DILocation)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(Ubiquity.NET.Llvm.DebugInfo.DILocation)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(Ubiquity.NET.Llvm.DebugInfo.DILocation)
  id: SetDebugLocation(Ubiquity.NET.Llvm.DebugInfo.DILocation)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: SetDebugLocation(DILocation?)
  nameWithType: InstructionBuilder.SetDebugLocation(DILocation?)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(Ubiquity.NET.Llvm.DebugInfo.DILocation?)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: SetDebugLocation
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 56
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Set the current debug location for this <xref href="Ubiquity.NET.Llvm.Instructions.InstructionBuilder" data-throw-if-not-resolved="false"></xref>
  example: []
  syntax:
    content: public InstructionBuilder SetDebugLocation(DILocation? location)
    parameters:
    - id: location
      type: Ubiquity.NET.Llvm.DebugInfo.DILocation
      description: Location to set
    return:
      type: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
      description: This builder for fluent API usage
    content.vb: Public Function SetDebugLocation(location As DILocation) As InstructionBuilder
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation*
  nameWithType.vb: InstructionBuilder.SetDebugLocation(DILocation)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(Ubiquity.NET.Llvm.DebugInfo.DILocation)
  name.vb: SetDebugLocation(DILocation)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
  commentId: P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
  id: InsertBlock
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: InsertBlock
  nameWithType: InstructionBuilder.InsertBlock
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
  type: Property
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: InsertBlock
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 64
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Gets the <xref href="Ubiquity.NET.Llvm.Values.BasicBlock" data-throw-if-not-resolved="false"></xref> this builder is building instructions for
  example: []
  syntax:
    content: public BasicBlock? InsertBlock { get; }
    parameters: []
    return:
      type: Ubiquity.NET.Llvm.Values.BasicBlock
    content.vb: Public ReadOnly Property InsertBlock As BasicBlock
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction
  commentId: P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction
  id: InsertFunction
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: InsertFunction
  nameWithType: InstructionBuilder.InsertFunction
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction
  type: Property
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: InsertFunction
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 74
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Gets the function this builder currently inserts into
  example: []
  syntax:
    content: public Function? InsertFunction { get; }
    parameters: []
    return:
      type: Ubiquity.NET.Llvm.Values.Function
    content.vb: Public ReadOnly Property InsertFunction As [Function]
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd(Ubiquity.NET.Llvm.Values.BasicBlock)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd(Ubiquity.NET.Llvm.Values.BasicBlock)
  id: PositionAtEnd(Ubiquity.NET.Llvm.Values.BasicBlock)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: PositionAtEnd(BasicBlock)
  nameWithType: InstructionBuilder.PositionAtEnd(BasicBlock)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd(Ubiquity.NET.Llvm.Values.BasicBlock)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: PositionAtEnd
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 78
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Positions the builder at the end of a given <xref href="Ubiquity.NET.Llvm.Values.BasicBlock" data-throw-if-not-resolved="false"></xref>
  example: []
  syntax:
    content: public void PositionAtEnd(BasicBlock basicBlock)
    parameters:
    - id: basicBlock
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: Block to set the position of
    content.vb: Public Sub PositionAtEnd(basicBlock As BasicBlock)
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore(Ubiquity.NET.Llvm.Instructions.Instruction)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore(Ubiquity.NET.Llvm.Instructions.Instruction)
  id: PositionBefore(Ubiquity.NET.Llvm.Instructions.Instruction)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: PositionBefore(Instruction)
  nameWithType: InstructionBuilder.PositionBefore(Instruction)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore(Ubiquity.NET.Llvm.Instructions.Instruction)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: PositionBefore
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 94
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Positions the builder before the given instruction
  remarks: >-
    This method will position the builder to add new instructions
        immediately before the specified instruction.
        <div class="NOTE"><h5>note</h5><p>It is important to keep in mind that this can change the
        block this builder is targeting. That is, <code class="paramref">instr</code>
        is not required to come from the same block the instruction builder is
        currently referencing.</p></div>
  example: []
  syntax:
    content: public void PositionBefore(Instruction instr)
    parameters:
    - id: instr
      type: Ubiquity.NET.Llvm.Instructions.Instruction
      description: Instruction to position the builder before
    content.vb: Public Sub PositionBefore(instr As Instruction)
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock(Ubiquity.NET.Llvm.Values.BasicBlock)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock(Ubiquity.NET.Llvm.Values.BasicBlock)
  id: AppendBasicBlock(Ubiquity.NET.Llvm.Values.BasicBlock)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AppendBasicBlock(BasicBlock)
  nameWithType: InstructionBuilder.AppendBasicBlock(BasicBlock)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock(Ubiquity.NET.Llvm.Values.BasicBlock)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AppendBasicBlock
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 104
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Appends a basic block after the <xref href="Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock" data-throw-if-not-resolved="false"></xref> of this <xref href="Ubiquity.NET.Llvm.Instructions.InstructionBuilder" data-throw-if-not-resolved="false"></xref>
  example: []
  syntax:
    content: public void AppendBasicBlock(BasicBlock block)
    parameters:
    - id: block
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: Block to insert
    content.vb: Public Sub AppendBasicBlock(block As BasicBlock)
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg(Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg(Ubiquity.NET.Llvm.Values.Value)
  id: FNeg(Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FNeg(Value)
  nameWithType: InstructionBuilder.FNeg(Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg(Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FNeg
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 113
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point negation operator
  example: []
  syntax:
    content: public Value FNeg(Value value)
    parameters:
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: value to negate
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function FNeg(value As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: FAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FAdd(Value, Value)
  nameWithType: InstructionBuilder.FAdd(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FAdd
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 119
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point add operator
  example: []
  syntax:
    content: public Value FAdd(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function FAdd(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: FSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FSub(Value, Value)
  nameWithType: InstructionBuilder.FSub(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FSub
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 125
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point subtraction operator
  example: []
  syntax:
    content: public Value FSub(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function FSub(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: FMul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FMul(Value, Value)
  nameWithType: InstructionBuilder.FMul(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FMul
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 131
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point multiple operator
  example: []
  syntax:
    content: public Value FMul(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function FMul(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: FDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FDiv(Value, Value)
  nameWithType: InstructionBuilder.FDiv(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FDiv
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 137
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point division operator
  example: []
  syntax:
    content: public Value FDiv(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function FDiv(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: FRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FRem(Value, Value)
  nameWithType: InstructionBuilder.FRem(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FRem
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 143
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point remainder operator
  example: []
  syntax:
    content: public Value FRem(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function FRem(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg(Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg(Ubiquity.NET.Llvm.Values.Value)
  id: Neg(Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Neg(Value)
  nameWithType: InstructionBuilder.Neg(Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg(Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Neg
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 148
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer negation operator
  example: []
  syntax:
    content: public Value Neg(Value value)
    parameters:
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: operand to negate
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function Neg(value As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not(Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not(Ubiquity.NET.Llvm.Values.Value)
  id: Not(Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Not(Value)
  nameWithType: InstructionBuilder.Not(Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not(Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Not
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 154
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer logical not operator
  remarks: LLVM IR doesn't actually have a logical not instruction so this is implemented as value XOR {one}
  example: []
  syntax:
    content: public Value Not(Value value)
    parameters:
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function [Not](value As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Add(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Add(Value, Value)
  nameWithType: InstructionBuilder.Add(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Add
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 160
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer add operator
  example: []
  syntax:
    content: public Value Add(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function Add(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: And(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: And(Value, Value)
  nameWithType: InstructionBuilder.And(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: And
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 166
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer bitwise and operator
  example: []
  syntax:
    content: public Value And(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function [And](lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Sub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Sub(Value, Value)
  nameWithType: InstructionBuilder.Sub(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Sub
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 172
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer subtraction operator
  example: []
  syntax:
    content: public Value Sub(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function [Sub](lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Mul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Mul(Value, Value)
  nameWithType: InstructionBuilder.Mul(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Mul
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 178
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer multiplication operator
  example: []
  syntax:
    content: public Value Mul(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function Mul(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: ShiftLeft(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: ShiftLeft(Value, Value)
  nameWithType: InstructionBuilder.ShiftLeft(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: ShiftLeft
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 184
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer shift left operator
  example: []
  syntax:
    content: public Value ShiftLeft(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function ShiftLeft(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: ArithmeticShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: ArithmeticShiftRight(Value, Value)
  nameWithType: InstructionBuilder.ArithmeticShiftRight(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: ArithmeticShiftRight
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 190
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer arithmetic shift right operator
  example: []
  syntax:
    content: public Value ArithmeticShiftRight(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function ArithmeticShiftRight(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: LogicalShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: LogicalShiftRight(Value, Value)
  nameWithType: InstructionBuilder.LogicalShiftRight(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: LogicalShiftRight
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 196
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer logical shift right operator
  example: []
  syntax:
    content: public Value LogicalShiftRight(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function LogicalShiftRight(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: UDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: UDiv(Value, Value)
  nameWithType: InstructionBuilder.UDiv(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: UDiv
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 202
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer unsigned division operator
  example: []
  syntax:
    content: public Value UDiv(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function UDiv(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: SDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: SDiv(Value, Value)
  nameWithType: InstructionBuilder.SDiv(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: SDiv
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 208
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer signed division operator
  example: []
  syntax:
    content: public Value SDiv(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function SDiv(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: URem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: URem(Value, Value)
  nameWithType: InstructionBuilder.URem(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: URem
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 214
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer unsigned remainder operator
  example: []
  syntax:
    content: public Value URem(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function URem(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: SRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: SRem(Value, Value)
  nameWithType: InstructionBuilder.SRem(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: SRem
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 220
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer signed remainder operator
  example: []
  syntax:
    content: public Value SRem(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function SRem(lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Xor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Xor(Value, Value)
  nameWithType: InstructionBuilder.Xor(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Xor
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 226
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer bitwise exclusive or operator
  example: []
  syntax:
    content: public Value Xor(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function [Xor](lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Or(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Or(Value, Value)
  nameWithType: InstructionBuilder.Or(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Or
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 232
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer bitwise or operator
  example: []
  syntax:
    content: public Value Or(Value lhs, Value rhs)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: left hand side operand
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the instruction
    content.vb: Public Function [Or](lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef)
  id: Alloca(Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Alloca(ITypeRef)
  nameWithType: InstructionBuilder.Alloca(ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Alloca
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 237
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an alloca instruction
  example: []
  syntax:
    content: public Alloca Alloca(ITypeRef typeRef)
    parameters:
    - id: typeRef
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Type of the value to allocate
    return:
      type: Ubiquity.NET.Llvm.Instructions.Alloca
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Alloca" data-throw-if-not-resolved="false"></xref> instruction
    content.vb: Public Function Alloca(typeRef As ITypeRef) As Alloca
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.ConstantInt)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.ConstantInt)
  id: Alloca(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.ConstantInt)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Alloca(ITypeRef, ConstantInt)
  nameWithType: InstructionBuilder.Alloca(ITypeRef, ConstantInt)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.ConstantInt)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Alloca
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 251
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an alloca instruction
  example: []
  syntax:
    content: public Alloca Alloca(ITypeRef typeRef, ConstantInt elements)
    parameters:
    - id: typeRef
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Type of the value to allocate
    - id: elements
      type: Ubiquity.NET.Llvm.Values.ConstantInt
      description: Number of elements to allocate
    return:
      type: Ubiquity.NET.Llvm.Instructions.Alloca
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Alloca" data-throw-if-not-resolved="false"></xref> instruction
    content.vb: Public Function Alloca(typeRef As ITypeRef, elements As ConstantInt) As Alloca
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return
  id: Return
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Return()
  nameWithType: InstructionBuilder.Return()
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return()
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Return
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 266
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a return instruction for a function that has no return value
  example: []
  syntax:
    content: public ReturnInstruction Return()
    return:
      type: Ubiquity.NET.Llvm.Instructions.ReturnInstruction
      description: <xref href="Ubiquity.NET.Llvm.Instructions.ReturnInstruction" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function [Return]() As ReturnInstruction
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: the function has a non-void return type
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return(Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return(Ubiquity.NET.Llvm.Values.Value)
  id: Return(Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Return(Value)
  nameWithType: InstructionBuilder.Return(Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return(Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Return
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 290
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a return instruction with the return value for a function
  example: []
  syntax:
    content: public ReturnInstruction Return(Value value)
    parameters:
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> to return
    return:
      type: Ubiquity.NET.Llvm.Instructions.ReturnInstruction
      description: <xref href="Ubiquity.NET.Llvm.Instructions.ReturnInstruction" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function [Return](value As Value) As ReturnInstruction
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function,Ubiquity.NET.Llvm.Values.Value[])
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function,Ubiquity.NET.Llvm.Values.Value[])
  id: Call(Ubiquity.NET.Llvm.Values.Function,Ubiquity.NET.Llvm.Values.Value[])
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Call(Function, params Value[])
  nameWithType: InstructionBuilder.Call(Function, params Value[])
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function, params Ubiquity.NET.Llvm.Values.Value[])
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Call
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 325
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a call function
  example: []
  syntax:
    content: public CallInstruction Call(Function func, params Value[] args)
    parameters:
    - id: func
      type: Ubiquity.NET.Llvm.Values.Function
      description: Function to call
    - id: args
      type: Ubiquity.NET.Llvm.Values.Value[]
      description: Arguments to pass to the function
    return:
      type: Ubiquity.NET.Llvm.Instructions.CallInstruction
      description: <xref href="Ubiquity.NET.Llvm.Instructions.CallInstruction" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function [Call](func As [Function], ParamArray args As Value()) As CallInstruction
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call*
  nameWithType.vb: InstructionBuilder.Call(Function, ParamArray Value())
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function, ParamArray Ubiquity.NET.Llvm.Values.Value())
  name.vb: Call(Function, ParamArray Value())
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value})
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value})
  id: Call(Ubiquity.NET.Llvm.Values.Function,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value})
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Call(Function, IReadOnlyList<Value>)
  nameWithType: InstructionBuilder.Call(Function, IReadOnlyList<Value>)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function, System.Collections.Generic.IReadOnlyList<Ubiquity.NET.Llvm.Values.Value>)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Call
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 331
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a call function
  example: []
  syntax:
    content: public CallInstruction Call(Function func, IReadOnlyList<Value> args)
    parameters:
    - id: func
      type: Ubiquity.NET.Llvm.Values.Function
      description: Function to call
    - id: args
      type: System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value}
      description: Arguments to pass to the function
    return:
      type: Ubiquity.NET.Llvm.Instructions.CallInstruction
      description: <xref href="Ubiquity.NET.Llvm.Instructions.CallInstruction" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function [Call](func As [Function], args As IReadOnlyList(Of Value)) As CallInstruction
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call*
  nameWithType.vb: InstructionBuilder.Call(Function, IReadOnlyList(Of Value))
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Function, System.Collections.Generic.IReadOnlyList(Of Ubiquity.NET.Llvm.Values.Value))
  name.vb: Call(Function, IReadOnlyList(Of Value))
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke(Ubiquity.NET.Llvm.Values.Function,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value},Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke(Ubiquity.NET.Llvm.Values.Function,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value},Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)
  id: Invoke(Ubiquity.NET.Llvm.Values.Function,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value},Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Invoke(Function, IReadOnlyList<Value>, BasicBlock, BasicBlock)
  nameWithType: InstructionBuilder.Invoke(Function, IReadOnlyList<Value>, BasicBlock, BasicBlock)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke(Ubiquity.NET.Llvm.Values.Function, System.Collections.Generic.IReadOnlyList<Ubiquity.NET.Llvm.Values.Value>, Ubiquity.NET.Llvm.Values.BasicBlock, Ubiquity.NET.Llvm.Values.BasicBlock)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Invoke
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 346
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an <xref href="Ubiquity.NET.Llvm.Instructions.Invoke" data-throw-if-not-resolved="false"></xref> instruction
  example: []
  syntax:
    content: public Invoke Invoke(Function func, IReadOnlyList<Value> args, BasicBlock then, BasicBlock catchBlock)
    parameters:
    - id: func
      type: Ubiquity.NET.Llvm.Values.Function
      description: Function to invoke
    - id: args
      type: System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value}
      description: arguments to pass to the function
    - id: then
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: Successful continuation block
    - id: catchBlock
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: Exception handling block
    return:
      type: Ubiquity.NET.Llvm.Instructions.Invoke
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Invoke" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function Invoke(func As [Function], args As IReadOnlyList(Of Value), [then] As BasicBlock, catchBlock As BasicBlock) As Invoke
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke*
  nameWithType.vb: InstructionBuilder.Invoke(Function, IReadOnlyList(Of Value), BasicBlock, BasicBlock)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke(Ubiquity.NET.Llvm.Values.Function, System.Collections.Generic.IReadOnlyList(Of Ubiquity.NET.Llvm.Values.Value), Ubiquity.NET.Llvm.Values.BasicBlock, Ubiquity.NET.Llvm.Values.BasicBlock)
  name.vb: Invoke(Function, IReadOnlyList(Of Value), BasicBlock, BasicBlock)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad(Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad(Ubiquity.NET.Llvm.Types.ITypeRef)
  id: LandingPad(Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: LandingPad(ITypeRef)
  nameWithType: InstructionBuilder.LandingPad(ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad(Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: LandingPad
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 374
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Instructions.LandingPad" data-throw-if-not-resolved="false"></xref> instruction
  example: []
  syntax:
    content: public LandingPad LandingPad(ITypeRef resultType)
    parameters:
    - id: resultType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Result type for the pad
    return:
      type: Ubiquity.NET.Llvm.Instructions.LandingPad
      description: <xref href="Ubiquity.NET.Llvm.Instructions.LandingPad" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function LandingPad(resultType As ITypeRef) As LandingPad
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze(Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze(Ubiquity.NET.Llvm.Values.Value)
  id: Freeze(Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Freeze(Value)
  nameWithType: InstructionBuilder.Freeze(Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze(Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Freeze
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 389
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Instructions.Freeze" data-throw-if-not-resolved="false"></xref> instruction
  example: []
  syntax:
    content: public Freeze Freeze(Value value)
    parameters:
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: Value to freeze
    return:
      type: Ubiquity.NET.Llvm.Instructions.Freeze
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Freeze" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function Freeze(value As Value) As Freeze
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume(Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume(Ubiquity.NET.Llvm.Values.Value)
  id: Resume(Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Resume(Value)
  nameWithType: InstructionBuilder.Resume(Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume(Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Resume
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 399
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Instructions.ResumeInstruction" data-throw-if-not-resolved="false"></xref>
  example: []
  syntax:
    content: public ResumeInstruction Resume(Value exception)
    parameters:
    - id: exception
      type: Ubiquity.NET.Llvm.Values.Value
      description: Exception value
    return:
      type: Ubiquity.NET.Llvm.Instructions.ResumeInstruction
      description: <xref href="Ubiquity.NET.Llvm.Instructions.ResumeInstruction" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function [Resume](exception As Value) As ResumeInstruction
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Store(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Store(Value, Value)
  nameWithType: InstructionBuilder.Store(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Store
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 417
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds an LLVM Store instruction
  remarks: >-
    Since store targets memory the type of <code class="paramref">destination</code>

    must be an <xref href="Ubiquity.NET.Llvm.Types.IPointerType" data-throw-if-not-resolved="false"></xref>. Furthermore, the element type of

    the pointer must match the type of <code class="paramref">value</code>. Otherwise,

    an <xref href="System.ArgumentException" data-throw-if-not-resolved="false"></xref> is thrown.
  example: []
  syntax:
    content: public Store Store(Value value, Value destination)
    parameters:
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: Value to store in destination
    - id: destination
      type: Ubiquity.NET.Llvm.Values.Value
      description: value for the destination
    return:
      type: Ubiquity.NET.Llvm.Instructions.Store
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Store" data-throw-if-not-resolved="false"></xref> instruction
    content.vb: Public Function Store(value As Value, destination As Value) As Store
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value)
  id: Load(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Load(ITypeRef, Value)
  nameWithType: InstructionBuilder.Load(ITypeRef, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Load
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 439
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a load instruction
  remarks: >-
    The <code class="paramref">type</code> of the value must be a sized type (e.g. not Opaque with a non-zero size ).

    if <code class="paramref">sourcePtr</code> is a non-opaque pointer then its ElementType must be the same as <code class="paramref">type</code>
  example: []
  syntax:
    content: public Load Load(ITypeRef type, Value sourcePtr)
    parameters:
    - id: type
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Type of the value to load
    - id: sourcePtr
      type: Ubiquity.NET.Llvm.Values.Value
      description: pointer to load the value from
    return:
      type: Ubiquity.NET.Llvm.Instructions.Load
      description: Load instruction
    content.vb: Public Function Load(type As ITypeRef, sourcePtr As Value) As Load
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicXchg(Value, Value)
  nameWithType: InstructionBuilder.AtomicXchg(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicXchg
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 462
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic exchange (Read, Modify, Write) instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicXchg(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicXchg(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicAdd(Value, Value)
  nameWithType: InstructionBuilder.AtomicAdd(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicAdd
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 468
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic add instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicAdd(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicAdd(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicSub(Value, Value)
  nameWithType: InstructionBuilder.AtomicSub(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicSub
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 474
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic subtraction instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicSub(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicSub(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicAnd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicAnd(Value, Value)
  nameWithType: InstructionBuilder.AtomicAnd(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicAnd
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 480
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic AND instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicAnd(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicAnd(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicNand(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicNand(Value, Value)
  nameWithType: InstructionBuilder.AtomicNand(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicNand
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 486
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic NAND instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicNand(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicNand(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicOr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicOr(Value, Value)
  nameWithType: InstructionBuilder.AtomicOr(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicOr
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 492
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic or instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicOr(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicOr(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicXor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicXor(Value, Value)
  nameWithType: InstructionBuilder.AtomicXor(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicXor
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 498
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic XOR instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicXor(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicXor(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicMax(Value, Value)
  nameWithType: InstructionBuilder.AtomicMax(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicMax
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 504
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic ADD instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicMax(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicMax(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicMin(Value, Value)
  nameWithType: InstructionBuilder.AtomicMin(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicMin
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 510
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic MIN instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicMin(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicMin(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicUMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicUMax(Value, Value)
  nameWithType: InstructionBuilder.AtomicUMax(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicUMax
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 516
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic UMax instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicUMax(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicUMax(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicUMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicUMin(Value, Value)
  nameWithType: InstructionBuilder.AtomicUMin(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicUMin
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 522
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic UMin instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicUMin(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicUMin(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicFadd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicFadd(Value, Value)
  nameWithType: InstructionBuilder.AtomicFadd(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicFadd
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 528
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic FAdd instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicFadd(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicFadd(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicFSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicFSub(Value, Value)
  nameWithType: InstructionBuilder.AtomicFSub(Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicFSub
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 534
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic FSub instruction
  example: []
  syntax:
    content: public AtomicRMW AtomicFSub(Value ptr, Value val)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: val
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicRMW
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicFSub(ptr As Value, val As Value) As AtomicRMW
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: AtomicCmpXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AtomicCmpXchg(Value, Value, Value)
  nameWithType: InstructionBuilder.AtomicCmpXchg(Value, Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AtomicCmpXchg
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 541
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an atomic Compare exchange instruction
  example: []
  syntax:
    content: public AtomicCmpXchg AtomicCmpXchg(Value ptr, Value cmp, Value value)
    parameters:
    - id: ptr
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer to the value to update (e.g. destination and the left hand operand)
    - id: cmp
      type: Ubiquity.NET.Llvm.Values.Value
      description: Comparand for the operation
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side operand
    return:
      type: Ubiquity.NET.Llvm.Instructions.AtomicCmpXchg
      description: <xref href="Ubiquity.NET.Llvm.Instructions.AtomicRMW" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AtomicCmpXchg(ptr As Value, cmp As Value, value As Value) As AtomicCmpXchg
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  id: GetStructElementPointer(Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetStructElementPointer(Value, uint)
  nameWithType: InstructionBuilder.GetStructElementPointer(Value, uint)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Values.Value, uint)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetStructElementPointer
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 575
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element (field) of a structure
  example: []
  syntax:
    content: >-
      [Obsolete("Use the overload that takes a type and opaque pointer")]

      public Value GetStructElementPointer(Value pointer, uint index)
    parameters:
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: pointer to the structure to get an element from
    - id: index
      type: System.UInt32
      description: element index
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: >-
      <Obsolete("Use the overload that takes a type and opaque pointer")>

      Public Function GetStructElementPointer(pointer As Value, index As UInteger) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer*
  attributes:
  - type: System.ObsoleteAttribute
    ctor: System.ObsoleteAttribute.#ctor(System.String)
    arguments:
    - type: System.String
      value: Use the overload that takes a type and opaque pointer
  nameWithType.vb: InstructionBuilder.GetStructElementPointer(Value, UInteger)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Values.Value, UInteger)
  name.vb: GetStructElementPointer(Value, UInteger)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  id: GetStructElementPointer(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetStructElementPointer(ITypeRef, Value, uint)
  nameWithType: InstructionBuilder.GetStructElementPointer(ITypeRef, Value, uint)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value, uint)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetStructElementPointer
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 597
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element (field) of a structure
  example: []
  syntax:
    content: public Value GetStructElementPointer(ITypeRef type, Value pointer, uint index)
    parameters:
    - id: type
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Type of the pointer
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: OPaque pointer to the structure to get an element from
    - id: index
      type: System.UInt32
      description: element index
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: Public Function GetStructElementPointer(type As ITypeRef, pointer As Value, index As UInteger) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer*
  nameWithType.vb: InstructionBuilder.GetStructElementPointer(ITypeRef, Value, UInteger)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value, UInteger)
  name.vb: GetStructElementPointer(ITypeRef, Value, UInteger)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  id: GetElementPtr(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetElementPtr(ITypeRef, Value, IEnumerable<Value>)
  nameWithType: InstructionBuilder.GetElementPtr(ITypeRef, Value, IEnumerable<Value>)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value, System.Collections.Generic.IEnumerable<Ubiquity.NET.Llvm.Values.Value>)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetElementPtr
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 629
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element of a type referenced by a pointer
  remarks: >-
    For details on GetElementPointer (GEP) see

    <a href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</a>.

    The basic gist is that the GEP instruction does not access memory, it only computes a pointer

    offset from a base. A common confusion is around the first index and what it means. For C

    and C++ programmers an expression like pFoo-&gt;bar seems to only have a single offset or

    index. However, that is only syntactic sugar where the compiler implicitly hides the first

    index. That is, there is no difference between pFoo[0].bar and pFoo-&gt;bar except that the

    former makes the first index explicit. LLVM requires an explicit first index, even if it is

    zero, in order to properly compute the offset for a given element in an aggregate type.
  example: []
  syntax:
    content: public Value GetElementPtr(ITypeRef type, Value pointer, IEnumerable<Value> args)
    parameters:
    - id: type
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Type of array,vector or structure to get the element pointer from
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: opaque pointer to get an element from
    - id: args
      type: System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value}
      description: additional indices for computing the resulting pointer
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: Public Function GetElementPtr(type As ITypeRef, pointer As Value, args As IEnumerable(Of Value)) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr*
  nameWithType.vb: InstructionBuilder.GetElementPtr(ITypeRef, Value, IEnumerable(Of Value))
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value, System.Collections.Generic.IEnumerable(Of Ubiquity.NET.Llvm.Values.Value))
  name.vb: GetElementPtr(ITypeRef, Value, IEnumerable(Of Value))
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  id: GetElementPtr(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetElementPtr(Value, IEnumerable<Value>)
  nameWithType: InstructionBuilder.GetElementPtr(Value, IEnumerable<Value>)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value, System.Collections.Generic.IEnumerable<Ubiquity.NET.Llvm.Values.Value>)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetElementPtr
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 664
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element of a type referenced by a pointer
  remarks: >-
    For details on GetElementPointer (GEP) see

    <a href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</a>.

    The basic gist is that the GEP instruction does not access memory, it only computes a pointer

    offset from a base. A common confusion is around the first index and what it means. For C

    and C++ programmers an expression like pFoo-&gt;bar seems to only have a single offset or

    index. However, that is only syntactic sugar where the compiler implicitly hides the first

    index. That is, there is no difference between pFoo[0].bar and pFoo-&gt;bar except that the

    former makes the first index explicit. LLVM requires an explicit first index, even if it is

    zero, in order to properly compute the offset for a given element in an aggregate type.
  example: []
  syntax:
    content: public Value GetElementPtr(Value pointer, IEnumerable<Value> args)
    parameters:
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: pointer to get an element from
    - id: args
      type: System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value}
      description: additional indices for computing the resulting pointer
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: Public Function GetElementPtr(pointer As Value, args As IEnumerable(Of Value)) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr*
  nameWithType.vb: InstructionBuilder.GetElementPtr(Value, IEnumerable(Of Value))
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value, System.Collections.Generic.IEnumerable(Of Ubiquity.NET.Llvm.Values.Value))
  name.vb: GetElementPtr(Value, IEnumerable(Of Value))
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  id: GetElementPtr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetElementPtr(Value, params Value[])
  nameWithType: InstructionBuilder.GetElementPtr(Value, params Value[])
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value, params Ubiquity.NET.Llvm.Values.Value[])
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetElementPtr
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 689
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element of a type referenced by a pointer
  remarks: >-
    For details on GetElementPointer (GEP) see

    <a href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</a>.

    The basic gist is that the GEP instruction does not access memory, it only computes a pointer

    offset from a base. A common confusion is around the first index and what it means. For C

    and C++ programmers an expression like pFoo-&gt;bar seems to only have a single offset or

    index. However, that is only syntactic sugar where the compiler implicitly hides the first

    index. That is, there is no difference between pFoo[0].bar and pFoo-&gt;bar except that the

    former makes the first index explicit. LLVM requires an explicit first index, even if it is

    zero, in order to properly compute the offset for a given element in an aggregate type.
  example: []
  syntax:
    content: public Value GetElementPtr(Value pointer, params Value[] args)
    parameters:
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: pointer to get an element from
    - id: args
      type: Ubiquity.NET.Llvm.Values.Value[]
      description: additional indices for computing the resulting pointer
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: Public Function GetElementPtr(pointer As Value, ParamArray args As Value()) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr*
  nameWithType.vb: InstructionBuilder.GetElementPtr(Value, ParamArray Value())
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value, ParamArray Ubiquity.NET.Llvm.Values.Value())
  name.vb: GetElementPtr(Value, ParamArray Value())
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  id: GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetElementPtrInBounds(Value, IEnumerable<Value>)
  nameWithType: InstructionBuilder.GetElementPtrInBounds(Value, IEnumerable<Value>)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value, System.Collections.Generic.IEnumerable<Ubiquity.NET.Llvm.Values.Value>)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetElementPtrInBounds
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 713
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element of a type referenced by a pointer
  remarks: >-
    For details on GetElementPointer (GEP) see

    <a href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</a>.

    The basic gist is that the GEP instruction does not access memory, it only computes a pointer

    offset from a base. A common confusion is around the first index and what it means. For C

    and C++ programmers an expression like pFoo-&gt;bar seems to only have a single offset or

    index. However, that is only syntactic sugar where the compiler implicitly hides the first

    index. That is, there is no difference between pFoo[0].bar and pFoo-&gt;bar except that the

    former makes the first index explicit. LLVM requires an explicit first index, even if it is

    zero, in order to properly compute the offset for a given element in an aggregate type.
  example: []
  syntax:
    content: >-
      [Obsolete("Use overload that takes a pointer type and opaque pointer")]

      public Value GetElementPtrInBounds(Value pointer, IEnumerable<Value> args)
    parameters:
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: pointer to get an element from
    - id: args
      type: System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value}
      description: additional indices for computing the resulting pointer
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: >-
      <Obsolete("Use overload that takes a pointer type and opaque pointer")>

      Public Function GetElementPtrInBounds(pointer As Value, args As IEnumerable(Of Value)) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds*
  attributes:
  - type: System.ObsoleteAttribute
    ctor: System.ObsoleteAttribute.#ctor(System.String)
    arguments:
    - type: System.String
      value: Use overload that takes a pointer type and opaque pointer
  nameWithType.vb: InstructionBuilder.GetElementPtrInBounds(Value, IEnumerable(Of Value))
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value, System.Collections.Generic.IEnumerable(Of Ubiquity.NET.Llvm.Values.Value))
  name.vb: GetElementPtrInBounds(Value, IEnumerable(Of Value))
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  id: GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetElementPtrInBounds(ITypeRef, Value, IEnumerable<Value>)
  nameWithType: InstructionBuilder.GetElementPtrInBounds(ITypeRef, Value, IEnumerable<Value>)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value, System.Collections.Generic.IEnumerable<Ubiquity.NET.Llvm.Values.Value>)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetElementPtrInBounds
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 742
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element of a type referenced by a pointer
  remarks: >-
    For details on GetElementPointer (GEP) see

    <a href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</a>.

    The basic gist is that the GEP instruction does not access memory, it only computes a pointer

    offset from a base. A common confusion is around the first index and what it means. For C

    and C++ programmers an expression like pFoo-&gt;bar seems to only have a single offset or

    index. However, that is only syntactic sugar where the compiler implicitly hides the first

    index. That is, there is no difference between pFoo[0].bar and pFoo-&gt;bar except that the

    former makes the first index explicit. LLVM requires an explicit first index, even if it is

    zero, in order to properly compute the offset for a given element in an aggregate type.
  example: []
  syntax:
    content: public Value GetElementPtrInBounds(ITypeRef type, Value pointer, IEnumerable<Value> args)
    parameters:
    - id: type
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Base pointer type
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: opaque pointer to get an element from
    - id: args
      type: System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value}
      description: additional indices for computing the resulting pointer
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: Public Function GetElementPtrInBounds(type As ITypeRef, pointer As Value, args As IEnumerable(Of Value)) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds*
  nameWithType.vb: InstructionBuilder.GetElementPtrInBounds(ITypeRef, Value, IEnumerable(Of Value))
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value, System.Collections.Generic.IEnumerable(Of Ubiquity.NET.Llvm.Values.Value))
  name.vb: GetElementPtrInBounds(ITypeRef, Value, IEnumerable(Of Value))
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  id: GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetElementPtrInBounds(Value, params Value[])
  nameWithType: InstructionBuilder.GetElementPtrInBounds(Value, params Value[])
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value, params Ubiquity.NET.Llvm.Values.Value[])
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetElementPtrInBounds
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 777
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element of a type referenced by a pointer
  remarks: >-
    For details on GetElementPointer (GEP) see

    <a href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</a>.

    The basic gist is that the GEP instruction does not access memory, it only computes a pointer

    offset from a base. A common confusion is around the first index and what it means. For C

    and C++ programmers an expression like pFoo-&gt;bar seems to only have a single offset or

    index. However that is only syntactic sugar where the compiler implicitly hides the first

    index. That is, there is no difference between pFoo[0].bar and pFoo-&gt;bar except that the

    former makes the first index explicit. LLVM requires an explicit first index, even if it is

    zero, in order to properly compute the offset for a given element in an aggregate type.
  example: []
  syntax:
    content: >-
      [Obsolete("Use overload that accepts base pointer type and na opaque pointer")]

      public Value GetElementPtrInBounds(Value pointer, params Value[] args)
    parameters:
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: pointer to get an element from
    - id: args
      type: Ubiquity.NET.Llvm.Values.Value[]
      description: additional indices for computing the resulting pointer
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: >-
      <Obsolete("Use overload that accepts base pointer type and na opaque pointer")>

      Public Function GetElementPtrInBounds(pointer As Value, ParamArray args As Value()) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds*
  attributes:
  - type: System.ObsoleteAttribute
    ctor: System.ObsoleteAttribute.#ctor(System.String)
    arguments:
    - type: System.String
      value: Use overload that accepts base pointer type and na opaque pointer
  nameWithType.vb: InstructionBuilder.GetElementPtrInBounds(Value, ParamArray Value())
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value, ParamArray Ubiquity.NET.Llvm.Values.Value())
  name.vb: GetElementPtrInBounds(Value, ParamArray Value())
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  id: GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: GetElementPtrInBounds(ITypeRef, Value, params Value[])
  nameWithType: InstructionBuilder.GetElementPtrInBounds(ITypeRef, Value, params Value[])
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value, params Ubiquity.NET.Llvm.Values.Value[])
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: GetElementPtrInBounds
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 806
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element of a type referenced by a pointer
  remarks: >-
    For details on GetElementPointer (GEP) see

    <a href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</a>.

    The basic gist is that the GEP instruction does not access memory, it only computes a pointer

    offset from a base. A common confusion is around the first index and what it means. For C

    and C++ programmers an expression like pFoo-&gt;bar seems to only have a single offset or

    index. However that is only syntactic sugar where the compiler implicitly hides the first

    index. That is, there is no difference between pFoo[0].bar and pFoo-&gt;bar except that the

    former makes the first index explicit. LLVM requires an explicit first index, even if it is

    zero, in order to properly compute the offset for a given element in an aggregate type.
  example: []
  syntax:
    content: public Value GetElementPtrInBounds(ITypeRef type, Value pointer, params Value[] args)
    parameters:
    - id: type
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Base pointer type
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: opaque pointer to get an element from
    - id: args
      type: Ubiquity.NET.Llvm.Values.Value[]
      description: additional indices for computing the resulting pointer
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>

        as LLVM may optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: Public Function GetElementPtrInBounds(type As ITypeRef, pointer As Value, ParamArray args As Value()) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds*
  nameWithType.vb: InstructionBuilder.GetElementPtrInBounds(ITypeRef, Value, ParamArray Value())
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef, Ubiquity.NET.Llvm.Values.Value, ParamArray Ubiquity.NET.Llvm.Values.Value())
  name.vb: GetElementPtrInBounds(ITypeRef, Value, ParamArray Value())
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  id: ConstGetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: ConstGetElementPtrInBounds(Value, params Value[])
  nameWithType: InstructionBuilder.ConstGetElementPtrInBounds(Value, params Value[])
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value, params Ubiquity.NET.Llvm.Values.Value[])
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: ConstGetElementPtrInBounds
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 833
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> that accesses an element of a type referenced by a pointer
  remarks: >-
    For details on GetElementPointer (GEP) see

    <a href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</a>.

    The basic gist is that the GEP instruction does not access memory, it only computes a pointer

    offset from a base. A common confusion is around the first index and what it means. For C

    and C++ programmers an expression like pFoo-&gt;bar seems to only have a single offset or

    index. However that is only syntactic sugar where the compiler implicitly hides the first

    index. That is, there is no difference between pFoo[0].bar and pFoo-&gt;bar except that the

    former makes the first index explicit. LLVM requires an explicit first index, even if it is

    zero, in order to properly compute the offset for a given element in an aggregate type.
  example: []
  syntax:
    content: public static Value ConstGetElementPtrInBounds(Value pointer, params Value[] args)
    parameters:
    - id: pointer
      type: Ubiquity.NET.Llvm.Values.Value
      description: pointer to get an element from
    - id: args
      type: Ubiquity.NET.Llvm.Values.Value[]
      description: additional indices for computing the resulting pointer
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: >-
        <p><xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref> for the member access. This is a User as LLVM may

        optimize the expression to a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> if it

        can so the actual type of the result may be <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref>

        or <xref href="Ubiquity.NET.Llvm.Instructions.GetElementPtr" data-throw-if-not-resolved="false"></xref>.</p>

        <p>Note that <code class="paramref">pointer</code> must be a pointer to a structure

        or an exception is thrown.</p>
    content.vb: Public Shared Function ConstGetElementPtrInBounds(pointer As Value, ParamArray args As Value()) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds*
  nameWithType.vb: InstructionBuilder.ConstGetElementPtrInBounds(Value, ParamArray Value())
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value, ParamArray Ubiquity.NET.Llvm.Values.Value())
  name.vb: ConstGetElementPtrInBounds(Value, ParamArray Value())
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.IPointerType)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.IPointerType)
  id: IntToPointer(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.IPointerType)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: IntToPointer(Value, IPointerType)
  nameWithType: InstructionBuilder.IntToPointer(Value, IPointerType)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.IPointerType)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: IntToPointer
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 850
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds a cast from an integer to a pointer
  remarks: >-
    The actual type of value returned depends on <code class="paramref">intValue</code>

    and is either a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> or an <xref href="Ubiquity.NET.Llvm.Instructions.IntToPointer" data-throw-if-not-resolved="false"></xref>

    instruction. Conversion to a constant expression is performed whenever possible.
  example: []
  syntax:
    content: public Value IntToPointer(Value intValue, IPointerType ptrType)
    parameters:
    - id: intValue
      type: Ubiquity.NET.Llvm.Values.Value
      description: Integer value to cast
    - id: ptrType
      type: Ubiquity.NET.Llvm.Types.IPointerType
      description: pointer type to return
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Resulting value from the cast
    content.vb: Public Function IntToPointer(intValue As Value, ptrType As IPointerType) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: PointerToInt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: PointerToInt(Value, ITypeRef)
  nameWithType: InstructionBuilder.PointerToInt(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: PointerToInt
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 872
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds a cast from a pointer to an integer type
  remarks: >-
    The actual type of value returned depends on <code class="paramref">ptrValue</code>

    and is either a <xref href="Ubiquity.NET.Llvm.Values.ConstantExpression" data-throw-if-not-resolved="false"></xref> or a <xref href="Ubiquity.NET.Llvm.Instructions.PointerToInt" data-throw-if-not-resolved="false"></xref>

    instruction. Conversion to a constant expression is performed whenever possible.
  example: []
  syntax:
    content: public Value PointerToInt(Value ptrValue, ITypeRef intType)
    parameters:
    - id: ptrValue
      type: Ubiquity.NET.Llvm.Values.Value
      description: Pointer value to cast
    - id: intType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Integer type to return
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Resulting value from the cast
    content.vb: Public Function PointerToInt(ptrValue As Value, intType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.BasicBlock)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.BasicBlock)
  id: Branch(Ubiquity.NET.Llvm.Values.BasicBlock)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Branch(BasicBlock)
  nameWithType: InstructionBuilder.Branch(BasicBlock)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.BasicBlock)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Branch
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 897
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Create an unconditional branch
  example: []
  syntax:
    content: public Branch Branch(BasicBlock target)
    parameters:
    - id: target
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: Target block for the branch
    return:
      type: Ubiquity.NET.Llvm.Instructions.Branch
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Branch" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function Branch(target As BasicBlock) As Branch
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)
  id: Branch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Branch(Value, BasicBlock, BasicBlock)
  nameWithType: InstructionBuilder.Branch(Value, BasicBlock, BasicBlock)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.BasicBlock, Ubiquity.NET.Llvm.Values.BasicBlock)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Branch
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 908
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a conditional branch instruction
  example: []
  syntax:
    content: public Branch Branch(Value ifCondition, BasicBlock thenTarget, BasicBlock elseTarget)
    parameters:
    - id: ifCondition
      type: Ubiquity.NET.Llvm.Values.Value
      description: Condition for the branch
    - id: thenTarget
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: Target block for the branch when <code class="paramref">ifCondition</code> evaluates to a non-zero value
    - id: elseTarget
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: Target block for the branch when <code class="paramref">ifCondition</code> evaluates to a zero value
    return:
      type: Ubiquity.NET.Llvm.Instructions.Branch
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Branch" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function Branch(ifCondition As Value, thenTarget As BasicBlock, elseTarget As BasicBlock) As Branch
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable
  id: Unreachable
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Unreachable()
  nameWithType: InstructionBuilder.Unreachable()
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable()
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Unreachable
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 925
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an <xref href="Ubiquity.NET.Llvm.Instructions.Unreachable" data-throw-if-not-resolved="false"></xref> instruction
  example: []
  syntax:
    content: public Unreachable Unreachable()
    return:
      type: Ubiquity.NET.Llvm.Instructions.Unreachable
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Unreachable" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function Unreachable() As Unreachable
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.IntPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.IntPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Compare(Ubiquity.NET.Llvm.Instructions.IntPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Compare(IntPredicate, Value, Value)
  nameWithType: InstructionBuilder.Compare(IntPredicate, Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.IntPredicate, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Compare
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 933
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds an Integer compare instruction
  example: []
  syntax:
    content: public Value Compare(IntPredicate predicate, Value lhs, Value rhs)
    parameters:
    - id: predicate
      type: Ubiquity.NET.Llvm.Instructions.IntPredicate
      description: Integer predicate for the comparison
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Left hand side of the comparison
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side of the comparison
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Comparison instruction
    content.vb: Public Function Compare(predicate As IntPredicate, lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.RealPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.RealPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Compare(Ubiquity.NET.Llvm.Instructions.RealPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Compare(RealPredicate, Value, Value)
  nameWithType: InstructionBuilder.Compare(RealPredicate, Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.RealPredicate, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Compare
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 958
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds a Floating point compare instruction
  example: []
  syntax:
    content: public Value Compare(RealPredicate predicate, Value lhs, Value rhs)
    parameters:
    - id: predicate
      type: Ubiquity.NET.Llvm.Instructions.RealPredicate
      description: predicate for the comparison
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Left hand side of the comparison
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side of the comparison
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Comparison instruction
    content.vb: Public Function Compare(predicate As RealPredicate, lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.Predicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.Predicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Compare(Ubiquity.NET.Llvm.Instructions.Predicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Compare(Predicate, Value, Value)
  nameWithType: InstructionBuilder.Compare(Predicate, Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.Predicate, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Compare
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 988
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds a compare instruction
  example: []
  syntax:
    content: public Value Compare(Predicate predicate, Value lhs, Value rhs)
    parameters:
    - id: predicate
      type: Ubiquity.NET.Llvm.Instructions.Predicate
      description: predicate for the comparison
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Left hand side of the comparison
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side of the comparison
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Comparison instruction
    content.vb: Public Function Compare(predicate As Predicate, lhs As Value, rhs As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: ZeroExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: ZeroExtendOrBitCast(Value, ITypeRef)
  nameWithType: InstructionBuilder.ZeroExtendOrBitCast(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: ZeroExtendOrBitCast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1011
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a zero extend or bit cast instruction
  example: []
  syntax:
    content: public Value ZeroExtendOrBitCast(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function ZeroExtendOrBitCast(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: SignExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: SignExtendOrBitCast(Value, ITypeRef)
  nameWithType: InstructionBuilder.SignExtendOrBitCast(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: SignExtendOrBitCast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1030
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a sign extend or bit cast instruction
  example: []
  syntax:
    content: public Value SignExtendOrBitCast(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function SignExtendOrBitCast(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: TruncOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: TruncOrBitCast(Value, ITypeRef)
  nameWithType: InstructionBuilder.TruncOrBitCast(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: TruncOrBitCast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1049
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a trunc or bit cast instruction
  example: []
  syntax:
    content: public Value TruncOrBitCast(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function TruncOrBitCast(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: ZeroExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: ZeroExtend(Value, ITypeRef)
  nameWithType: InstructionBuilder.ZeroExtend(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: ZeroExtend
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1072
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a Zero Extend instruction
  example: []
  syntax:
    content: public Value ZeroExtend(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function ZeroExtend(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: SignExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: SignExtend(Value, ITypeRef)
  nameWithType: InstructionBuilder.SignExtend(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: SignExtend
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1085
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a Sign Extend instruction
  example: []
  syntax:
    content: public Value SignExtend(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function SignExtend(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: BitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: BitCast(Value, ITypeRef)
  nameWithType: InstructionBuilder.BitCast(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: BitCast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1098
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a bitcast instruction
  example: []
  syntax:
    content: public Value BitCast(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function BitCast(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean)
  id: IntCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: IntCast(Value, ITypeRef, bool)
  nameWithType: InstructionBuilder.IntCast(Value, ITypeRef, bool)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef, bool)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: IntCast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1122
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an integer cast instruction
  example: []
  syntax:
    content: public Value IntCast(Value valueRef, ITypeRef targetType, bool isSigned)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    - id: isSigned
      type: System.Boolean
      description: Flag to indicate if the cast is signed or unsigned
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function IntCast(valueRef As Value, targetType As ITypeRef, isSigned As Boolean) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast*
  nameWithType.vb: InstructionBuilder.IntCast(Value, ITypeRef, Boolean)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef, Boolean)
  name.vb: IntCast(Value, ITypeRef, Boolean)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: Trunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Trunc(Value, ITypeRef)
  nameWithType: InstructionBuilder.Trunc(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Trunc
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1135
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a trunc instruction
  example: []
  syntax:
    content: public Value Trunc(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function Trunc(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: SIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: SIToFPCast(Value, ITypeRef)
  nameWithType: InstructionBuilder.SIToFPCast(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: SIToFPCast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1151
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a signed integer to floating point cast instruction
  example: []
  syntax:
    content: public Value SIToFPCast(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function SIToFPCast(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: UIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: UIToFPCast(Value, ITypeRef)
  nameWithType: InstructionBuilder.UIToFPCast(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: UIToFPCast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1164
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an unsigned integer to floating point cast instruction
  example: []
  syntax:
    content: public Value UIToFPCast(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function UIToFPCast(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: FPToUICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FPToUICast(Value, ITypeRef)
  nameWithType: InstructionBuilder.FPToUICast(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FPToUICast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1177
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a Floating point to unsigned integer cast instruction
  example: []
  syntax:
    content: public Value FPToUICast(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function FPToUICast(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: FPToSICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FPToSICast(Value, ITypeRef)
  nameWithType: InstructionBuilder.FPToSICast(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FPToSICast
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1190
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point to signed integer cast instruction
  example: []
  syntax:
    content: public Value FPToSICast(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function FPToSICast(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: FPExt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FPExt(Value, ITypeRef)
  nameWithType: InstructionBuilder.FPExt(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FPExt
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1203
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point extend instruction
  example: []
  syntax:
    content: public Value FPExt(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function FPExt(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  id: FPTrunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: FPTrunc(Value, ITypeRef)
  nameWithType: InstructionBuilder.FPTrunc(Value, ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: FPTrunc
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1216
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a floating point truncate instruction
  example: []
  syntax:
    content: public Value FPTrunc(Value valueRef, ITypeRef targetType)
    parameters:
    - id: valueRef
      type: Ubiquity.NET.Llvm.Values.Value
      description: Operand for the instruction
    - id: targetType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Target type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function FPTrunc(valueRef As Value, targetType As ITypeRef) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  id: Select(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Select(Value, Value, Value)
  nameWithType: InstructionBuilder.Select(Value, Value, Value)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Select
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1234
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds a <xref href="Ubiquity.NET.Llvm.Instructions.SelectInstruction" data-throw-if-not-resolved="false"></xref> instruction
  remarks: >-
    If <code class="paramref">ifCondition</code> is a vector then both values must be a vector of the same

    size and the selection is performed element by element. The values must be the same type.
  example: []
  syntax:
    content: public Value Select(Value ifCondition, Value thenValue, Value elseValue)
    parameters:
    - id: ifCondition
      type: Ubiquity.NET.Llvm.Values.Value
      description: Value for the condition to select between the values
    - id: thenValue
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result value if <code class="paramref">ifCondition</code> evaluates to 1
    - id: elseValue
      type: Ubiquity.NET.Llvm.Values.Value
      description: Result value if <code class="paramref">ifCondition</code> evaluates to 0
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Selected value
    content.vb: Public Function [Select](ifCondition As Value, thenValue As Value, elseValue As Value) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode(Ubiquity.NET.Llvm.Types.ITypeRef)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode(Ubiquity.NET.Llvm.Types.ITypeRef)
  id: PhiNode(Ubiquity.NET.Llvm.Types.ITypeRef)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: PhiNode(ITypeRef)
  nameWithType: InstructionBuilder.PhiNode(ITypeRef)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode(Ubiquity.NET.Llvm.Types.ITypeRef)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: PhiNode
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1279
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a Phi instruction
  example: []
  syntax:
    content: public PhiNode PhiNode(ITypeRef resultType)
    parameters:
    - id: resultType
      type: Ubiquity.NET.Llvm.Types.ITypeRef
      description: Result type for the instruction
    return:
      type: Ubiquity.NET.Llvm.Instructions.PhiNode
      description: <xref href="Ubiquity.NET.Llvm.Instructions.PhiNode" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function PhiNode(resultType As ITypeRef) As PhiNode
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue(Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue(Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  id: ExtractValue(Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: ExtractValue(Value, uint)
  nameWithType: InstructionBuilder.ExtractValue(Value, uint)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue(Ubiquity.NET.Llvm.Values.Value, uint)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: ExtractValue
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1289
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates an extractvalue instruction
  example: []
  syntax:
    content: public Value ExtractValue(Value instance, uint index)
    parameters:
    - id: instance
      type: Ubiquity.NET.Llvm.Values.Value
      description: Instance to extract a value from
    - id: index
      type: System.UInt32
      description: index of the element to extract
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Value for the instruction
    content.vb: Public Function ExtractValue(instance As Value, index As UInteger) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue*
  nameWithType.vb: InstructionBuilder.ExtractValue(Value, UInteger)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue(Ubiquity.NET.Llvm.Values.Value, UInteger)
  name.vb: ExtractValue(Value, UInteger)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,System.UInt32)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,System.UInt32)
  id: Switch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,System.UInt32)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Switch(Value, BasicBlock, uint)
  nameWithType: InstructionBuilder.Switch(Value, BasicBlock, uint)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.BasicBlock, uint)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Switch
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1306
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a switch instruction
  remarks: >-
    Callers can use <xref href="Ubiquity.NET.Llvm.Instructions.Switch.AddCase(Ubiquity.NET.Llvm.Values.Value%2cUbiquity.NET.Llvm.Values.BasicBlock)" data-throw-if-not-resolved="false"></xref> to add cases to the

    instruction.
  example: []
  syntax:
    content: public Switch Switch(Value value, BasicBlock defaultCase, uint numCases)
    parameters:
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: Value to switch on
    - id: defaultCase
      type: Ubiquity.NET.Llvm.Values.BasicBlock
      description: default case if <code class="paramref">value</code> does match any case
    - id: numCases
      type: System.UInt32
      description: Number of cases for the switch
    return:
      type: Ubiquity.NET.Llvm.Instructions.Switch
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Switch" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function Switch(value As Value, defaultCase As BasicBlock, numCases As UInteger) As Switch
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch*
  nameWithType.vb: InstructionBuilder.Switch(Value, BasicBlock, UInteger)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.BasicBlock, UInteger)
  name.vb: Switch(Value, BasicBlock, UInteger)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing
  id: DoNothing
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: DoNothing()
  nameWithType: InstructionBuilder.DoNothing()
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing()
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: DoNothing
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1320
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a call to the llvm.donothing intrinsic
  example: []
  syntax:
    content: public CallInstruction DoNothing()
    return:
      type: Ubiquity.NET.Llvm.Instructions.CallInstruction
      description: <xref href="Ubiquity.NET.Llvm.Instructions.CallInstruction" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function DoNothing() As CallInstruction
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: <xref href="Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock" data-throw-if-not-resolved="false"></xref> is <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/null">null</a> or it's <xref href="Ubiquity.NET.Llvm.Values.BasicBlock.ContainingFunction" data-throw-if-not-resolved="false"></xref> is null or has a <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/null">null</a> <xref href="Ubiquity.NET.Llvm.Values.GlobalValue.ParentModule" data-throw-if-not-resolved="false"></xref>
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap
  id: DebugTrap
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: DebugTrap()
  nameWithType: InstructionBuilder.DebugTrap()
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap()
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: DebugTrap
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1330
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a llvm.debugtrap call
  example: []
  syntax:
    content: public CallInstruction DebugTrap()
    return:
      type: Ubiquity.NET.Llvm.Instructions.CallInstruction
      description: <xref href="Ubiquity.NET.Llvm.Instructions.CallInstruction" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function DebugTrap() As CallInstruction
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap
  id: Trap
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: Trap()
  nameWithType: InstructionBuilder.Trap()
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap()
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: Trap
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1340
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Creates a llvm.trap call
  example: []
  syntax:
    content: public CallInstruction Trap()
    return:
      type: Ubiquity.NET.Llvm.Instructions.CallInstruction
      description: <xref href="Ubiquity.NET.Llvm.Instructions.CallInstruction" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function Trap() As CallInstruction
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap*
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  id: MemCpy(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: MemCpy(Value, Value, Value, bool)
  nameWithType: InstructionBuilder.MemCpy(Value, Value, Value, bool)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, bool)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: MemCpy
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1359
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds a memcpy intrinsic call
  remarks: >-
    LLVM has many overloaded variants of the memcpy intrinsic, this implementation will deduce the types from

    the provided values and generate a more specific call without the need to provide overloaded forms of this

    method and otherwise complicating the calling code.
  example: []
  syntax:
    content: public Value MemCpy(Value destination, Value source, Value len, bool isVolatile)
    parameters:
    - id: destination
      type: Ubiquity.NET.Llvm.Values.Value
      description: Destination pointer of the memcpy
    - id: source
      type: Ubiquity.NET.Llvm.Values.Value
      description: Source pointer of the memcpy
    - id: len
      type: Ubiquity.NET.Llvm.Values.Value
      description: length of the data to copy
    - id: isVolatile
      type: System.Boolean
      description: Flag to indicate if the copy involves volatile data such as physical registers
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Intrinsic" data-throw-if-not-resolved="false"></xref> call for the memcpy
    content.vb: Public Function MemCpy(destination As Value, source As Value, len As Value, isVolatile As Boolean) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy*
  nameWithType.vb: InstructionBuilder.MemCpy(Value, Value, Value, Boolean)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Boolean)
  name.vb: MemCpy(Value, Value, Value, Boolean)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  id: MemMove(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: MemMove(Value, Value, Value, bool)
  nameWithType: InstructionBuilder.MemMove(Value, Value, Value, bool)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, bool)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: MemMove
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1414
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds a memmove intrinsic call
  remarks: >-
    LLVM has many overloaded variants of the memmove intrinsic, this implementation will deduce the types from

    the provided values and generate a more specific call without the need to provide overloaded forms of this

    method and otherwise complicating the calling code.
  example: []
  syntax:
    content: public Value MemMove(Value destination, Value source, Value len, bool isVolatile)
    parameters:
    - id: destination
      type: Ubiquity.NET.Llvm.Values.Value
      description: Destination pointer of the memmove
    - id: source
      type: Ubiquity.NET.Llvm.Values.Value
      description: Source pointer of the memmove
    - id: len
      type: Ubiquity.NET.Llvm.Values.Value
      description: length of the data to copy
    - id: isVolatile
      type: System.Boolean
      description: Flag to indicate if the copy involves volatile data such as physical registers
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Intrinsic" data-throw-if-not-resolved="false"></xref> call for the memmove
    content.vb: Public Function MemMove(destination As Value, source As Value, len As Value, isVolatile As Boolean) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove*
  nameWithType.vb: InstructionBuilder.MemMove(Value, Value, Value, Boolean)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Boolean)
  name.vb: MemMove(Value, Value, Value, Boolean)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  id: MemSet(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: MemSet(Value, Value, Value, bool)
  nameWithType: InstructionBuilder.MemSet(Value, Value, Value, bool)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, bool)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: MemSet
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1464
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds a memset intrinsic call
  remarks: >-
    LLVM has many overloaded variants of the memset intrinsic, this implementation will deduce the types from

    the provided values and generate a more specific call without the need to provide overloaded forms of this

    method and otherwise complicating the calling code.
  example: []
  syntax:
    content: public Value MemSet(Value destination, Value value, Value len, bool isVolatile)
    parameters:
    - id: destination
      type: Ubiquity.NET.Llvm.Values.Value
      description: Destination pointer of the memset
    - id: value
      type: Ubiquity.NET.Llvm.Values.Value
      description: fill value for the memset
    - id: len
      type: Ubiquity.NET.Llvm.Values.Value
      description: length of the data to fill
    - id: isVolatile
      type: System.Boolean
      description: Flag to indicate if the fill involves volatile data such as physical registers
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: <xref href="Ubiquity.NET.Llvm.Instructions.Intrinsic" data-throw-if-not-resolved="false"></xref> call for the memset
    content.vb: Public Function MemSet(destination As Value, value As Value, len As Value, isVolatile As Boolean) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet*
  nameWithType.vb: InstructionBuilder.MemSet(Value, Value, Value, Boolean)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Boolean)
  name.vb: MemSet(Value, Value, Value, Boolean)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  id: InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.UInt32)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: InsertValue(Value, Value, uint)
  nameWithType: InstructionBuilder.InsertValue(Value, Value, uint)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, uint)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: InsertValue
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1509
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Builds an <xref href="Ubiquity.NET.Llvm.Instructions.InsertValue" data-throw-if-not-resolved="false"></xref> instruction
  example: []
  syntax:
    content: public Value InsertValue(Value aggValue, Value elementValue, uint index)
    parameters:
    - id: aggValue
      type: Ubiquity.NET.Llvm.Values.Value
      description: Aggregate value to insert <code class="paramref">elementValue</code> into
    - id: elementValue
      type: Ubiquity.NET.Llvm.Values.Value
      description: Value to insert into <code class="paramref">aggValue</code>
    - id: index
      type: System.UInt32
      description: Index to insert the value into
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Instruction as a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function InsertValue(aggValue As Value, elementValue As Value, index As UInteger) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue*
  nameWithType.vb: InstructionBuilder.InsertValue(Value, Value, UInteger)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, UInteger)
  name.vb: InsertValue(Value, Value, UInteger)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  id: AddWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: AddWithOverflow(Value, Value, bool)
  nameWithType: InstructionBuilder.AddWithOverflow(Value, Value, bool)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, bool)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: AddWithOverflow
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1523
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Generates a call to the llvm.[s|u]add.with.overflow intrinsic
  example: []
  syntax:
    content: public Value AddWithOverflow(Value lhs, Value rhs, bool signed)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Left hand side of the operation
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side of the operation
    - id: signed
      type: System.Boolean
      description: Flag to indicate if the operation is signed <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/bool">true</a> or unsigned <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/bool">false</a>
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Instruction as a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function AddWithOverflow(lhs As Value, rhs As Value, signed As Boolean) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow*
  nameWithType.vb: InstructionBuilder.AddWithOverflow(Value, Value, Boolean)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Boolean)
  name.vb: AddWithOverflow(Value, Value, Boolean)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  id: SubWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: SubWithOverflow(Value, Value, bool)
  nameWithType: InstructionBuilder.SubWithOverflow(Value, Value, bool)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, bool)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: SubWithOverflow
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1541
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Generates a call to the llvm.[s|u]sub.with.overflow intrinsic
  example: []
  syntax:
    content: public Value SubWithOverflow(Value lhs, Value rhs, bool signed)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Left hand side of the operation
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side of the operation
    - id: signed
      type: System.Boolean
      description: Flag to indicate if the operation is signed <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/bool">true</a> or unsigned <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/bool">false</a>
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Instruction as a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function SubWithOverflow(lhs As Value, rhs As Value, signed As Boolean) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow*
  nameWithType.vb: InstructionBuilder.SubWithOverflow(Value, Value, Boolean)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Boolean)
  name.vb: SubWithOverflow(Value, Value, Boolean)
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  commentId: M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  id: MulWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)
  parent: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  langs:
  - csharp
  - vb
  name: MulWithOverflow(Value, Value, bool)
  nameWithType: InstructionBuilder.MulWithOverflow(Value, Value, bool)
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, bool)
  type: Method
  source:
    remote:
      path: src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
      branch: LLVM20
      repo: https://github.com/smaillet/Llvm.NET.git
    id: MulWithOverflow
    path: ../src/Ubiquity.NET.Llvm/Instructions/InstructionBuilder.cs
    startLine: 1560
  assemblies:
  - Ubiquity.NET.Llvm
  namespace: Ubiquity.NET.Llvm.Instructions
  summary: Generates a call to the llvm.[s|u]mul.with.overflow intrinsic
  example: []
  syntax:
    content: public Value MulWithOverflow(Value lhs, Value rhs, bool signed)
    parameters:
    - id: lhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Left hand side of the operation
    - id: rhs
      type: Ubiquity.NET.Llvm.Values.Value
      description: Right hand side of the operation
    - id: signed
      type: System.Boolean
      description: Flag to indicate if the operation is signed <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/bool">true</a> or unsigned <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/bool">false</a>
    return:
      type: Ubiquity.NET.Llvm.Values.Value
      description: Instruction as a <xref href="Ubiquity.NET.Llvm.Values.Value" data-throw-if-not-resolved="false"></xref>
    content.vb: Public Function MulWithOverflow(lhs As Value, rhs As Value, signed As Boolean) As Value
  overload: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow*
  nameWithType.vb: InstructionBuilder.MulWithOverflow(Value, Value, Boolean)
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.Value, Boolean)
  name.vb: MulWithOverflow(Value, Value, Boolean)
references:
- uid: Ubiquity.NET.Llvm.Instructions
  commentId: N:Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.html
  name: Ubiquity.NET.Llvm.Instructions
  nameWithType: Ubiquity.NET.Llvm.Instructions
  fullName: Ubiquity.NET.Llvm.Instructions
  spec.csharp:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  - name: .
  - uid: Ubiquity.NET.Llvm.Instructions
    name: Instructions
    href: Ubiquity.NET.Llvm.Instructions.html
  spec.vb:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  - name: .
  - uid: Ubiquity.NET.Llvm.Instructions
    name: Instructions
    href: Ubiquity.NET.Llvm.Instructions.html
- uid: System.Object
  commentId: T:System.Object
  parent: System
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.object
  name: object
  nameWithType: object
  fullName: object
  nameWithType.vb: Object
  fullName.vb: Object
  name.vb: Object
- uid: System.IDisposable
  commentId: T:System.IDisposable
  parent: System
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.idisposable
  name: IDisposable
  nameWithType: IDisposable
  fullName: System.IDisposable
- uid: System.Object.Equals(System.Object)
  commentId: M:System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)
  name: Equals(object)
  nameWithType: object.Equals(object)
  fullName: object.Equals(object)
  nameWithType.vb: Object.Equals(Object)
  fullName.vb: Object.Equals(Object)
  name.vb: Equals(Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)
  - name: (
  - uid: System.Object
    name: object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)
  - name: (
  - uid: System.Object
    name: Object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: )
- uid: System.Object.Equals(System.Object,System.Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)
  name: Equals(object, object)
  nameWithType: object.Equals(object, object)
  fullName: object.Equals(object, object)
  nameWithType.vb: Object.Equals(Object, Object)
  fullName.vb: Object.Equals(Object, Object)
  name.vb: Equals(Object, Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)
  - name: (
  - uid: System.Object
    name: object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: ','
  - name: " "
  - uid: System.Object
    name: object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)
  - name: (
  - uid: System.Object
    name: Object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: ','
  - name: " "
  - uid: System.Object
    name: Object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: )
- uid: System.Object.GetHashCode
  commentId: M:System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.object.gethashcode
  name: GetHashCode()
  nameWithType: object.GetHashCode()
  fullName: object.GetHashCode()
  nameWithType.vb: Object.GetHashCode()
  fullName.vb: Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.gethashcode
  - name: (
  - name: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.gethashcode
  - name: (
  - name: )
- uid: System.Object.GetType
  commentId: M:System.Object.GetType
  parent: System.Object
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.object.gettype
  name: GetType()
  nameWithType: object.GetType()
  fullName: object.GetType()
  nameWithType.vb: Object.GetType()
  fullName.vb: Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.gettype
  - name: (
  - name: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.gettype
  - name: (
  - name: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.object.referenceequals
  name: ReferenceEquals(object, object)
  nameWithType: object.ReferenceEquals(object, object)
  fullName: object.ReferenceEquals(object, object)
  nameWithType.vb: Object.ReferenceEquals(Object, Object)
  fullName.vb: Object.ReferenceEquals(Object, Object)
  name.vb: ReferenceEquals(Object, Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.referenceequals
  - name: (
  - uid: System.Object
    name: object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: ','
  - name: " "
  - uid: System.Object
    name: object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.referenceequals
  - name: (
  - uid: System.Object
    name: Object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: ','
  - name: " "
  - uid: System.Object
    name: Object
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object
  - name: )
- uid: System.Object.ToString
  commentId: M:System.Object.ToString
  parent: System.Object
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.object.tostring
  name: ToString()
  nameWithType: object.ToString()
  fullName: object.ToString()
  nameWithType.vb: Object.ToString()
  fullName.vb: Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.tostring
  - name: (
  - name: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.object.tostring
  - name: (
  - name: )
- uid: System
  commentId: N:System
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system
  name: System
  nameWithType: System
  fullName: System
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Dispose*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Dispose
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Dispose
  name: Dispose
  nameWithType: InstructionBuilder.Dispose
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Dispose
- uid: System.IDisposable.Dispose
  commentId: M:System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.idisposable.dispose
  name: Dispose()
  nameWithType: IDisposable.Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.idisposable.dispose
  - name: (
  - name: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.idisposable.dispose
  - name: (
  - name: )
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  commentId: T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html
  name: InstructionBuilder
  nameWithType: InstructionBuilder
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder
- uid: Ubiquity.NET.Llvm.ContextAlias
  commentId: T:Ubiquity.NET.Llvm.ContextAlias
  name: ContextAlias
  nameWithType: ContextAlias
  fullName: Ubiquity.NET.Llvm.ContextAlias
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder__ctor_Ubiquity_NET_Llvm_IContext_
  name: InstructionBuilder
  nameWithType: InstructionBuilder.InstructionBuilder
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InstructionBuilder
  nameWithType.vb: InstructionBuilder.New
  fullName.vb: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.New
  name.vb: New
- uid: Ubiquity.NET.Llvm.IContext
  commentId: T:Ubiquity.NET.Llvm.IContext
  parent: Ubiquity.NET.Llvm
  href: Ubiquity.NET.Llvm.IContext.html
  name: IContext
  nameWithType: IContext
  fullName: Ubiquity.NET.Llvm.IContext
- uid: Ubiquity.NET.Llvm
  commentId: N:Ubiquity.NET.Llvm
  href: Ubiquity.html
  name: Ubiquity.NET.Llvm
  nameWithType: Ubiquity.NET.Llvm
  fullName: Ubiquity.NET.Llvm
  spec.csharp:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  spec.vb:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
- uid: Ubiquity.NET.Llvm.Values.BasicBlock
  commentId: T:Ubiquity.NET.Llvm.Values.BasicBlock
  parent: Ubiquity.NET.Llvm.Values
  href: Ubiquity.NET.Llvm.Values.BasicBlock.html
  name: BasicBlock
  nameWithType: BasicBlock
  fullName: Ubiquity.NET.Llvm.Values.BasicBlock
- uid: Ubiquity.NET.Llvm.Values
  commentId: N:Ubiquity.NET.Llvm.Values
  href: Ubiquity.html
  name: Ubiquity.NET.Llvm.Values
  nameWithType: Ubiquity.NET.Llvm.Values
  fullName: Ubiquity.NET.Llvm.Values
  spec.csharp:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  - name: .
  - uid: Ubiquity.NET.Llvm.Values
    name: Values
    href: Ubiquity.NET.Llvm.Values.html
  spec.vb:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  - name: .
  - uid: Ubiquity.NET.Llvm.Values
    name: Values
    href: Ubiquity.NET.Llvm.Values.html
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Context
  name: Context
  nameWithType: InstructionBuilder.Context
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_CurrentDebugLocation
  name: CurrentDebugLocation
  nameWithType: InstructionBuilder.CurrentDebugLocation
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation
- uid: Ubiquity.NET.Llvm.DebugInfo.DILocation
  commentId: T:Ubiquity.NET.Llvm.DebugInfo.DILocation
  parent: Ubiquity.NET.Llvm.DebugInfo
  href: Ubiquity.NET.Llvm.DebugInfo.DILocation.html
  name: DILocation
  nameWithType: DILocation
  fullName: Ubiquity.NET.Llvm.DebugInfo.DILocation
- uid: Ubiquity.NET.Llvm.DebugInfo
  commentId: N:Ubiquity.NET.Llvm.DebugInfo
  href: Ubiquity.html
  name: Ubiquity.NET.Llvm.DebugInfo
  nameWithType: Ubiquity.NET.Llvm.DebugInfo
  fullName: Ubiquity.NET.Llvm.DebugInfo
  spec.csharp:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  - name: .
  - uid: Ubiquity.NET.Llvm.DebugInfo
    name: DebugInfo
    href: Ubiquity.NET.Llvm.DebugInfo.html
  spec.vb:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  - name: .
  - uid: Ubiquity.NET.Llvm.DebugInfo
    name: DebugInfo
    href: Ubiquity.NET.Llvm.DebugInfo.html
- uid: Ubiquity.NET.Llvm.DebugInfo.DILocalScope
  commentId: T:Ubiquity.NET.Llvm.DebugInfo.DILocalScope
  parent: Ubiquity.NET.Llvm.DebugInfo
  href: Ubiquity.NET.Llvm.DebugInfo.DILocalScope.html
  name: DILocalScope
  nameWithType: DILocalScope
  fullName: Ubiquity.NET.Llvm.DebugInfo.DILocalScope
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_SetDebugLocation_System_UInt32_System_UInt32_Ubiquity_NET_Llvm_DebugInfo_DILocalScope_Ubiquity_NET_Llvm_DebugInfo_DILocation_
  name: SetDebugLocation
  nameWithType: InstructionBuilder.SetDebugLocation
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation
- uid: System.UInt32
  commentId: T:System.UInt32
  parent: System
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.uint32
  name: uint
  nameWithType: uint
  fullName: uint
  nameWithType.vb: UInteger
  fullName.vb: UInteger
  name.vb: UInteger
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_InsertBlock
  name: InsertBlock
  nameWithType: InstructionBuilder.InsertBlock
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_InsertFunction
  name: InsertFunction
  nameWithType: InstructionBuilder.InsertFunction
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction
- uid: Ubiquity.NET.Llvm.Values.Function
  commentId: T:Ubiquity.NET.Llvm.Values.Function
  parent: Ubiquity.NET.Llvm.Values
  href: Ubiquity.NET.Llvm.Values.Function.html
  name: Function
  nameWithType: Function
  fullName: Ubiquity.NET.Llvm.Values.Function
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_PositionAtEnd_Ubiquity_NET_Llvm_Values_BasicBlock_
  name: PositionAtEnd
  nameWithType: InstructionBuilder.PositionAtEnd
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_PositionBefore_Ubiquity_NET_Llvm_Instructions_Instruction_
  name: PositionBefore
  nameWithType: InstructionBuilder.PositionBefore
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore
- uid: Ubiquity.NET.Llvm.Instructions.Instruction
  commentId: T:Ubiquity.NET.Llvm.Instructions.Instruction
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Instruction.html
  name: Instruction
  nameWithType: Instruction
  fullName: Ubiquity.NET.Llvm.Instructions.Instruction
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
  commentId: P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_InsertBlock
  name: InsertBlock
  nameWithType: InstructionBuilder.InsertBlock
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AppendBasicBlock_Ubiquity_NET_Llvm_Values_BasicBlock_
  name: AppendBasicBlock
  nameWithType: InstructionBuilder.AppendBasicBlock
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock
- uid: Ubiquity.NET.Llvm.Values.Value
  commentId: T:Ubiquity.NET.Llvm.Values.Value
  parent: Ubiquity.NET.Llvm.Values
  href: Ubiquity.NET.Llvm.Values.Value.html
  name: Value
  nameWithType: Value
  fullName: Ubiquity.NET.Llvm.Values.Value
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FNeg_Ubiquity_NET_Llvm_Values_Value_
  name: FNeg
  nameWithType: InstructionBuilder.FNeg
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FAdd_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: FAdd
  nameWithType: InstructionBuilder.FAdd
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FSub_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: FSub
  nameWithType: InstructionBuilder.FSub
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FMul_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: FMul
  nameWithType: InstructionBuilder.FMul
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FDiv_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: FDiv
  nameWithType: InstructionBuilder.FDiv
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FRem_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: FRem
  nameWithType: InstructionBuilder.FRem
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Neg_Ubiquity_NET_Llvm_Values_Value_
  name: Neg
  nameWithType: InstructionBuilder.Neg
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Not_Ubiquity_NET_Llvm_Values_Value_
  name: Not
  nameWithType: InstructionBuilder.Not
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Add_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: Add
  nameWithType: InstructionBuilder.Add
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_And_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: And
  nameWithType: InstructionBuilder.And
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Sub_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: Sub
  nameWithType: InstructionBuilder.Sub
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Mul_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: Mul
  nameWithType: InstructionBuilder.Mul
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_ShiftLeft_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: ShiftLeft
  nameWithType: InstructionBuilder.ShiftLeft
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_ArithmeticShiftRight_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: ArithmeticShiftRight
  nameWithType: InstructionBuilder.ArithmeticShiftRight
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_LogicalShiftRight_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: LogicalShiftRight
  nameWithType: InstructionBuilder.LogicalShiftRight
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_UDiv_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: UDiv
  nameWithType: InstructionBuilder.UDiv
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_SDiv_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: SDiv
  nameWithType: InstructionBuilder.SDiv
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_URem_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: URem
  nameWithType: InstructionBuilder.URem
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_SRem_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: SRem
  nameWithType: InstructionBuilder.SRem
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Xor_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: Xor
  nameWithType: InstructionBuilder.Xor
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Or_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: Or
  nameWithType: InstructionBuilder.Or
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or
- uid: Ubiquity.NET.Llvm.Instructions.Alloca
  commentId: T:Ubiquity.NET.Llvm.Instructions.Alloca
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Alloca.html
  name: Alloca
  nameWithType: Alloca
  fullName: Ubiquity.NET.Llvm.Instructions.Alloca
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Alloca_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: Alloca
  nameWithType: InstructionBuilder.Alloca
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca
- uid: Ubiquity.NET.Llvm.Types.ITypeRef
  commentId: T:Ubiquity.NET.Llvm.Types.ITypeRef
  parent: Ubiquity.NET.Llvm.Types
  href: Ubiquity.NET.Llvm.Types.ITypeRef.html
  name: ITypeRef
  nameWithType: ITypeRef
  fullName: Ubiquity.NET.Llvm.Types.ITypeRef
- uid: Ubiquity.NET.Llvm.Types
  commentId: N:Ubiquity.NET.Llvm.Types
  href: Ubiquity.html
  name: Ubiquity.NET.Llvm.Types
  nameWithType: Ubiquity.NET.Llvm.Types
  fullName: Ubiquity.NET.Llvm.Types
  spec.csharp:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  - name: .
  - uid: Ubiquity.NET.Llvm.Types
    name: Types
    href: Ubiquity.NET.Llvm.Types.html
  spec.vb:
  - uid: Ubiquity
    name: Ubiquity
    href: Ubiquity.html
  - name: .
  - uid: Ubiquity.NET
    name: NET
    href: Ubiquity.NET.html
  - name: .
  - uid: Ubiquity.NET.Llvm
    name: Llvm
    href: Ubiquity.NET.Llvm.html
  - name: .
  - uid: Ubiquity.NET.Llvm.Types
    name: Types
    href: Ubiquity.NET.Llvm.Types.html
- uid: Ubiquity.NET.Llvm.Values.ConstantInt
  commentId: T:Ubiquity.NET.Llvm.Values.ConstantInt
  parent: Ubiquity.NET.Llvm.Values
  href: Ubiquity.NET.Llvm.Values.ConstantInt.html
  name: ConstantInt
  nameWithType: ConstantInt
  fullName: Ubiquity.NET.Llvm.Values.ConstantInt
- uid: Ubiquity.NET.Llvm.Instructions.ReturnInstruction
  commentId: T:Ubiquity.NET.Llvm.Instructions.ReturnInstruction
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.ReturnInstruction.html
  name: ReturnInstruction
  nameWithType: ReturnInstruction
  fullName: Ubiquity.NET.Llvm.Instructions.ReturnInstruction
- uid: System.ArgumentException
  commentId: T:System.ArgumentException
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.argumentexception
  name: ArgumentException
  nameWithType: ArgumentException
  fullName: System.ArgumentException
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Return
  name: Return
  nameWithType: InstructionBuilder.Return
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return
- uid: Ubiquity.NET.Llvm.Instructions.CallInstruction
  commentId: T:Ubiquity.NET.Llvm.Instructions.CallInstruction
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.CallInstruction.html
  name: CallInstruction
  nameWithType: CallInstruction
  fullName: Ubiquity.NET.Llvm.Instructions.CallInstruction
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Call_Ubiquity_NET_Llvm_Values_Function_Ubiquity_NET_Llvm_Values_Value___
  name: Call
  nameWithType: InstructionBuilder.Call
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call
- uid: Ubiquity.NET.Llvm.Values.Value[]
  isExternal: true
  href: Ubiquity.NET.Llvm.Values.Value.html
  name: Value[]
  nameWithType: Value[]
  fullName: Ubiquity.NET.Llvm.Values.Value[]
  nameWithType.vb: Value()
  fullName.vb: Ubiquity.NET.Llvm.Values.Value()
  name.vb: Value()
  spec.csharp:
  - uid: Ubiquity.NET.Llvm.Values.Value
    name: Value
    href: Ubiquity.NET.Llvm.Values.Value.html
  - name: '['
  - name: ']'
  spec.vb:
  - uid: Ubiquity.NET.Llvm.Values.Value
    name: Value
    href: Ubiquity.NET.Llvm.Values.Value.html
  - name: (
  - name: )
- uid: System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value}
  commentId: T:System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IReadOnlyList`1
  href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlylist-1
  name: IReadOnlyList<Value>
  nameWithType: IReadOnlyList<Value>
  fullName: System.Collections.Generic.IReadOnlyList<Ubiquity.NET.Llvm.Values.Value>
  nameWithType.vb: IReadOnlyList(Of Value)
  fullName.vb: System.Collections.Generic.IReadOnlyList(Of Ubiquity.NET.Llvm.Values.Value)
  name.vb: IReadOnlyList(Of Value)
  spec.csharp:
  - uid: System.Collections.Generic.IReadOnlyList`1
    name: IReadOnlyList
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlylist-1
  - name: <
  - uid: Ubiquity.NET.Llvm.Values.Value
    name: Value
    href: Ubiquity.NET.Llvm.Values.Value.html
  - name: '>'
  spec.vb:
  - uid: System.Collections.Generic.IReadOnlyList`1
    name: IReadOnlyList
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlylist-1
  - name: (
  - name: Of
  - name: " "
  - uid: Ubiquity.NET.Llvm.Values.Value
    name: Value
    href: Ubiquity.NET.Llvm.Values.Value.html
  - name: )
- uid: System.Collections.Generic.IReadOnlyList`1
  commentId: T:System.Collections.Generic.IReadOnlyList`1
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlylist-1
  name: IReadOnlyList<T>
  nameWithType: IReadOnlyList<T>
  fullName: System.Collections.Generic.IReadOnlyList<T>
  nameWithType.vb: IReadOnlyList(Of T)
  fullName.vb: System.Collections.Generic.IReadOnlyList(Of T)
  name.vb: IReadOnlyList(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IReadOnlyList`1
    name: IReadOnlyList
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlylist-1
  - name: <
  - name: T
  - name: '>'
  spec.vb:
  - uid: System.Collections.Generic.IReadOnlyList`1
    name: IReadOnlyList
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlylist-1
  - name: (
  - name: Of
  - name: " "
  - name: T
  - name: )
- uid: System.Collections.Generic
  commentId: N:System.Collections.Generic
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system
  name: System.Collections.Generic
  nameWithType: System.Collections.Generic
  fullName: System.Collections.Generic
  spec.csharp:
  - uid: System
    name: System
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system
  - name: .
  - uid: System.Collections
    name: Collections
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections
  - name: .
  - uid: System.Collections.Generic
    name: Generic
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic
  spec.vb:
  - uid: System
    name: System
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system
  - name: .
  - uid: System.Collections
    name: Collections
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections
  - name: .
  - uid: System.Collections.Generic
    name: Generic
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic
- uid: Ubiquity.NET.Llvm.Instructions.Invoke
  commentId: T:Ubiquity.NET.Llvm.Instructions.Invoke
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Invoke.html
  name: Invoke
  nameWithType: Invoke
  fullName: Ubiquity.NET.Llvm.Instructions.Invoke
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Invoke_Ubiquity_NET_Llvm_Values_Function_System_Collections_Generic_IReadOnlyList_Ubiquity_NET_Llvm_Values_Value__Ubiquity_NET_Llvm_Values_BasicBlock_Ubiquity_NET_Llvm_Values_BasicBlock_
  name: Invoke
  nameWithType: InstructionBuilder.Invoke
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke
- uid: Ubiquity.NET.Llvm.Instructions.LandingPad
  commentId: T:Ubiquity.NET.Llvm.Instructions.LandingPad
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.LandingPad.html
  name: LandingPad
  nameWithType: LandingPad
  fullName: Ubiquity.NET.Llvm.Instructions.LandingPad
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_LandingPad_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: LandingPad
  nameWithType: InstructionBuilder.LandingPad
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad
- uid: Ubiquity.NET.Llvm.Instructions.Freeze
  commentId: T:Ubiquity.NET.Llvm.Instructions.Freeze
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Freeze.html
  name: Freeze
  nameWithType: Freeze
  fullName: Ubiquity.NET.Llvm.Instructions.Freeze
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Freeze_Ubiquity_NET_Llvm_Values_Value_
  name: Freeze
  nameWithType: InstructionBuilder.Freeze
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze
- uid: Ubiquity.NET.Llvm.Instructions.ResumeInstruction
  commentId: T:Ubiquity.NET.Llvm.Instructions.ResumeInstruction
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.ResumeInstruction.html
  name: ResumeInstruction
  nameWithType: ResumeInstruction
  fullName: Ubiquity.NET.Llvm.Instructions.ResumeInstruction
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Resume_Ubiquity_NET_Llvm_Values_Value_
  name: Resume
  nameWithType: InstructionBuilder.Resume
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume
- uid: Ubiquity.NET.Llvm.Instructions.Store
  commentId: T:Ubiquity.NET.Llvm.Instructions.Store
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Store.html
  name: Store
  nameWithType: Store
  fullName: Ubiquity.NET.Llvm.Instructions.Store
- uid: Ubiquity.NET.Llvm.Types.IPointerType
  commentId: T:Ubiquity.NET.Llvm.Types.IPointerType
  parent: Ubiquity.NET.Llvm.Types
  href: Ubiquity.NET.Llvm.Types.IPointerType.html
  name: IPointerType
  nameWithType: IPointerType
  fullName: Ubiquity.NET.Llvm.Types.IPointerType
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Store_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: Store
  nameWithType: InstructionBuilder.Store
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Load_Ubiquity_NET_Llvm_Types_ITypeRef_Ubiquity_NET_Llvm_Values_Value_
  name: Load
  nameWithType: InstructionBuilder.Load
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load
- uid: Ubiquity.NET.Llvm.Instructions.Load
  commentId: T:Ubiquity.NET.Llvm.Instructions.Load
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Load.html
  name: Load
  nameWithType: Load
  fullName: Ubiquity.NET.Llvm.Instructions.Load
- uid: Ubiquity.NET.Llvm.Instructions.AtomicRMW
  commentId: T:Ubiquity.NET.Llvm.Instructions.AtomicRMW
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.AtomicRMW.html
  name: AtomicRMW
  nameWithType: AtomicRMW
  fullName: Ubiquity.NET.Llvm.Instructions.AtomicRMW
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicXchg_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicXchg
  nameWithType: InstructionBuilder.AtomicXchg
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicAdd_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicAdd
  nameWithType: InstructionBuilder.AtomicAdd
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicSub_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicSub
  nameWithType: InstructionBuilder.AtomicSub
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicAnd_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicAnd
  nameWithType: InstructionBuilder.AtomicAnd
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicNand_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicNand
  nameWithType: InstructionBuilder.AtomicNand
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicOr_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicOr
  nameWithType: InstructionBuilder.AtomicOr
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicXor_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicXor
  nameWithType: InstructionBuilder.AtomicXor
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicMax_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicMax
  nameWithType: InstructionBuilder.AtomicMax
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicMin_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicMin
  nameWithType: InstructionBuilder.AtomicMin
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicUMax_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicUMax
  nameWithType: InstructionBuilder.AtomicUMax
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicUMin_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicUMin
  nameWithType: InstructionBuilder.AtomicUMin
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicFadd_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicFadd
  nameWithType: InstructionBuilder.AtomicFadd
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicFSub_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicFSub
  nameWithType: InstructionBuilder.AtomicFSub
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AtomicCmpXchg_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: AtomicCmpXchg
  nameWithType: InstructionBuilder.AtomicCmpXchg
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg
- uid: Ubiquity.NET.Llvm.Instructions.AtomicCmpXchg
  commentId: T:Ubiquity.NET.Llvm.Instructions.AtomicCmpXchg
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.AtomicCmpXchg.html
  name: AtomicCmpXchg
  nameWithType: AtomicCmpXchg
  fullName: Ubiquity.NET.Llvm.Instructions.AtomicCmpXchg
- uid: Ubiquity.NET.Llvm.Values.ConstantExpression
  commentId: T:Ubiquity.NET.Llvm.Values.ConstantExpression
  href: Ubiquity.NET.Llvm.Values.ConstantExpression.html
  name: ConstantExpression
  nameWithType: ConstantExpression
  fullName: Ubiquity.NET.Llvm.Values.ConstantExpression
- uid: Ubiquity.NET.Llvm.Instructions.GetElementPtr
  commentId: T:Ubiquity.NET.Llvm.Instructions.GetElementPtr
  href: Ubiquity.NET.Llvm.Instructions.GetElementPtr.html
  name: GetElementPtr
  nameWithType: GetElementPtr
  fullName: Ubiquity.NET.Llvm.Instructions.GetElementPtr
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_GetStructElementPointer_Ubiquity_NET_Llvm_Values_Value_System_UInt32_
  name: GetStructElementPointer
  nameWithType: InstructionBuilder.GetStructElementPointer
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_GetElementPtr_Ubiquity_NET_Llvm_Types_ITypeRef_Ubiquity_NET_Llvm_Values_Value_System_Collections_Generic_IEnumerable_Ubiquity_NET_Llvm_Values_Value__
  name: GetElementPtr
  nameWithType: InstructionBuilder.GetElementPtr
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr
- uid: System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value}
  commentId: T:System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1
  name: IEnumerable<Value>
  nameWithType: IEnumerable<Value>
  fullName: System.Collections.Generic.IEnumerable<Ubiquity.NET.Llvm.Values.Value>
  nameWithType.vb: IEnumerable(Of Value)
  fullName.vb: System.Collections.Generic.IEnumerable(Of Ubiquity.NET.Llvm.Values.Value)
  name.vb: IEnumerable(Of Value)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1
  - name: <
  - uid: Ubiquity.NET.Llvm.Values.Value
    name: Value
    href: Ubiquity.NET.Llvm.Values.Value.html
  - name: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1
  - name: (
  - name: Of
  - name: " "
  - uid: Ubiquity.NET.Llvm.Values.Value
    name: Value
    href: Ubiquity.NET.Llvm.Values.Value.html
  - name: )
- uid: System.Collections.Generic.IEnumerable`1
  commentId: T:System.Collections.Generic.IEnumerable`1
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  nameWithType.vb: IEnumerable(Of T)
  fullName.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1
  - name: <
  - name: T
  - name: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    isExternal: true
    href: https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1
  - name: (
  - name: Of
  - name: " "
  - name: T
  - name: )
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_GetElementPtrInBounds_Ubiquity_NET_Llvm_Values_Value_System_Collections_Generic_IEnumerable_Ubiquity_NET_Llvm_Values_Value__
  name: GetElementPtrInBounds
  nameWithType: InstructionBuilder.GetElementPtrInBounds
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_ConstGetElementPtrInBounds_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value___
  name: ConstGetElementPtrInBounds
  nameWithType: InstructionBuilder.ConstGetElementPtrInBounds
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds
- uid: Ubiquity.NET.Llvm.Instructions.IntToPointer
  commentId: T:Ubiquity.NET.Llvm.Instructions.IntToPointer
  href: Ubiquity.NET.Llvm.Instructions.IntToPointer.html
  name: IntToPointer
  nameWithType: IntToPointer
  fullName: Ubiquity.NET.Llvm.Instructions.IntToPointer
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_IntToPointer_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_IPointerType_
  name: IntToPointer
  nameWithType: InstructionBuilder.IntToPointer
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer
- uid: Ubiquity.NET.Llvm.Instructions.PointerToInt
  commentId: T:Ubiquity.NET.Llvm.Instructions.PointerToInt
  href: Ubiquity.NET.Llvm.Instructions.PointerToInt.html
  name: PointerToInt
  nameWithType: PointerToInt
  fullName: Ubiquity.NET.Llvm.Instructions.PointerToInt
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_PointerToInt_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: PointerToInt
  nameWithType: InstructionBuilder.PointerToInt
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt
- uid: Ubiquity.NET.Llvm.Instructions.Branch
  commentId: T:Ubiquity.NET.Llvm.Instructions.Branch
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Branch.html
  name: Branch
  nameWithType: Branch
  fullName: Ubiquity.NET.Llvm.Instructions.Branch
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Branch_Ubiquity_NET_Llvm_Values_BasicBlock_
  name: Branch
  nameWithType: InstructionBuilder.Branch
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch
- uid: Ubiquity.NET.Llvm.Instructions.Unreachable
  commentId: T:Ubiquity.NET.Llvm.Instructions.Unreachable
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Unreachable.html
  name: Unreachable
  nameWithType: Unreachable
  fullName: Ubiquity.NET.Llvm.Instructions.Unreachable
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Unreachable
  name: Unreachable
  nameWithType: InstructionBuilder.Unreachable
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Compare_Ubiquity_NET_Llvm_Instructions_IntPredicate_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: Compare
  nameWithType: InstructionBuilder.Compare
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare
- uid: Ubiquity.NET.Llvm.Instructions.IntPredicate
  commentId: T:Ubiquity.NET.Llvm.Instructions.IntPredicate
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.IntPredicate.html
  name: IntPredicate
  nameWithType: IntPredicate
  fullName: Ubiquity.NET.Llvm.Instructions.IntPredicate
- uid: Ubiquity.NET.Llvm.Instructions.RealPredicate
  commentId: T:Ubiquity.NET.Llvm.Instructions.RealPredicate
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.RealPredicate.html
  name: RealPredicate
  nameWithType: RealPredicate
  fullName: Ubiquity.NET.Llvm.Instructions.RealPredicate
- uid: Ubiquity.NET.Llvm.Instructions.Predicate
  commentId: T:Ubiquity.NET.Llvm.Instructions.Predicate
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Predicate.html
  name: Predicate
  nameWithType: Predicate
  fullName: Ubiquity.NET.Llvm.Instructions.Predicate
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_ZeroExtendOrBitCast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: ZeroExtendOrBitCast
  nameWithType: InstructionBuilder.ZeroExtendOrBitCast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_SignExtendOrBitCast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: SignExtendOrBitCast
  nameWithType: InstructionBuilder.SignExtendOrBitCast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_TruncOrBitCast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: TruncOrBitCast
  nameWithType: InstructionBuilder.TruncOrBitCast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_ZeroExtend_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: ZeroExtend
  nameWithType: InstructionBuilder.ZeroExtend
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_SignExtend_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: SignExtend
  nameWithType: InstructionBuilder.SignExtend
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_BitCast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: BitCast
  nameWithType: InstructionBuilder.BitCast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_IntCast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_System_Boolean_
  name: IntCast
  nameWithType: InstructionBuilder.IntCast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast
- uid: System.Boolean
  commentId: T:System.Boolean
  parent: System
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.boolean
  name: bool
  nameWithType: bool
  fullName: bool
  nameWithType.vb: Boolean
  fullName.vb: Boolean
  name.vb: Boolean
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Trunc_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: Trunc
  nameWithType: InstructionBuilder.Trunc
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_SIToFPCast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: SIToFPCast
  nameWithType: InstructionBuilder.SIToFPCast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_UIToFPCast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: UIToFPCast
  nameWithType: InstructionBuilder.UIToFPCast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FPToUICast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: FPToUICast
  nameWithType: InstructionBuilder.FPToUICast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FPToSICast_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: FPToSICast
  nameWithType: InstructionBuilder.FPToSICast
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FPExt_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: FPExt
  nameWithType: InstructionBuilder.FPExt
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_FPTrunc_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: FPTrunc
  nameWithType: InstructionBuilder.FPTrunc
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc
- uid: Ubiquity.NET.Llvm.Instructions.SelectInstruction
  commentId: T:Ubiquity.NET.Llvm.Instructions.SelectInstruction
  href: Ubiquity.NET.Llvm.Instructions.SelectInstruction.html
  name: SelectInstruction
  nameWithType: SelectInstruction
  fullName: Ubiquity.NET.Llvm.Instructions.SelectInstruction
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Select_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_
  name: Select
  nameWithType: InstructionBuilder.Select
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select
- uid: Ubiquity.NET.Llvm.Instructions.PhiNode
  commentId: T:Ubiquity.NET.Llvm.Instructions.PhiNode
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.PhiNode.html
  name: PhiNode
  nameWithType: PhiNode
  fullName: Ubiquity.NET.Llvm.Instructions.PhiNode
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_PhiNode_Ubiquity_NET_Llvm_Types_ITypeRef_
  name: PhiNode
  nameWithType: InstructionBuilder.PhiNode
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_ExtractValue_Ubiquity_NET_Llvm_Values_Value_System_UInt32_
  name: ExtractValue
  nameWithType: InstructionBuilder.ExtractValue
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue
- uid: Ubiquity.NET.Llvm.Instructions.Switch
  commentId: T:Ubiquity.NET.Llvm.Instructions.Switch
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Switch.html
  name: Switch
  nameWithType: Switch
  fullName: Ubiquity.NET.Llvm.Instructions.Switch
- uid: Ubiquity.NET.Llvm.Instructions.Switch.AddCase(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock)
  commentId: M:Ubiquity.NET.Llvm.Instructions.Switch.AddCase(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock)
  href: Ubiquity.NET.Llvm.Instructions.Switch.html#Ubiquity_NET_Llvm_Instructions_Switch_AddCase_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_BasicBlock_
  name: AddCase(Value, BasicBlock)
  nameWithType: Switch.AddCase(Value, BasicBlock)
  fullName: Ubiquity.NET.Llvm.Instructions.Switch.AddCase(Ubiquity.NET.Llvm.Values.Value, Ubiquity.NET.Llvm.Values.BasicBlock)
  spec.csharp:
  - uid: Ubiquity.NET.Llvm.Instructions.Switch.AddCase(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock)
    name: AddCase
    href: Ubiquity.NET.Llvm.Instructions.Switch.html#Ubiquity_NET_Llvm_Instructions_Switch_AddCase_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_BasicBlock_
  - name: (
  - uid: Ubiquity.NET.Llvm.Values.Value
    name: Value
    href: Ubiquity.NET.Llvm.Values.Value.html
  - name: ','
  - name: " "
  - uid: Ubiquity.NET.Llvm.Values.BasicBlock
    name: BasicBlock
    href: Ubiquity.NET.Llvm.Values.BasicBlock.html
  - name: )
  spec.vb:
  - uid: Ubiquity.NET.Llvm.Instructions.Switch.AddCase(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock)
    name: AddCase
    href: Ubiquity.NET.Llvm.Instructions.Switch.html#Ubiquity_NET_Llvm_Instructions_Switch_AddCase_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_BasicBlock_
  - name: (
  - uid: Ubiquity.NET.Llvm.Values.Value
    name: Value
    href: Ubiquity.NET.Llvm.Values.Value.html
  - name: ','
  - name: " "
  - uid: Ubiquity.NET.Llvm.Values.BasicBlock
    name: BasicBlock
    href: Ubiquity.NET.Llvm.Values.BasicBlock.html
  - name: )
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Switch_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_BasicBlock_System_UInt32_
  name: Switch
  nameWithType: InstructionBuilder.Switch
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch
- uid: Ubiquity.NET.Llvm.Values.BasicBlock.ContainingFunction
  commentId: P:Ubiquity.NET.Llvm.Values.BasicBlock.ContainingFunction
  href: Ubiquity.NET.Llvm.Values.BasicBlock.html#Ubiquity_NET_Llvm_Values_BasicBlock_ContainingFunction
  name: ContainingFunction
  nameWithType: BasicBlock.ContainingFunction
  fullName: Ubiquity.NET.Llvm.Values.BasicBlock.ContainingFunction
- uid: Ubiquity.NET.Llvm.Values.GlobalValue.ParentModule
  commentId: P:Ubiquity.NET.Llvm.Values.GlobalValue.ParentModule
  parent: Ubiquity.NET.Llvm.Values.GlobalValue
  href: Ubiquity.NET.Llvm.Values.GlobalValue.html#Ubiquity_NET_Llvm_Values_GlobalValue_ParentModule
  name: ParentModule
  nameWithType: GlobalValue.ParentModule
  fullName: Ubiquity.NET.Llvm.Values.GlobalValue.ParentModule
- uid: System.InvalidOperationException
  commentId: T:System.InvalidOperationException
  isExternal: true
  href: https://learn.microsoft.com/dotnet/api/system.invalidoperationexception
  name: InvalidOperationException
  nameWithType: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_DoNothing
  name: DoNothing
  nameWithType: InstructionBuilder.DoNothing
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing
- uid: Ubiquity.NET.Llvm.Values.GlobalValue
  commentId: T:Ubiquity.NET.Llvm.Values.GlobalValue
  parent: Ubiquity.NET.Llvm.Values
  href: Ubiquity.NET.Llvm.Values.GlobalValue.html
  name: GlobalValue
  nameWithType: GlobalValue
  fullName: Ubiquity.NET.Llvm.Values.GlobalValue
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_DebugTrap
  name: DebugTrap
  nameWithType: InstructionBuilder.DebugTrap
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_Trap
  name: Trap
  nameWithType: InstructionBuilder.Trap
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap
- uid: Ubiquity.NET.Llvm.Instructions.Intrinsic
  commentId: T:Ubiquity.NET.Llvm.Instructions.Intrinsic
  parent: Ubiquity.NET.Llvm.Instructions
  href: Ubiquity.NET.Llvm.Instructions.Intrinsic.html
  name: Intrinsic
  nameWithType: Intrinsic
  fullName: Ubiquity.NET.Llvm.Instructions.Intrinsic
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_MemCpy_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_System_Boolean_
  name: MemCpy
  nameWithType: InstructionBuilder.MemCpy
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_MemMove_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_System_Boolean_
  name: MemMove
  nameWithType: InstructionBuilder.MemMove
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_MemSet_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_System_Boolean_
  name: MemSet
  nameWithType: InstructionBuilder.MemSet
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet
- uid: Ubiquity.NET.Llvm.Instructions.InsertValue
  commentId: T:Ubiquity.NET.Llvm.Instructions.InsertValue
  href: Ubiquity.NET.Llvm.Instructions.InsertValue.html
  name: InsertValue
  nameWithType: InsertValue
  fullName: Ubiquity.NET.Llvm.Instructions.InsertValue
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_InsertValue_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_System_UInt32_
  name: InsertValue
  nameWithType: InstructionBuilder.InsertValue
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_AddWithOverflow_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_System_Boolean_
  name: AddWithOverflow
  nameWithType: InstructionBuilder.AddWithOverflow
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_SubWithOverflow_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_System_Boolean_
  name: SubWithOverflow
  nameWithType: InstructionBuilder.SubWithOverflow
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow
- uid: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow*
  commentId: Overload:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow
  href: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html#Ubiquity_NET_Llvm_Instructions_InstructionBuilder_MulWithOverflow_Ubiquity_NET_Llvm_Values_Value_Ubiquity_NET_Llvm_Values_Value_System_Boolean_
  name: MulWithOverflow
  nameWithType: InstructionBuilder.MulWithOverflow
  fullName: Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow
