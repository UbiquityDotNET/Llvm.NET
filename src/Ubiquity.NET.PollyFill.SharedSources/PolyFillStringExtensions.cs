// <auto-generated/>
#nullable enable

// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

// from .NET sources
// see: https://github.com/dotnet/runtime/blob/1d1bf92fcf43aa6981804dc53c5174445069c9e4/src/libraries/System.Private.CoreLib/src/System/String.Manipulation.cs

#pragma warning disable IDE0130 // Namespace does not match folder structure

using global::System.Diagnostics;

namespace System
{
    /// <summary>Pollyfill extensions for support not present in older runtimes</summary>
    /// <inheritdoc cref="PolyFillExceptionValidators" path="/remarks"/>
    internal static class PolyFillStringExtensions
    {
        extension(string)
        {
            /// <summary>Concatenates the members of a collection, using the specified separator between each member.</summary>
            /// <typeparam name="T">The type of the members of values.</typeparam>
            /// <param name="separator">The character to use as a separator. separator is included in the returned string only if values has more than one element.</param>
            /// <param name="values">A collection that contains the objects to concatenate.</param>
            /// <returns>
            /// A string that consists of the members of values delimited by the separator character.
            /// -or- System.String.Empty if values has no elements.
            /// </returns>
            /// <exception cref="System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/></exception>
            /// <exception cref="System.OutOfMemoryException">The length of the resulting string overflows the maximum allowed length (<see cref="Int32.MaxValue"/>).</exception>
            public static string Join<T>( char separator, IEnumerable<T> values )
            {
                return string.Join(separator.ToString(), values);
            }
        }

        public static int GetHashCode( this string self, StringComparison comparisonType )
        {
            if(comparisonType != StringComparison.Ordinal)
            {
                throw new global::System.ComponentModel.InvalidEnumArgumentException(nameof(comparisonType), (int)comparisonType, typeof(StringComparison));
            }

            return self.GetHashCode();
        }

        /// <summary>Replace line endings in the string with environment specific forms</summary>
        /// <param name="self">string to change line endings for</param>
        /// <returns>string with environment specific line endings</returns>
        public static string ReplaceLineEndings(this string self)
        {
            return ReplaceLineEndings(self, global::System.Environment.NewLine);
        }

        // This is NOT the most performant implementation, it's going for simplistic pollyfill that has
        // the correct behavior, even if not the most performant. If performance is critical, use a
        // later version of the runtime!

        /// <summary>Replace line endings in the string with a given string</summary>
        /// <param name="self">string to change line endings for</param>
        /// <param name="replacementText">Text to replace all of the line endings in <paramref name="self"/></param>
        /// <returns>string with line endings replaced by <paramref name="replacementText"/></returns>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static string ReplaceLineEndings(this string self, string replacementText)
        {
            global::System.ArgumentNullException.ThrowIfNull(self);
            global::System.ArgumentNullException.ThrowIfNull(replacementText);

            string retVal = UnicodeNewLinesRegEx.Replace(self, replacementText);

            // if the result of replacement is the same, just return the original
            // This is wasted overhead, but at least matches the behavior
            return self == retVal ? self : retVal;
        }

        // The Unicode Standard, Sec. 5.8, Recommendation R4 and Table 5-2 state that the CR, LF,
        // CRLF, NEL, LS, FF, and PS sequences are considered newline functions. That section
        // also specifically excludes VT from the list of newline functions, so we do not include
        // it in the regular expression match.

        // language=regex
        private const string UnicodeNewLinesRegExPattern = @"(\r\n|\r|\n|\f|\u0085|\u2028|\u2029)";

        // NOTE: can't use source generated RegEx here as there's no way to declare the depency on
        // the output of one generator as the input for another. They all see the same input, therefore
        // the partial implementation would never be filled in and produces a compilation error instead.
        private static global::System.Text.RegularExpressions.Regex UnicodeNewLinesRegEx { get; }
            = new global::System.Text.RegularExpressions.Regex(UnicodeNewLinesRegExPattern);
    }
}
