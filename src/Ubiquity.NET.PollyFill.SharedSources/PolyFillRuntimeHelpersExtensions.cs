// <auto-generated/>
#nullable enable

// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

// based on work from: https://github.com/Sergio0694/PolySharp/issues/104

#pragma warning disable IDE0130 // Namespace does not match folder structure

namespace System.Runtime.CompilerServices
{
    /// <summary>Poly Fill Extensions to <see cref="RuntimeHelpers"/></summary>
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Design","CA1034: Nested types should not be visible", Justification = "extension, broken analyzer")]
    internal static class PolyFillRuntimeHelpersExtensions
    {
        /// <summary>Poly Fill Extensions to <see cref="RuntimeHelpers"/></summary>
        extension( global::System.Runtime.CompilerServices.RuntimeHelpers )
        {
            /// <summary>
            /// Slices the specified array using the specified range.
            /// Adapted from source: https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/RuntimeHelpers.cs.
            /// Required for be able to use `array[10..20] ` syntax in .NET Standard 2.0 and net48.
            /// </summary>
            public static T[] GetSubArray<T>( T[] array, global::System.Range range )
            {
                global::System.ArgumentNullException.ThrowIfNull(array);
                (int offset, int length) = range.GetOffsetAndLength( array.Length );

                if(length == 0)
                {
                    return [];
                }

                T[] dest;

                if(typeof( T[] ) == array.GetType())
                {
                    // We know the type of the array to be exactly T[].
                    dest = new T[ length ];
                }
                else
                {
                    // exception should never hit since array is T[], but this keeps compiler/analyzers happy
                    global::System.Type elementType = array.GetType().GetElementType() ?? throw new global::System.InvalidOperationException("element type is not known!");

                    // The array is actually a U[] where U:T. We'll make sure to create
                    // an array of the exact same backing type. The cast to T[] will
                    // never fail.
                    dest = (T[])global::System.Array.CreateInstance( elementType, length );
                }

                // In either case, the newly-allocated array is the exact same type as the
                // original incoming array. It's safe for us to Array.Copy the contents
                // from the source array to the destination array, otherwise the contents
                // wouldn't have been valid for the source array in the first place.
                global::System.Array.Copy( array, offset, dest, 0, length );
                return dest;
            }
        }
    }
}
