// <auto-generated/>
#nullable enable

// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

#pragma warning disable IDE0130 // Namespace does not match folder structure
#pragma warning disable CS3021 // Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute

namespace System.Runtime.InteropServices
{
    /// <summary>Extensions for <see cref="MemoryMarshal"/> to allow downlevel compatibility</summary>
    internal static class PolyFillMemoryMarshal
    {
        extension(global::System.Runtime.InteropServices.MemoryMarshal)
        {
            /// <summary>Creates a new read-only span for a null-terminated UTF-8 string.</summary>
            /// <param name="value">The pointer to the null-terminated string of bytes.</param>
            /// <returns>A read-only span representing the specified null-terminated string, or an empty span if the pointer is null.</returns>
            /// <remarks>The returned span does not include the null terminator, nor does it validate the well-formedness of the UTF-8 data.</remarks>
            /// <exception cref="ArgumentException">The string is longer than <see cref="int.MaxValue"/>.</exception>
            [global::System.CLSCompliant(false)]
            public static unsafe global::System.ReadOnlySpan<byte> CreateReadOnlySpanFromNullTerminated(byte* value)
            {
                return value != null
                     ? new global::System.ReadOnlySpan<byte>(value, StrLen(value))
                     : default;
            }
        }

        private static unsafe int StrLen(byte* p)
        {
            // Crude but functional - definately NOT perf optimized.
            int indexOfTerminator = 0;
            for(; *p != 0; ++p, ++indexOfTerminator)
            {
            }

            return indexOfTerminator;
        }
    }
}
