// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 2.17941.31104.49410
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System.CodeDom.Compiler;
using System.Runtime.InteropServices;
using System.Security;

namespace Llvm.NET.Interop
{
    [UnmanagedFunctionPointer( global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
    unsafe public delegate byte* LLVMMemoryManagerAllocateCodeSectionCallback( global::System.IntPtr Opaque, System.UIntPtr Size, uint Alignment, uint SectionID, [MarshalAs( UnmanagedType.LPStr )]string SectionName );

    [UnmanagedFunctionPointer( global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
    unsafe public delegate byte* LLVMMemoryManagerAllocateDataSectionCallback( global::System.IntPtr Opaque, System.UIntPtr Size, uint Alignment, uint SectionID, [MarshalAs( UnmanagedType.LPStr )]string SectionName, bool IsReadOnly );

    [UnmanagedFunctionPointer( global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
    public delegate bool LLVMMemoryManagerFinalizeMemoryCallback( global::System.IntPtr Opaque, [MarshalAs( UnmanagedType.LPStr, ArraySubType = UnmanagedType.LPStr )]global::System.String[] ErrMsg );

    [UnmanagedFunctionPointer( global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
    public delegate void LLVMMemoryManagerDestroyCallback( global::System.IntPtr Opaque );

    [StructLayout( LayoutKind.Sequential )]
    [GeneratedCode( "LlvmBindingsGenerator", "2.17941.31104.49410" )]
    public struct LLVMMCJITCompilerOptions
    {
        public uint OptLevel;
        public LLVMCodeModel CodeModel;
        public bool NoFramePointerElim;
        public bool EnableFastISel;
        public LLVMMCJITMemoryManagerRef MCJMM;
    }

    public static partial class NativeMethods
    {
        /**
         * @defgroup LLVMCExecutionEngine Execution Engine
         * @ingroup LLVMC
         *
         * @{
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMLinkInMCJIT(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMLinkInInterpreter(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMGenericValueRef LLVMCreateGenericValueOfInt( LLVMTypeRef Ty, ulong N, [MarshalAs( UnmanagedType.Bool )]bool IsSigned );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMGenericValueRef LLVMCreateGenericValueOfPointer( global::System.IntPtr P );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMGenericValueRef LLVMCreateGenericValueOfFloat( LLVMTypeRef Ty, double N );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGenericValueIntWidth( LLVMGenericValueRef GenValRef );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern ulong LLVMGenericValueToInt( LLVMGenericValueRef GenVal, [MarshalAs( UnmanagedType.Bool )]bool IsSigned );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern global::System.IntPtr LLVMGenericValueToPointer( LLVMGenericValueRef GenVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern double LLVMGenericValueToFloat( LLVMTypeRef TyRef, LLVMGenericValueRef GenVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMCreateExecutionEngineForModule( out LLVMExecutionEngineRef OutEE, LLVMModuleRef M, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string OutError );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMCreateInterpreterForModule( out LLVMExecutionEngineRef OutInterp, LLVMModuleRef M, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string OutError );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMCreateJITCompilerForModule( out LLVMExecutionEngineRef OutJIT, LLVMModuleRef M, uint OptLevel, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string OutError );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMInitializeMCJITCompilerOptions( out global::Llvm.NET.Interop.LLVMMCJITCompilerOptions Options, size_t SizeOfOptions );

        /**
         * Create an MCJIT execution engine for a module, with the given options. It is
         * the responsibility of the caller to ensure that all fields in Options up to
         * the given SizeOfOptions are initialized. It is correct to pass a smaller
         * value of SizeOfOptions that omits some fields. The canonical way of using
         * this is:
         *
         * LLVMMCJITCompilerOptions options;
         * LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));
         * ... fill in those options you care about
         * LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),
         *                                  &error);
         *
         * Note that this is also correct, though possibly suboptimal:
         *
         * LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMCreateMCJITCompilerForModule( out LLVMExecutionEngineRef OutJIT, LLVMModuleRef M, out global::Llvm.NET.Interop.LLVMMCJITCompilerOptions Options, size_t SizeOfOptions, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string OutError );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMRunStaticConstructors( LLVMExecutionEngineRef EE );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMRunStaticDestructors( LLVMExecutionEngineRef EE );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern int LLVMRunFunctionAsMain( LLVMExecutionEngineRef EE, LLVMValueRef F, uint ArgC, [MarshalAs( UnmanagedType.LPStr, ArraySubType = UnmanagedType.LPStr )]global::System.String[] ArgV, [MarshalAs( UnmanagedType.LPStr, ArraySubType = UnmanagedType.LPStr )]global::System.String[] EnvP );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMGenericValueRef LLVMRunFunction( LLVMExecutionEngineRef EE, LLVMValueRef F, uint NumArgs, out LLVMGenericValueRef Args );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMFreeMachineCodeForFunction( LLVMExecutionEngineRef EE, LLVMValueRef F );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddModule( LLVMExecutionEngineRef EE, LLVMModuleRef M );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMRemoveModule( LLVMExecutionEngineRef EE, LLVMModuleRef M, out LLVMModuleRef OutMod, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string OutError );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMFindFunction( LLVMExecutionEngineRef EE, [MarshalAs( UnmanagedType.LPStr )]string Name, out LLVMValueRef OutFn );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern global::System.IntPtr LLVMRecompileAndRelinkFunction( LLVMExecutionEngineRef EE, LLVMValueRef Fn );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTargetDataRef LLVMGetExecutionEngineTargetData( LLVMExecutionEngineRef EE );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTargetMachineRef LLVMGetExecutionEngineTargetMachine( LLVMExecutionEngineRef EE );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddGlobalMapping( LLVMExecutionEngineRef EE, LLVMValueRef Global, global::System.IntPtr Addr );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern global::System.IntPtr LLVMGetPointerToGlobal( LLVMExecutionEngineRef EE, LLVMValueRef Global );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern System.UInt64 LLVMGetGlobalValueAddress( LLVMExecutionEngineRef EE, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern System.UInt64 LLVMGetFunctionAddress( LLVMExecutionEngineRef EE, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Create a simple custom MCJIT memory manager. This memory manager can
         * intercept allocations in a module-oblivious way. This will return NULL
         * if any of the passed functions are NULL.
         *
         * @param Opaque An opaque client object to pass back to the callbacks.
         * @param AllocateCodeSection Allocate a block of memory for executable code.
         * @param AllocateDataSection Allocate a block of memory for data.
         * @param FinalizeMemory Set page permissions and flush cache. Return 0 on
         *   success, 1 on error.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMMCJITMemoryManagerRef LLVMCreateSimpleMCJITMemoryManager( global::System.IntPtr Opaque, LLVMMemoryManagerAllocateCodeSectionCallback AllocateCodeSection, LLVMMemoryManagerAllocateDataSectionCallback AllocateDataSection, LLVMMemoryManagerFinalizeMemoryCallback FinalizeMemory, LLVMMemoryManagerDestroyCallback Destroy );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMJITEventListenerRef LLVMCreateGDBRegistrationListener(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMJITEventListenerRef LLVMCreateIntelJITEventListener(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMJITEventListenerRef LLVMCreateOProfileJITEventListener(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMJITEventListenerRef LLVMCreatePerfJITEventListener(  );

    }
}
