// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 2.17941.31104.49410
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System.CodeDom.Compiler;
using System.Runtime.InteropServices;
using System.Security;

namespace Llvm.NET.Interop
{
    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMCodeGenOptLevel : global::System.Int32
    {
        LLVMCodeGenLevelNone = 0,
        LLVMCodeGenLevelLess = 1,
        LLVMCodeGenLevelDefault = 2,
        LLVMCodeGenLevelAggressive = 3,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMRelocMode : global::System.Int32
    {
        LLVMRelocDefault = 0,
        LLVMRelocStatic = 1,
        LLVMRelocPIC = 2,
        LLVMRelocDynamicNoPic = 3,
        LLVMRelocROPI = 4,
        LLVMRelocRWPI = 5,
        LLVMRelocROPI_RWPI = 6,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMCodeModel : global::System.Int32
    {
        LLVMCodeModelDefault = 0,
        LLVMCodeModelJITDefault = 1,
        LLVMCodeModelTiny = 2,
        LLVMCodeModelSmall = 3,
        LLVMCodeModelKernel = 4,
        LLVMCodeModelMedium = 5,
        LLVMCodeModelLarge = 6,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMCodeGenFileType : global::System.Int32
    {
        LLVMAssemblyFile = 0,
        LLVMObjectFile = 1,
    }

    public static partial class NativeMethods
    {
        /** Returns the first llvm::Target in the registered targets list. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTargetRef LLVMGetFirstTarget(  );

        /** Returns the next llvm::Target given a previous one (or null if there's none) */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTargetRef LLVMGetNextTarget( LLVMTargetRef T );

        /** Finds the target corresponding to the given name and stores it in \p T.
          Returns 0 on success. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTargetRef LLVMGetTargetFromName( [MarshalAs( UnmanagedType.LPStr )]string Name );

        /** Finds the target corresponding to the given triple and stores it in \p T.
          Returns 0 on success. Optionally returns any error in ErrorMessage.
          Use LLVMDisposeMessage to dispose the message. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMGetTargetFromTriple( [MarshalAs( UnmanagedType.LPStr )]string Triple, out LLVMTargetRef T, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string ErrorMessage );

        /** Returns the name of a target. See llvm::Target::getName */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetTargetName( LLVMTargetRef T );

        /** Returns the description  of a target. See llvm::Target::getDescription */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetTargetDescription( LLVMTargetRef T );

        /** Returns if the target has a JIT */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMTargetHasJIT( LLVMTargetRef T );

        /** Returns if the target has a TargetMachine associated */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMTargetHasTargetMachine( LLVMTargetRef T );

        /** Returns if the target as an ASM backend (required for emitting output) */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMTargetHasAsmBackend( LLVMTargetRef T );

        /** Creates a new llvm::TargetMachine. See llvm::Target::createTargetMachine */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTargetMachineRef LLVMCreateTargetMachine( LLVMTargetRef T, [MarshalAs( UnmanagedType.LPStr )]string Triple, [MarshalAs( UnmanagedType.LPStr )]string CPU, [MarshalAs( UnmanagedType.LPStr )]string Features, LLVMCodeGenOptLevel Level, LLVMRelocMode Reloc, LLVMCodeModel CodeModel );

        /** Returns the Target used in a TargetMachine */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTargetRef LLVMGetTargetMachineTarget( LLVMTargetMachineRef T );

        /** Returns the triple used creating this target machine. See
          llvm::TargetMachine::getTriple. The result needs to be disposed with
          LLVMDisposeMessage. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]
        public static extern string LLVMGetTargetMachineTriple( LLVMTargetMachineRef T );

        /** Returns the cpu used creating this target machine. See
          llvm::TargetMachine::getCPU. The result needs to be disposed with
          LLVMDisposeMessage. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]
        public static extern string LLVMGetTargetMachineCPU( LLVMTargetMachineRef T );

        /** Returns the feature string used creating this target machine. See
          llvm::TargetMachine::getFeatureString. The result needs to be disposed with
          LLVMDisposeMessage. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]
        public static extern string LLVMGetTargetMachineFeatureString( LLVMTargetMachineRef T );

        /** Create a DataLayout based on the targetMachine. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTargetDataRef LLVMCreateTargetDataLayout( LLVMTargetMachineRef T );

        /** Set the target machine's ASM verbosity. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetTargetMachineAsmVerbosity( LLVMTargetMachineRef T, [MarshalAs( UnmanagedType.Bool )]bool VerboseAsm );

        /** Emits an asm or object file for the given module to the filename. This
          wraps several c++ only classes (among them a file stream). Returns any
          error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMTargetMachineEmitToFile( LLVMTargetMachineRef T, LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Filename, LLVMCodeGenFileType codegen, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string ErrorMessage );

        /** Compile the LLVM IR stored in \p M and store the result in \p OutMemBuf. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMTargetMachineEmitToMemoryBuffer( LLVMTargetMachineRef T, LLVMModuleRef M, LLVMCodeGenFileType codegen, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string ErrorMessage, out LLVMMemoryBufferRef OutMemBuf );

        /** Get a triple for the host machine as a string. The result needs to be
          disposed with LLVMDisposeMessage. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        unsafe public static extern sbyte* LLVMGetDefaultTargetTriple(  );

        /** Normalize a target triple. The result needs to be disposed with
          LLVMDisposeMessage. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        unsafe public static extern sbyte* LLVMNormalizeTargetTriple( [MarshalAs( UnmanagedType.LPStr )]string triple );

        /** Get the host CPU as a string. The result needs to be disposed with
          LLVMDisposeMessage. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        unsafe public static extern sbyte* LLVMGetHostCPUName(  );

        /** Get the host CPU's features as a string. The result needs to be disposed
          with LLVMDisposeMessage. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        unsafe public static extern sbyte* LLVMGetHostCPUFeatures(  );

        /** Adds the target-specific analysis passes to the pass manager. */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddAnalysisPasses( LLVMTargetMachineRef T, LLVMPassManagerRef PM );

    }
}
