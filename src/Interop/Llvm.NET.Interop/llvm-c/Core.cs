// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 2.17941.31104.49410
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System.CodeDom.Compiler;
using System.Runtime.InteropServices;
using System.Security;

namespace Llvm.NET.Interop
{
    /// External users depend on the following values being stable. It is not safe
    /// to reorder them.
    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMOpcode : global::System.Int32
    {
        LLVMRet = 1,
        LLVMBr = 2,
        LLVMSwitch = 3,
        LLVMIndirectBr = 4,
        LLVMInvoke = 5,
        LLVMUnreachable = 7,
        LLVMFNeg = 66,
        LLVMAdd = 8,
        LLVMFAdd = 9,
        LLVMSub = 10,
        LLVMFSub = 11,
        LLVMMul = 12,
        LLVMFMul = 13,
        LLVMUDiv = 14,
        LLVMSDiv = 15,
        LLVMFDiv = 16,
        LLVMURem = 17,
        LLVMSRem = 18,
        LLVMFRem = 19,
        LLVMShl = 20,
        LLVMLShr = 21,
        LLVMAShr = 22,
        LLVMAnd = 23,
        LLVMOr = 24,
        LLVMXor = 25,
        LLVMAlloca = 26,
        LLVMLoad = 27,
        LLVMStore = 28,
        LLVMGetElementPtr = 29,
        LLVMTrunc = 30,
        LLVMZExt = 31,
        LLVMSExt = 32,
        LLVMFPToUI = 33,
        LLVMFPToSI = 34,
        LLVMUIToFP = 35,
        LLVMSIToFP = 36,
        LLVMFPTrunc = 37,
        LLVMFPExt = 38,
        LLVMPtrToInt = 39,
        LLVMIntToPtr = 40,
        LLVMBitCast = 41,
        LLVMAddrSpaceCast = 60,
        LLVMICmp = 42,
        LLVMFCmp = 43,
        LLVMPHI = 44,
        LLVMCall = 45,
        LLVMSelect = 46,
        LLVMUserOp1 = 47,
        LLVMUserOp2 = 48,
        LLVMVAArg = 49,
        LLVMExtractElement = 50,
        LLVMInsertElement = 51,
        LLVMShuffleVector = 52,
        LLVMExtractValue = 53,
        LLVMInsertValue = 54,
        LLVMFence = 55,
        LLVMAtomicCmpXchg = 56,
        LLVMAtomicRMW = 57,
        LLVMResume = 58,
        LLVMLandingPad = 59,
        LLVMCleanupRet = 61,
        LLVMCatchRet = 62,
        LLVMCatchPad = 63,
        LLVMCleanupPad = 64,
        LLVMCatchSwitch = 65,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMTypeKind : global::System.Int32
    {
        /**< type with no size */
        LLVMVoidTypeKind = 0,
        /**< 16 bit floating point type */
        LLVMHalfTypeKind = 1,
        /**< 32 bit floating point type */
        LLVMFloatTypeKind = 2,
        /**< 64 bit floating point type */
        LLVMDoubleTypeKind = 3,
        /**< 80 bit floating point type (X87) */
        LLVMX86_FP80TypeKind = 4,
        /**< 128 bit floating point type (112-bit mantissa)*/
        LLVMFP128TypeKind = 5,
        /**< 128 bit floating point type (two 64-bits) */
        LLVMPPC_FP128TypeKind = 6,
        /**< Labels */
        LLVMLabelTypeKind = 7,
        /**< Arbitrary bit width integers */
        LLVMIntegerTypeKind = 8,
        /**< Functions */
        LLVMFunctionTypeKind = 9,
        /**< Structures */
        LLVMStructTypeKind = 10,
        /**< Arrays */
        LLVMArrayTypeKind = 11,
        /**< Pointers */
        LLVMPointerTypeKind = 12,
        /**< SIMD 'packed' format, or other vector type */
        LLVMVectorTypeKind = 13,
        /**< Metadata */
        LLVMMetadataTypeKind = 14,
        /**< X86 MMX */
        LLVMX86_MMXTypeKind = 15,
        /**< Tokens */
        LLVMTokenTypeKind = 16,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMLinkage : global::System.Int32
    {
        /**< Externally visible function */
        LLVMExternalLinkage = 0,
        LLVMAvailableExternallyLinkage = 1,
        /**< Keep one copy of function when linking (inline)*/
        LLVMLinkOnceAnyLinkage = 2,
        /**< Same, but only replaced by something
                                    equivalent. */
        LLVMLinkOnceODRLinkage = 3,
        /**< Obsolete */
        LLVMLinkOnceODRAutoHideLinkage = 4,
        /**< Keep one copy of function when linking (weak) */
        LLVMWeakAnyLinkage = 5,
        /**< Same, but only replaced by something
                                    equivalent. */
        LLVMWeakODRLinkage = 6,
        /**< Special purpose, only applies to global arrays */
        LLVMAppendingLinkage = 7,
        /**< Rename collisions when linking (static
                                       functions) */
        LLVMInternalLinkage = 8,
        /**< Like Internal, but omit from symbol table */
        LLVMPrivateLinkage = 9,
        /**< Obsolete */
        LLVMDLLImportLinkage = 10,
        /**< Obsolete */
        LLVMDLLExportLinkage = 11,
        /**< ExternalWeak linkage description */
        LLVMExternalWeakLinkage = 12,
        /**< Obsolete */
        LLVMGhostLinkage = 13,
        /**< Tentative definitions */
        LLVMCommonLinkage = 14,
        /**< Like Private, but linker removes. */
        LLVMLinkerPrivateLinkage = 15,
        /**< Like LinkerPrivate, but is weak. */
        LLVMLinkerPrivateWeakLinkage = 16,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMVisibility : global::System.Int32
    {
        /**< The GV is visible */
        LLVMDefaultVisibility = 0,
        /**< The GV is hidden */
        LLVMHiddenVisibility = 1,
        /**< The GV is protected */
        LLVMProtectedVisibility = 2,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMUnnamedAddr : global::System.Int32
    {
        /**< Address of the GV is significant. */
        LLVMNoUnnamedAddr = 0,
        /**< Address of the GV is locally insignificant. */
        LLVMLocalUnnamedAddr = 1,
        /**< Address of the GV is globally insignificant. */
        LLVMGlobalUnnamedAddr = 2,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMDLLStorageClass : global::System.Int32
    {
        LLVMDefaultStorageClass = 0,
        /**< Function to be imported from DLL. */
        LLVMDLLImportStorageClass = 1,
        /**< Function to be accessible from DLL. */
        LLVMDLLExportStorageClass = 2,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMCallConv : global::System.Int32
    {
        LLVMCCallConv = 0,
        LLVMFastCallConv = 8,
        LLVMColdCallConv = 9,
        LLVMGHCCallConv = 10,
        LLVMHiPECallConv = 11,
        LLVMWebKitJSCallConv = 12,
        LLVMAnyRegCallConv = 13,
        LLVMPreserveMostCallConv = 14,
        LLVMPreserveAllCallConv = 15,
        LLVMSwiftCallConv = 16,
        LLVMCXXFASTTLSCallConv = 17,
        LLVMX86StdcallCallConv = 64,
        LLVMX86FastcallCallConv = 65,
        LLVMARMAPCSCallConv = 66,
        LLVMARMAAPCSCallConv = 67,
        LLVMARMAAPCSVFPCallConv = 68,
        LLVMMSP430INTRCallConv = 69,
        LLVMX86ThisCallCallConv = 70,
        LLVMPTXKernelCallConv = 71,
        LLVMPTXDeviceCallConv = 72,
        LLVMSPIRFUNCCallConv = 75,
        LLVMSPIRKERNELCallConv = 76,
        LLVMIntelOCLBICallConv = 77,
        LLVMX8664SysVCallConv = 78,
        LLVMWin64CallConv = 79,
        LLVMX86VectorCallCallConv = 80,
        LLVMHHVMCallConv = 81,
        LLVMHHVMCCallConv = 82,
        LLVMX86INTRCallConv = 83,
        LLVMAVRINTRCallConv = 84,
        LLVMAVRSIGNALCallConv = 85,
        LLVMAVRBUILTINCallConv = 86,
        LLVMAMDGPUVSCallConv = 87,
        LLVMAMDGPUGSCallConv = 88,
        LLVMAMDGPUPSCallConv = 89,
        LLVMAMDGPUCSCallConv = 90,
        LLVMAMDGPUKERNELCallConv = 91,
        LLVMX86RegCallCallConv = 92,
        LLVMAMDGPUHSCallConv = 93,
        LLVMMSP430BUILTINCallConv = 94,
        LLVMAMDGPULSCallConv = 95,
        LLVMAMDGPUESCallConv = 96,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMValueKind : global::System.Int32
    {
        LLVMArgumentValueKind = 0,
        LLVMBasicBlockValueKind = 1,
        LLVMMemoryUseValueKind = 2,
        LLVMMemoryDefValueKind = 3,
        LLVMMemoryPhiValueKind = 4,
        LLVMFunctionValueKind = 5,
        LLVMGlobalAliasValueKind = 6,
        LLVMGlobalIFuncValueKind = 7,
        LLVMGlobalVariableValueKind = 8,
        LLVMBlockAddressValueKind = 9,
        LLVMConstantExprValueKind = 10,
        LLVMConstantArrayValueKind = 11,
        LLVMConstantStructValueKind = 12,
        LLVMConstantVectorValueKind = 13,
        LLVMUndefValueValueKind = 14,
        LLVMConstantAggregateZeroValueKind = 15,
        LLVMConstantDataArrayValueKind = 16,
        LLVMConstantDataVectorValueKind = 17,
        LLVMConstantIntValueKind = 18,
        LLVMConstantFPValueKind = 19,
        LLVMConstantPointerNullValueKind = 20,
        LLVMConstantTokenNoneValueKind = 21,
        LLVMMetadataAsValueValueKind = 22,
        LLVMInlineAsmValueKind = 23,
        LLVMInstructionValueKind = 24,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMIntPredicate : global::System.Int32
    {
        /**< equal */
        LLVMIntEQ = 32,
        /**< not equal */
        LLVMIntNE = 33,
        /**< unsigned greater than */
        LLVMIntUGT = 34,
        /**< unsigned greater or equal */
        LLVMIntUGE = 35,
        /**< unsigned less than */
        LLVMIntULT = 36,
        /**< unsigned less or equal */
        LLVMIntULE = 37,
        /**< signed greater than */
        LLVMIntSGT = 38,
        /**< signed greater or equal */
        LLVMIntSGE = 39,
        /**< signed less than */
        LLVMIntSLT = 40,
        /**< signed less or equal */
        LLVMIntSLE = 41,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMRealPredicate : global::System.Int32
    {
        /**< Always false (always folded) */
        LLVMRealPredicateFalse = 0,
        /**< True if ordered and equal */
        LLVMRealOEQ = 1,
        /**< True if ordered and greater than */
        LLVMRealOGT = 2,
        /**< True if ordered and greater than or equal */
        LLVMRealOGE = 3,
        /**< True if ordered and less than */
        LLVMRealOLT = 4,
        /**< True if ordered and less than or equal */
        LLVMRealOLE = 5,
        /**< True if ordered and operands are unequal */
        LLVMRealONE = 6,
        /**< True if ordered (no nans) */
        LLVMRealORD = 7,
        /**< True if unordered: isnan(X) | isnan(Y) */
        LLVMRealUNO = 8,
        /**< True if unordered or equal */
        LLVMRealUEQ = 9,
        /**< True if unordered or greater than */
        LLVMRealUGT = 10,
        /**< True if unordered, greater than, or equal */
        LLVMRealUGE = 11,
        /**< True if unordered or less than */
        LLVMRealULT = 12,
        /**< True if unordered, less than, or equal */
        LLVMRealULE = 13,
        /**< True if unordered or not equal */
        LLVMRealUNE = 14,
        /**< Always true (always folded) */
        LLVMRealPredicateTrue = 15,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMLandingPadClauseTy : global::System.Int32
    {
        /**< A catch clause   */
        LLVMLandingPadCatch = 0,
        /**< A filter clause  */
        LLVMLandingPadFilter = 1,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMThreadLocalMode : global::System.Int32
    {
        LLVMNotThreadLocal = 0,
        LLVMGeneralDynamicTLSModel = 1,
        LLVMLocalDynamicTLSModel = 2,
        LLVMInitialExecTLSModel = 3,
        LLVMLocalExecTLSModel = 4,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMAtomicOrdering : global::System.Int32
    {
        /**< A load or store which is not atomic */
        LLVMAtomicOrderingNotAtomic = 0,
        /**< Lowest level of atomicity, guarantees
                                             somewhat sane results, lock free. */
        LLVMAtomicOrderingUnordered = 1,
        /**< guarantees that if you take all the
                                             operations affecting a specific address,
                                             a consistent ordering exists */
        LLVMAtomicOrderingMonotonic = 2,
        /**< Acquire provides a barrier of the sort
                                           necessary to acquire a lock to access other
                                           memory with normal loads and stores. */
        LLVMAtomicOrderingAcquire = 4,
        /**< Release is similar to Acquire, but with
                                           a barrier of the sort necessary to release
                                           a lock. */
        LLVMAtomicOrderingRelease = 5,
        /**< provides both an Acquire and a
                                                  Release barrier (for fences and
                                                  operations which both read and write
                                                   memory). */
        LLVMAtomicOrderingAcquireRelease = 6,
        /**< provides Acquire semantics
                                                         for loads and Release
                                                         semantics for stores.
                                                         Additionally, it guarantees
                                                         that a total ordering exists
                                                         between all
                                                         SequentiallyConsistent
                                                         operations. */
        LLVMAtomicOrderingSequentiallyConsistent = 7,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMAtomicRMWBinOp : global::System.Int32
    {
        /**< Set the new value and return the one old */
        LLVMAtomicRMWBinOpXchg = 0,
        /**< Add a value and return the old one */
        LLVMAtomicRMWBinOpAdd = 1,
        /**< Subtract a value and return the old one */
        LLVMAtomicRMWBinOpSub = 2,
        /**< And a value and return the old one */
        LLVMAtomicRMWBinOpAnd = 3,
        /**< Not-And a value and return the old one */
        LLVMAtomicRMWBinOpNand = 4,
        /**< OR a value and return the old one */
        LLVMAtomicRMWBinOpOr = 5,
        /**< Xor a value and return the old one */
        LLVMAtomicRMWBinOpXor = 6,
        /**< Sets the value if it's greater than the
                                     original using a signed comparison and return
                                     the old one */
        LLVMAtomicRMWBinOpMax = 7,
        /**< Sets the value if it's Smaller than the
                                     original using a signed comparison and return
                                     the old one */
        LLVMAtomicRMWBinOpMin = 8,
        /**< Sets the value if it's greater than the
                                     original using an unsigned comparison and return
                                     the old one */
        LLVMAtomicRMWBinOpUMax = 9,
        /**< Sets the value if it's greater than the
                                     original using an unsigned comparison  and return
                                     the old one */
        LLVMAtomicRMWBinOpUMin = 10,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMDiagnosticSeverity : global::System.Int32
    {
        LLVMDSError = 0,
        LLVMDSWarning = 1,
        LLVMDSRemark = 2,
        LLVMDSNote = 3,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMInlineAsmDialect : global::System.Int32
    {
        LLVMInlineAsmDialectATT = 0,
        LLVMInlineAsmDialectIntel = 1,
    }

    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMModuleFlagBehavior : global::System.Int32
    {
        /**
           * Emits an error if two values disagree, otherwise the resulting value is
           * that of the operands.
           *
           * @see Module::ModFlagBehavior::Error
           */
        LLVMModuleFlagBehaviorError = 0,
        /**
           * Emits a warning if two values disagree. The result value will be the
           * operand for the flag from the first module being linked.
           *
           * @see Module::ModFlagBehavior::Warning
           */
        LLVMModuleFlagBehaviorWarning = 1,
        /**
           * Adds a requirement that another module flag be present and have a
           * specified value after linking is performed. The value must be a metadata
           * pair, where the first element of the pair is the ID of the module flag
           * to be restricted, and the second element of the pair is the value the
           * module flag should be restricted to. This behavior can be used to
           * restrict the allowable results (via triggering of an error) of linking
           * IDs with the **Override** behavior.
           *
           * @see Module::ModFlagBehavior::Require
           */
        LLVMModuleFlagBehaviorRequire = 2,
        /**
           * Uses the specified value, regardless of the behavior or value of the
           * other module. If both modules specify **Override**, but the values
           * differ, an error will be emitted.
           *
           * @see Module::ModFlagBehavior::Override
           */
        LLVMModuleFlagBehaviorOverride = 3,
        /**
           * Appends the two values, which are required to be metadata nodes.
           *
           * @see Module::ModFlagBehavior::Append
           */
        LLVMModuleFlagBehaviorAppend = 4,
        /**
           * Appends the two values, which are required to be metadata
           * nodes. However, duplicate entries in the second list are dropped
           * during the append operation.
           *
           * @see Module::ModFlagBehavior::AppendUnique
           */
        LLVMModuleFlagBehaviorAppendUnique = 5,
    }

    /**
     * Attribute index are either LLVMAttributeReturnIndex,
     * LLVMAttributeFunctionIndex or a parameter number from 1 to N.
     */
    [GeneratedCode("LlvmBindingsGenerator","2.17941.31104.49410")]
    public enum LLVMAttributeIndex : global::System.Int32
    {
        LLVMAttributeReturnIndex = 0,
        LLVMAttributeFunctionIndex = -1,
    }

    /**
     * @defgroup LLVMCCoreContext Contexts
     *
     * Contexts are execution states for the core LLVM IR system.
     *
     * Most types are tied to a context instance. Multiple contexts can
     * exist simultaneously. A single context is not thread safe. However,
     * different contexts can execute on different threads simultaneously.
     *
     * @{
     */
    [UnmanagedFunctionPointer( global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
    public delegate void LLVMDiagnosticHandler( LLVMDiagnosticInfoRef _0, global::System.IntPtr _1 );

    [UnmanagedFunctionPointer( global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
    public delegate void LLVMYieldCallback( LLVMContextRef _0, global::System.IntPtr _1 );

    public static partial class NativeMethods
    {
        /**
         * @}
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMInitializeCore( LLVMPassRegistryRef R );

        /** Deallocate and destroy all ManagedStatic variables.
            @see llvm::llvm_shutdown
            @see ManagedStatic */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMShutdown(  );

        /**
         * Create a new context.
         *
         * Every call to this function should be paired with a call to
         * LLVMContextDispose() or the context will leak memory.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMContextRef LLVMContextCreate(  );

        /**
         * Obtain the global context instance.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMContextRefAlias LLVMGetGlobalContext(  );

        /**
         * Set the diagnostic handler for this context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMContextSetDiagnosticHandler( LLVMContextRef C, LLVMDiagnosticHandler Handler, global::System.IntPtr DiagnosticContext );

        /**
         * Get the diagnostic handler of this context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMDiagnosticHandler LLVMContextGetDiagnosticHandler( LLVMContextRef C );

        /**
         * Get the diagnostic context of this context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern global::System.IntPtr LLVMContextGetDiagnosticContext( LLVMContextRef C );

        /**
         * Set the yield callback function for this context.
         *
         * @see LLVMContext::setYieldCallback()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMContextSetYieldCallback( LLVMContextRef C, LLVMYieldCallback Callback, global::System.IntPtr OpaqueHandle );

        /**
         * Retrieve whether the given context is set to discard all value names.
         *
         * @see LLVMContext::shouldDiscardValueNames()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMContextShouldDiscardValueNames( LLVMContextRef C );

        /**
         * Set whether the given context discards all value names.
         *
         * If true, only the names of GlobalValue objects will be available in the IR.
         * This can be used to save memory and runtime, especially in release mode.
         *
         * @see LLVMContext::setDiscardValueNames()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMContextSetDiscardValueNames( LLVMContextRef C, [MarshalAs( UnmanagedType.Bool )]bool Discard );

        /**
         * Return a string representation of the DiagnosticInfo. Use
         * LLVMDisposeMessage to free the string.
         *
         * @see DiagnosticInfo::print()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]
        public static extern string LLVMGetDiagInfoDescription( LLVMDiagnosticInfoRef DI );

        /**
         * Return an enum LLVMDiagnosticSeverity.
         *
         * @see DiagnosticInfo::getSeverity()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMDiagnosticSeverity LLVMGetDiagInfoSeverity( LLVMDiagnosticInfoRef DI );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetMDKindIDInContext( LLVMContextRef C, [MarshalAs( UnmanagedType.LPStr )]string Name, uint SLen );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetMDKindID( [MarshalAs( UnmanagedType.LPStr )]string Name, uint SLen );

        /**
         * Return an unique id given the name of a enum attribute,
         * or 0 if no attribute by that name exists.
         *
         * See http://llvm.org/docs/LangRef.html#parameter-attributes
         * and http://llvm.org/docs/LangRef.html#function-attributes
         * for the list of available attributes.
         *
         * NB: Attribute names and/or id are subject to change without
         * going through the C API deprecation cycle.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetEnumAttributeKindForName( [MarshalAs( UnmanagedType.LPStr )]string Name, size_t SLen );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetLastEnumAttributeKind(  );

        /**
         * Create an enum attribute.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAttributeRef LLVMCreateEnumAttribute( LLVMContextRef C, uint KindID, System.UInt64 Val );

        /**
         * Get the unique id corresponding to the enum attribute
         * passed as argument.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetEnumAttributeKind( LLVMAttributeRef A );

        /**
         * Get the enum attribute's value. 0 is returned if none exists.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern System.UInt64 LLVMGetEnumAttributeValue( LLVMAttributeRef A );

        /**
         * Create a string attribute.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAttributeRef LLVMCreateStringAttribute( LLVMContextRef C, [MarshalAs( UnmanagedType.LPStr )]string K, uint KLength, [MarshalAs( UnmanagedType.LPStr )]string V, uint VLength );

        /**
         * Get the string attribute's kind.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetStringAttributeKind( LLVMAttributeRef A, out uint Length );

        /**
         * Get the string attribute's value.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetStringAttributeValue( LLVMAttributeRef A, out uint Length );

        /**
         * Check for the different types of attributes.
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsEnumAttribute( LLVMAttributeRef A );

        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsStringAttribute( LLVMAttributeRef A );

        /**
         * Create a new, empty module in the global context.
         *
         * This is equivalent to calling LLVMModuleCreateWithNameInContext with
         * LLVMGetGlobalContext() as the context parameter.
         *
         * Every invocation should be paired with LLVMDisposeModule() or memory
         * will be leaked.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMModuleRef LLVMModuleCreateWithName( [MarshalAs( UnmanagedType.LPStr )]string ModuleID );

        /**
         * Create a new, empty module in a specific context.
         *
         * Every invocation should be paired with LLVMDisposeModule() or memory
         * will be leaked.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMModuleRef LLVMModuleCreateWithNameInContext( [MarshalAs( UnmanagedType.LPStr )]string ModuleID, LLVMContextRef C );

        /**
         * Return an exact copy of the specified module.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMModuleRef LLVMCloneModule( LLVMModuleRef M );

        /**
         * Destroy a module instance.
         *
         * This must be called for every created module or memory will be
         * leaked.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMDisposeModule( LLVMModuleRef M );

        /**
         * Obtain the identifier of a module.
         *
         * @param M Module to obtain identifier of
         * @param Len Out parameter which holds the length of the returned string.
         * @return The identifier of M.
         * @see Module::getModuleIdentifier()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetModuleIdentifier( LLVMModuleRef M, out size_t Len );

        /**
         * Set the identifier of a module to a string Ident with length Len.
         *
         * @param M The module to set identifier
         * @param Ident The string to set M's identifier to
         * @param Len Length of Ident
         * @see Module::setModuleIdentifier()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetModuleIdentifier( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Ident, size_t Len );

        /**
         * Obtain the module's original source file name.
         *
         * @param M Module to obtain the name of
         * @param Len Out parameter which holds the length of the returned string
         * @return The original source file name of M
         * @see Module::getSourceFileName()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetSourceFileName( LLVMModuleRef M, out size_t Len );

        /**
         * Set the original source file name of a module to a string Name with length
         * Len.
         *
         * @param M The module to set the source file name of
         * @param Name The string to set M's source file name to
         * @param Len Length of Name
         * @see Module::setSourceFileName()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetSourceFileName( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name, size_t Len );

        /**
         * Obtain the data layout for a module.
         *
         * @see Module::getDataLayoutStr()
         *
         * LLVMGetDataLayout is DEPRECATED, as the name is not only incorrect,
         * but match the name of another method on the module. Prefer the use
         * of LLVMGetDataLayoutStr, which is not ambiguous.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetDataLayoutStr( LLVMModuleRef M );

        /**
         * Set the data layout for a module.
         *
         * @see Module::setDataLayout()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetDataLayout( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string DataLayoutStr );

        /**
         * Obtain the target triple for a module.
         *
         * @see Module::getTargetTriple()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetTarget( LLVMModuleRef M );

        /**
         * Set the target triple for a module.
         *
         * @see Module::setTargetTriple()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetTarget( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Triple );

        /**
         * Returns the module flags as an array of flag-key-value triples.  The caller
         * is responsible for freeing this array by calling
         * \c LLVMDisposeModuleFlagsMetadata.
         *
         * @see Module::getModuleFlagsMetadata()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMModuleFlagEntry LLVMCopyModuleFlagsMetadata( LLVMModuleRef M, out size_t Len );

        /**
         * Returns the flag behavior for a module flag entry at a specific index.
         *
         * @see Module::ModuleFlagEntry::Behavior
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMModuleFlagBehavior LLVMModuleFlagEntriesGetFlagBehavior( LLVMModuleFlagEntry Entries, uint Index );

        /**
         * Returns the key for a module flag entry at a specific index.
         *
         * @see Module::ModuleFlagEntry::Key
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMModuleFlagEntriesGetKey( LLVMModuleFlagEntry Entries, uint Index, out size_t Len );

        /**
         * Returns the metadata for a module flag entry at a specific index.
         *
         * @see Module::ModuleFlagEntry::Val
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMMetadataRef LLVMModuleFlagEntriesGetMetadata( LLVMModuleFlagEntry Entries, uint Index );

        /**
         * Add a module-level flag to the module-level flags metadata if it doesn't
         * already exist.
         *
         * @see Module::getModuleFlag()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMMetadataRef LLVMGetModuleFlag( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Key, size_t KeyLen );

        /**
         * Add a module-level flag to the module-level flags metadata if it doesn't
         * already exist.
         *
         * @see Module::addModuleFlag()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddModuleFlag( LLVMModuleRef M, LLVMModuleFlagBehavior Behavior, [MarshalAs( UnmanagedType.LPStr )]string Key, size_t KeyLen, LLVMMetadataRef Val );

        /**
         * Dump a representation of a module to stderr.
         *
         * @see Module::dump()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMDumpModule( LLVMModuleRef M );

        /**
         * Print a representation of a module to a file. The ErrorMessage needs to be
         * disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.
         *
         * @see Module::print()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMPrintModuleToFile( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Filename, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string ErrorMessage );

        /**
         * Return a string representation of the module. Use
         * LLVMDisposeMessage to free the string.
         *
         * @see Module::print()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]
        public static extern string LLVMPrintModuleToString( LLVMModuleRef M );

        /**
         * Get inline assembly for a module.
         *
         * @see Module::getModuleInlineAsm()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetModuleInlineAsm( LLVMModuleRef M, out size_t Len );

        /**
         * Set inline assembly for a module.
         *
         * @see Module::setModuleInlineAsm()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetModuleInlineAsm2( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Asm, size_t Len );

        /**
         * Append inline assembly to a module.
         *
         * @see Module::appendModuleInlineAsm()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAppendModuleInlineAsm( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Asm, size_t Len );

        /**
         * Create the specified uniqued inline asm string.
         *
         * @see InlineAsm::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetInlineAsm( LLVMTypeRef Ty, [MarshalAs( UnmanagedType.LPStr )]string AsmString, size_t AsmStringSize, [MarshalAs( UnmanagedType.LPStr )]string Constraints, size_t ConstraintsSize, [MarshalAs( UnmanagedType.Bool )]bool HasSideEffects, [MarshalAs( UnmanagedType.Bool )]bool IsAlignStack, LLVMInlineAsmDialect Dialect );

        /**
         * Obtain the context to which this module is associated.
         *
         * @see Module::getContext()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMContextRefAlias LLVMGetModuleContext( LLVMModuleRef M );

        /**
         * Obtain a Type from a module by its registered name.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMGetTypeByName( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Obtain an iterator to the first NamedMDNode in a Module.
         *
         * @see llvm::Module::named_metadata_begin()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMNamedMDNodeRef LLVMGetFirstNamedMetadata( LLVMModuleRef M );

        /**
         * Obtain an iterator to the last NamedMDNode in a Module.
         *
         * @see llvm::Module::named_metadata_end()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMNamedMDNodeRef LLVMGetLastNamedMetadata( LLVMModuleRef M );

        /**
         * Advance a NamedMDNode iterator to the next NamedMDNode.
         *
         * Returns NULL if the iterator was already at the end and there are no more
         * named metadata nodes.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMNamedMDNodeRef LLVMGetNextNamedMetadata( LLVMNamedMDNodeRef NamedMDNode );

        /**
         * Decrement a NamedMDNode iterator to the previous NamedMDNode.
         *
         * Returns NULL if the iterator was already at the beginning and there are
         * no previous named metadata nodes.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMNamedMDNodeRef LLVMGetPreviousNamedMetadata( LLVMNamedMDNodeRef NamedMDNode );

        /**
         * Retrieve a NamedMDNode with the given name, returning NULL if no such
         * node exists.
         *
         * @see llvm::Module::getNamedMetadata()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMNamedMDNodeRef LLVMGetNamedMetadata( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name, size_t NameLen );

        /**
         * Retrieve a NamedMDNode with the given name, creating a new node if no such
         * node exists.
         *
         * @see llvm::Module::getOrInsertNamedMetadata()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMNamedMDNodeRef LLVMGetOrInsertNamedMetadata( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name, size_t NameLen );

        /**
         * Retrieve the name of a NamedMDNode.
         *
         * @see llvm::NamedMDNode::getName()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetNamedMetadataName( LLVMNamedMDNodeRef NamedMD, out size_t NameLen );

        /**
         * Obtain the number of operands for named metadata in a module.
         *
         * @see llvm::Module::getNamedMetadata()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetNamedMetadataNumOperands( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Obtain the named metadata operands for a module.
         *
         * The passed LLVMValueRef pointer should refer to an array of
         * LLVMValueRef at least LLVMGetNamedMetadataNumOperands long. This
         * array will be populated with the LLVMValueRef instances. Each
         * instance corresponds to a llvm::MDNode.
         *
         * @see llvm::Module::getNamedMetadata()
         * @see llvm::MDNode::getOperand()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetNamedMetadataOperands( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name, out LLVMValueRef Dest );

        /**
         * Add an operand to named metadata.
         *
         * @see llvm::Module::getNamedMetadata()
         * @see llvm::MDNode::addOperand()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddNamedMetadataOperand( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name, LLVMValueRef Val );

        /**
         * Return the directory of the debug location for this value, which must be
         * an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.
         *
         * @see llvm::Instruction::getDebugLoc()
         * @see llvm::GlobalVariable::getDebugInfo()
         * @see llvm::Function::getSubprogram()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetDebugLocDirectory( LLVMValueRef Val, out uint Length );

        /**
         * Return the filename of the debug location for this value, which must be
         * an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.
         *
         * @see llvm::Instruction::getDebugLoc()
         * @see llvm::GlobalVariable::getDebugInfo()
         * @see llvm::Function::getSubprogram()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetDebugLocFilename( LLVMValueRef Val, out uint Length );

        /**
         * Return the line number of the debug location for this value, which must be
         * an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.
         *
         * @see llvm::Instruction::getDebugLoc()
         * @see llvm::GlobalVariable::getDebugInfo()
         * @see llvm::Function::getSubprogram()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetDebugLocLine( LLVMValueRef Val );

        /**
         * Return the column number of the debug location for this value, which must be
         * an llvm::Instruction.
         *
         * @see llvm::Instruction::getDebugLoc()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetDebugLocColumn( LLVMValueRef Val );

        /**
         * Add a function to a module under a specified name.
         *
         * @see llvm::Function::Create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMAddFunction( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name, LLVMTypeRef FunctionTy );

        /**
         * Obtain a Function value from a Module by its name.
         *
         * The returned value corresponds to a llvm::Function value.
         *
         * @see llvm::Module::getFunction()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetNamedFunction( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Obtain an iterator to the first Function in a Module.
         *
         * @see llvm::Module::begin()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetFirstFunction( LLVMModuleRef M );

        /**
         * Obtain an iterator to the last Function in a Module.
         *
         * @see llvm::Module::end()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetLastFunction( LLVMModuleRef M );

        /**
         * Advance a Function iterator to the next Function.
         *
         * Returns NULL if the iterator was already at the end and there are no more
         * functions.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetNextFunction( LLVMValueRef Fn );

        /**
         * Decrement a Function iterator to the previous Function.
         *
         * Returns NULL if the iterator was already at the beginning and there are
         * no previous functions.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetPreviousFunction( LLVMValueRef Fn );

        /**
         * Obtain the enumerated type of a Type instance.
         *
         * @see llvm::Type:getTypeID()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeKind LLVMGetTypeKind( LLVMTypeRef Ty );

        /**
         * Whether the type has a known size.
         *
         * Things that don't have a size are abstract types, labels, and void.a
         *
         * @see llvm::Type::isSized()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMTypeIsSized( LLVMTypeRef Ty );

        /**
         * Obtain the context to which this type instance is associated.
         *
         * @see llvm::Type::getContext()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMContextRefAlias LLVMGetTypeContext( LLVMTypeRef Ty );

        /**
         * Dump a representation of a type to stderr.
         *
         * @see llvm::Type::dump()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMDumpType( LLVMTypeRef Val );

        /**
         * Return a string representation of the type. Use
         * LLVMDisposeMessage to free the string.
         *
         * @see llvm::Type::print()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]
        public static extern string LLVMPrintTypeToString( LLVMTypeRef Val );

        /**
         * Obtain an integer type from a context with specified bit width.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt1TypeInContext( LLVMContextRef C );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt8TypeInContext( LLVMContextRef C );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt16TypeInContext( LLVMContextRef C );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt32TypeInContext( LLVMContextRef C );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt64TypeInContext( LLVMContextRef C );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt128TypeInContext( LLVMContextRef C );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMIntTypeInContext( LLVMContextRef C, uint NumBits );

        /**
         * Obtain an integer type from the global context with a specified bit
         * width.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt1Type(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt8Type(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt16Type(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt32Type(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt64Type(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMInt128Type(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMIntType( uint NumBits );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetIntTypeWidth( LLVMTypeRef IntegerTy );

        /**
         * Obtain a 16-bit floating point type from a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMHalfTypeInContext( LLVMContextRef C );

        /**
         * Obtain a 32-bit floating point type from a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMFloatTypeInContext( LLVMContextRef C );

        /**
         * Obtain a 64-bit floating point type from a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMDoubleTypeInContext( LLVMContextRef C );

        /**
         * Obtain a 80-bit floating point type (X87) from a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMX86FP80TypeInContext( LLVMContextRef C );

        /**
         * Obtain a 128-bit floating point type (112-bit mantissa) from a
         * context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMFP128TypeInContext( LLVMContextRef C );

        /**
         * Obtain a 128-bit floating point type (two 64-bits) from a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMPPCFP128TypeInContext( LLVMContextRef C );

        /**
         * Obtain a floating point type from the global context.
         *
         * These map to the functions in this group of the same name.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMHalfType(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMFloatType(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMDoubleType(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMX86FP80Type(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMFP128Type(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMPPCFP128Type(  );

        /**
         * Obtain a function type consisting of a specified signature.
         *
         * The function is defined as a tuple of a return Type, a list of
         * parameter types, and whether the function is variadic.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMFunctionType( LLVMTypeRef ReturnType, out LLVMTypeRef ParamTypes, uint ParamCount, [MarshalAs( UnmanagedType.Bool )]bool IsVarArg );

        /**
         * Returns whether a function type is variadic.
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsFunctionVarArg( LLVMTypeRef FunctionTy );

        /**
         * Obtain the Type this function Type returns.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMGetReturnType( LLVMTypeRef FunctionTy );

        /**
         * Obtain the number of parameters this function accepts.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMCountParamTypes( LLVMTypeRef FunctionTy );

        /**
         * Obtain the types of a function's parameters.
         *
         * The Dest parameter should point to a pre-allocated array of
         * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the
         * first LLVMCountParamTypes() entries in the array will be populated
         * with LLVMTypeRef instances.
         *
         * @param FunctionTy The function type to operate on.
         * @param Dest Memory address of an array to be filled with result.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetParamTypes( LLVMTypeRef FunctionTy, out LLVMTypeRef Dest );

        /**
         * Create a new structure type in a context.
         *
         * A structure is specified by a list of inner elements/types and
         * whether these can be packed together.
         *
         * @see llvm::StructType::create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMStructTypeInContext( LLVMContextRef C, out LLVMTypeRef ElementTypes, uint ElementCount, [MarshalAs( UnmanagedType.Bool )]bool Packed );

        /**
         * Create a new structure type in the global context.
         *
         * @see llvm::StructType::create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMStructType( out LLVMTypeRef ElementTypes, uint ElementCount, [MarshalAs( UnmanagedType.Bool )]bool Packed );

        /**
         * Create an empty structure in a context having a specified name.
         *
         * @see llvm::StructType::create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMStructCreateNamed( LLVMContextRef C, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Obtain the name of a structure.
         *
         * @see llvm::StructType::getName()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetStructName( LLVMTypeRef Ty );

        /**
         * Set the contents of a structure type.
         *
         * @see llvm::StructType::setBody()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMStructSetBody( LLVMTypeRef StructTy, out LLVMTypeRef ElementTypes, uint ElementCount, [MarshalAs( UnmanagedType.Bool )]bool Packed );

        /**
         * Get the number of elements defined inside the structure.
         *
         * @see llvm::StructType::getNumElements()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMCountStructElementTypes( LLVMTypeRef StructTy );

        /**
         * Get the elements within a structure.
         *
         * The function is passed the address of a pre-allocated array of
         * LLVMTypeRef at least LLVMCountStructElementTypes() long. After
         * invocation, this array will be populated with the structure's
         * elements. The objects in the destination array will have a lifetime
         * of the structure type itself, which is the lifetime of the context it
         * is contained in.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetStructElementTypes( LLVMTypeRef StructTy, out LLVMTypeRef Dest );

        /**
         * Get the type of the element at a given index in the structure.
         *
         * @see llvm::StructType::getTypeAtIndex()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMStructGetTypeAtIndex( LLVMTypeRef StructTy, uint i );

        /**
         * Determine whether a structure is packed.
         *
         * @see llvm::StructType::isPacked()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsPackedStruct( LLVMTypeRef StructTy );

        /**
         * Determine whether a structure is opaque.
         *
         * @see llvm::StructType::isOpaque()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsOpaqueStruct( LLVMTypeRef StructTy );

        /**
         * Determine whether a structure is literal.
         *
         * @see llvm::StructType::isLiteral()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsLiteralStruct( LLVMTypeRef StructTy );

        /**
         * Obtain the type of elements within a sequential type.
         *
         * This works on array, vector, and pointer types.
         *
         * @see llvm::SequentialType::getElementType()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMGetElementType( LLVMTypeRef Ty );

        /**
         * Returns type's subtypes
         *
         * @see llvm::Type::subtypes()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetSubtypes( LLVMTypeRef Tp, out LLVMTypeRef Arr );

        /**
         *  Return the number of types in the derived type.
         *
         * @see llvm::Type::getNumContainedTypes()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetNumContainedTypes( LLVMTypeRef Tp );

        /**
         * Create a fixed size array type that refers to a specific type.
         *
         * The created type will exist in the context that its element type
         * exists in.
         *
         * @see llvm::ArrayType::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMArrayType( LLVMTypeRef ElementType, uint ElementCount );

        /**
         * Obtain the length of an array type.
         *
         * This only works on types that represent arrays.
         *
         * @see llvm::ArrayType::getNumElements()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetArrayLength( LLVMTypeRef ArrayTy );

        /**
         * Create a pointer type that points to a defined type.
         *
         * The created type will exist in the context that its pointee type
         * exists in.
         *
         * @see llvm::PointerType::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMPointerType( LLVMTypeRef ElementType, uint AddressSpace );

        /**
         * Obtain the address space of a pointer type.
         *
         * This only works on types that represent pointers.
         *
         * @see llvm::PointerType::getAddressSpace()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetPointerAddressSpace( LLVMTypeRef PointerTy );

        /**
         * Create a vector type that contains a defined type and has a specific
         * number of elements.
         *
         * The created type will exist in the context thats its element type
         * exists in.
         *
         * @see llvm::VectorType::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMVectorType( LLVMTypeRef ElementType, uint ElementCount );

        /**
         * Obtain the number of elements in a vector type.
         *
         * This only works on types that represent vectors.
         *
         * @see llvm::VectorType::getNumElements()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetVectorSize( LLVMTypeRef VectorTy );

        /**
         * Create a void type in a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMVoidTypeInContext( LLVMContextRef C );

        /**
         * Create a label type in a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMLabelTypeInContext( LLVMContextRef C );

        /**
         * Create a X86 MMX type in a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMX86MMXTypeInContext( LLVMContextRef C );

        /**
         * Create a token type in a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMTokenTypeInContext( LLVMContextRef C );

        /**
         * Create a metadata type in a context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMMetadataTypeInContext( LLVMContextRef C );

        /**
         * These are similar to the above functions except they operate on the
         * global context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMVoidType(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMLabelType(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMX86MMXType(  );

        /**
         * Obtain the type of a value.
         *
         * @see llvm::Value::getType()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMTypeOf( LLVMValueRef Val );

        /**
         * Obtain the enumerated type of a Value instance.
         *
         * @see llvm::Value::getValueID()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueKind LLVMGetValueKind( LLVMValueRef Val );

        /**
         * Obtain the string name of a value.
         *
         * @see llvm::Value::getName()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetValueName2( LLVMValueRef Val, out size_t Length );

        /**
         * Set the string name of a value.
         *
         * @see llvm::Value::setName()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetValueName2( LLVMValueRef Val, [MarshalAs( UnmanagedType.LPStr )]string Name, size_t NameLen );

        /**
         * Dump a representation of a value to stderr.
         *
         * @see llvm::Value::dump()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMDumpValue( LLVMValueRef Val );

        /**
         * Return a string representation of the value. Use
         * LLVMDisposeMessage to free the string.
         *
         * @see llvm::Value::print()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]
        public static extern string LLVMPrintValueToString( LLVMValueRef Val );

        /**
         * Replace all uses of a value with another one.
         *
         * @see llvm::Value::replaceAllUsesWith()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMReplaceAllUsesWith( LLVMValueRef OldVal, LLVMValueRef NewVal );

        /**
         * Determine whether the specified value instance is constant.
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsConstant( LLVMValueRef Val );

        /**
         * Determine whether a value instance is undefined.
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsUndef( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAArgument( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsABasicBlock( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAInlineAsm( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAUser( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstant( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsABlockAddress( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantAggregateZero( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantArray( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantDataSequential( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantDataArray( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantDataVector( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantExpr( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantFP( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantInt( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantPointerNull( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantStruct( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantTokenNone( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAConstantVector( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAGlobalValue( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAGlobalAlias( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAGlobalIFunc( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAGlobalObject( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAFunction( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAGlobalVariable( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAUndefValue( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAInstruction( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsABinaryOperator( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsACallInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAIntrinsicInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsADbgInfoIntrinsic( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsADbgVariableIntrinsic( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsADbgDeclareInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsADbgLabelInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAMemIntrinsic( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAMemCpyInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAMemMoveInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAMemSetInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsACmpInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAFCmpInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAICmpInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAExtractElementInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAGetElementPtrInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAInsertElementInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAInsertValueInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsALandingPadInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAPHINode( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsASelectInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAShuffleVectorInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAStoreInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsABranchInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAIndirectBrInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAInvokeInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAReturnInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsASwitchInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAUnreachableInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAResumeInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsACleanupReturnInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsACatchReturnInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAFuncletPadInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsACatchPadInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsACleanupPadInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAUnaryInstruction( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAAllocaInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsACastInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAAddrSpaceCastInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsABitCastInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAFPExtInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAFPToSIInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAFPToUIInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAFPTruncInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAIntToPtrInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAPtrToIntInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsASExtInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsASIToFPInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsATruncInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAUIToFPInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAZExtInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAExtractValueInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsALoadInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAVAArgInst( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAMDNode( LLVMValueRef Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsAMDString( LLVMValueRef Val );

        /**
         * Obtain the first use of a value.
         *
         * Uses are obtained in an iterator fashion. First, call this function
         * to obtain a reference to the first use. Then, call LLVMGetNextUse()
         * on that instance and all subsequently obtained instances until
         * LLVMGetNextUse() returns NULL.
         *
         * @see llvm::Value::use_begin()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMUseRef LLVMGetFirstUse( LLVMValueRef Val );

        /**
         * Obtain the next use of a value.
         *
         * This effectively advances the iterator. It returns NULL if you are on
         * the final use and no more are available.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMUseRef LLVMGetNextUse( LLVMUseRef U );

        /**
         * Obtain the user value for a user.
         *
         * The returned value corresponds to a llvm::User type.
         *
         * @see llvm::Use::getUser()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetUser( LLVMUseRef U );

        /**
         * Obtain the value this use corresponds to.
         *
         * @see llvm::Use::get().
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetUsedValue( LLVMUseRef U );

        /**
         * Obtain an operand at a specific index in a llvm::User value.
         *
         * @see llvm::User::getOperand()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetOperand( LLVMValueRef Val, uint Index );

        /**
         * Obtain the use of an operand at a specific index in a llvm::User value.
         *
         * @see llvm::User::getOperandUse()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMUseRef LLVMGetOperandUse( LLVMValueRef Val, uint Index );

        /**
         * Set an operand at a specific index in a llvm::User value.
         *
         * @see llvm::User::setOperand()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetOperand( LLVMValueRef User, uint Index, LLVMValueRef Val );

        /**
         * Obtain the number of operands in a llvm::User value.
         *
         * @see llvm::User::getNumOperands()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern int LLVMGetNumOperands( LLVMValueRef Val );

        /**
         * Obtain a constant value referring to the null instance of a type.
         *
         * @see llvm::Constant::getNullValue()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNull( LLVMTypeRef Ty );

        /**
         * Obtain a constant value referring to the instance of a type
         * consisting of all ones.
         *
         * This is only valid for integer types.
         *
         * @see llvm::Constant::getAllOnesValue()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstAllOnes( LLVMTypeRef Ty );

        /**
         * Obtain a constant value referring to an undefined value of a type.
         *
         * @see llvm::UndefValue::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetUndef( LLVMTypeRef Ty );

        /**
         * Determine whether a value instance is null.
         *
         * @see llvm::Constant::isNullValue()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsNull( LLVMValueRef Val );

        /**
         * Obtain a constant that is a constant pointer pointing to NULL for a
         * specified type.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstPointerNull( LLVMTypeRef Ty );

        /**
         * Obtain a constant value for an integer type.
         *
         * The returned value corresponds to a llvm::ConstantInt.
         *
         * @see llvm::ConstantInt::get()
         *
         * @param IntTy Integer type to obtain value of.
         * @param N The value the returned instance should refer to.
         * @param SignExtend Whether to sign extend the produced value.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstInt( LLVMTypeRef IntTy, ulong N, [MarshalAs( UnmanagedType.Bool )]bool SignExtend );

        /**
         * Obtain a constant value for an integer of arbitrary precision.
         *
         * @see llvm::ConstantInt::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstIntOfArbitraryPrecision( LLVMTypeRef IntTy, uint NumWords, System.UInt64[] Words );

        /**
         * Obtain a constant value for an integer parsed from a string.
         *
         * A similar API, LLVMConstIntOfStringAndSize is also available. If the
         * string's length is available, it is preferred to call that function
         * instead.
         *
         * @see llvm::ConstantInt::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstIntOfString( LLVMTypeRef IntTy, [MarshalAs( UnmanagedType.LPStr )]string Text, System.Byte Radix );

        /**
         * Obtain a constant value for an integer parsed from a string with
         * specified length.
         *
         * @see llvm::ConstantInt::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstIntOfStringAndSize( LLVMTypeRef IntTy, [MarshalAs( UnmanagedType.LPStr )]string Text, uint SLen, System.Byte Radix );

        /**
         * Obtain a constant value referring to a double floating point value.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstReal( LLVMTypeRef RealTy, double N );

        /**
         * Obtain a constant for a floating point value parsed from a string.
         *
         * A similar API, LLVMConstRealOfStringAndSize is also available. It
         * should be used if the input string's length is known.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstRealOfString( LLVMTypeRef RealTy, [MarshalAs( UnmanagedType.LPStr )]string Text );

        /**
         * Obtain a constant for a floating point value parsed from a string.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstRealOfStringAndSize( LLVMTypeRef RealTy, [MarshalAs( UnmanagedType.LPStr )]string Text, uint SLen );

        /**
         * Obtain the zero extended value for an integer constant value.
         *
         * @see llvm::ConstantInt::getZExtValue()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern ulong LLVMConstIntGetZExtValue( LLVMValueRef ConstantVal );

        /**
         * Obtain the sign extended value for an integer constant value.
         *
         * @see llvm::ConstantInt::getSExtValue()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern long LLVMConstIntGetSExtValue( LLVMValueRef ConstantVal );

        /**
         * Obtain the double value for an floating point constant value.
         * losesInfo indicates if some precision was lost in the conversion.
         *
         * @see llvm::ConstantFP::getDoubleValue
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern double LLVMConstRealGetDouble( LLVMValueRef ConstantVal, out bool losesInfo );

        /**
         * Create a ConstantDataSequential and initialize it with a string.
         *
         * @see llvm::ConstantDataArray::getString()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstStringInContext( LLVMContextRef C, [MarshalAs( UnmanagedType.LPStr )]string Str, uint Length, [MarshalAs( UnmanagedType.Bool )]bool DontNullTerminate );

        /**
         * Create a ConstantDataSequential with string content in the global context.
         *
         * This is the same as LLVMConstStringInContext except it operates on the
         * global context.
         *
         * @see LLVMConstStringInContext()
         * @see llvm::ConstantDataArray::getString()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstString( [MarshalAs( UnmanagedType.LPStr )]string Str, uint Length, [MarshalAs( UnmanagedType.Bool )]bool DontNullTerminate );

        /**
         * Returns true if the specified constant is an array of i8.
         *
         * @see ConstantDataSequential::getAsString()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsConstantString( LLVMValueRef c );

        /**
         * Get the given constant data sequential as a string.
         *
         * @see ConstantDataSequential::getAsString()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetAsString( LLVMValueRef c, out size_t Length );

        /**
         * Create an anonymous ConstantStruct with the specified values.
         *
         * @see llvm::ConstantStruct::getAnon()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstStructInContext( LLVMContextRef C, out LLVMValueRef ConstantVals, uint Count, [MarshalAs( UnmanagedType.Bool )]bool Packed );

        /**
         * Create a ConstantStruct in the global Context.
         *
         * This is the same as LLVMConstStructInContext except it operates on the
         * global Context.
         *
         * @see LLVMConstStructInContext()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstStruct( out LLVMValueRef ConstantVals, uint Count, [MarshalAs( UnmanagedType.Bool )]bool Packed );

        /**
         * Create a ConstantArray from values.
         *
         * @see llvm::ConstantArray::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstArray( LLVMTypeRef ElementTy, out LLVMValueRef ConstantVals, uint Length );

        /**
         * Create a non-anonymous ConstantStruct from values.
         *
         * @see llvm::ConstantStruct::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNamedStruct( LLVMTypeRef StructTy, out LLVMValueRef ConstantVals, uint Count );

        /**
         * Get an element at specified index as a constant.
         *
         * @see ConstantDataSequential::getElementAsConstant()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetElementAsConstant( LLVMValueRef C, uint idx );

        /**
         * Create a ConstantVector from values.
         *
         * @see llvm::ConstantVector::get()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstVector( out LLVMValueRef ScalarConstantVals, uint Size );

        /**
         * @defgroup LLVMCCoreValueConstantExpressions Constant Expressions
         *
         * Functions in this group correspond to APIs on llvm::ConstantExpr.
         *
         * @see llvm::ConstantExpr.
         *
         * @{
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMOpcode LLVMGetConstOpcode( LLVMValueRef ConstantVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMAlignOf( LLVMTypeRef Ty );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMSizeOf( LLVMTypeRef Ty );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNeg( LLVMValueRef ConstantVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNSWNeg( LLVMValueRef ConstantVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNUWNeg( LLVMValueRef ConstantVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFNeg( LLVMValueRef ConstantVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNot( LLVMValueRef ConstantVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstAdd( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNSWAdd( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNUWAdd( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFAdd( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstSub( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNSWSub( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNUWSub( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFSub( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstMul( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNSWMul( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstNUWMul( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFMul( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstUDiv( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstExactUDiv( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstSDiv( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstExactSDiv( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFDiv( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstURem( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstSRem( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFRem( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstAnd( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstOr( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstXor( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstICmp( LLVMIntPredicate Predicate, LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFCmp( LLVMRealPredicate Predicate, LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstShl( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstLShr( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstAShr( LLVMValueRef LHSConstant, LLVMValueRef RHSConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstGEP( LLVMValueRef ConstantVal, out LLVMValueRef ConstantIndices, uint NumIndices );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstInBoundsGEP( LLVMValueRef ConstantVal, out LLVMValueRef ConstantIndices, uint NumIndices );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstTrunc( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstSExt( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstZExt( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFPTrunc( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFPExt( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstUIToFP( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstSIToFP( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFPToUI( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFPToSI( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstPtrToInt( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstIntToPtr( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstBitCast( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstAddrSpaceCast( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstZExtOrBitCast( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstSExtOrBitCast( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstTruncOrBitCast( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstPointerCast( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstIntCast( LLVMValueRef ConstantVal, LLVMTypeRef ToType, [MarshalAs( UnmanagedType.Bool )]bool isSigned );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstFPCast( LLVMValueRef ConstantVal, LLVMTypeRef ToType );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstSelect( LLVMValueRef ConstantCondition, LLVMValueRef ConstantIfTrue, LLVMValueRef ConstantIfFalse );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstExtractElement( LLVMValueRef VectorConstant, LLVMValueRef IndexConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstInsertElement( LLVMValueRef VectorConstant, LLVMValueRef ElementValueConstant, LLVMValueRef IndexConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstShuffleVector( LLVMValueRef VectorAConstant, LLVMValueRef VectorBConstant, LLVMValueRef MaskConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstExtractValue( LLVMValueRef AggConstant, out uint IdxList, uint NumIdx );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMConstInsertValue( LLVMValueRef AggConstant, LLVMValueRef ElementValueConstant, out uint IdxList, uint NumIdx );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBlockAddress( LLVMValueRef F, LLVMBasicBlockRef BB );

        /**
         * @defgroup LLVMCCoreValueConstantGlobals Global Values
         *
         * This group contains functions that operate on global values. Functions in
         * this group relate to functions in the llvm::GlobalValue class tree.
         *
         * @see llvm::GlobalValue
         *
         * @{
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMModuleRef LLVMGetGlobalParent( LLVMValueRef Global );

        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsDeclaration( LLVMValueRef Global );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMLinkage LLVMGetLinkage( LLVMValueRef Global );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetLinkage( LLVMValueRef Global, LLVMLinkage Linkage );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetSection( LLVMValueRef Global );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetSection( LLVMValueRef Global, [MarshalAs( UnmanagedType.LPStr )]string Section );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMVisibility LLVMGetVisibility( LLVMValueRef Global );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetVisibility( LLVMValueRef Global, LLVMVisibility Viz );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMDLLStorageClass LLVMGetDLLStorageClass( LLVMValueRef Global );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetDLLStorageClass( LLVMValueRef Global, LLVMDLLStorageClass Class );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMUnnamedAddr LLVMGetUnnamedAddress( LLVMValueRef Global );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetUnnamedAddress( LLVMValueRef Global, LLVMUnnamedAddr UnnamedAddr );

        /**
         * Returns the "value type" of a global value.  This differs from the formal
         * type of a global value which is always a pointer type.
         *
         * @see llvm::GlobalValue::getValueType()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMGlobalGetValueType( LLVMValueRef Global );

        /**
         * Obtain the preferred alignment of the value.
         * @see llvm::AllocaInst::getAlignment()
         * @see llvm::LoadInst::getAlignment()
         * @see llvm::StoreInst::getAlignment()
         * @see llvm::GlobalValue::getAlignment()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetAlignment( LLVMValueRef V );

        /**
         * Set the preferred alignment of the value.
         * @see llvm::AllocaInst::setAlignment()
         * @see llvm::LoadInst::setAlignment()
         * @see llvm::StoreInst::setAlignment()
         * @see llvm::GlobalValue::setAlignment()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetAlignment( LLVMValueRef V, uint Bytes );

        /**
         * Sets a metadata attachment, erasing the existing metadata attachment if
         * it already exists for the given kind.
         *
         * @see llvm::GlobalObject::setMetadata()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGlobalSetMetadata( LLVMValueRef Global, uint Kind, LLVMMetadataRef MD );

        /**
         * Erases a metadata attachment of the given kind if it exists.
         *
         * @see llvm::GlobalObject::eraseMetadata()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGlobalEraseMetadata( LLVMValueRef Global, uint Kind );

        /**
         * Removes all metadata attachments from this value.
         *
         * @see llvm::GlobalObject::clearMetadata()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGlobalClearMetadata( LLVMValueRef Global );

        /**
         * Retrieves an array of metadata entries representing the metadata attached to
         * this value. The caller is responsible for freeing this array by calling
         * \c LLVMDisposeValueMetadataEntries.
         *
         * @see llvm::GlobalObject::getAllMetadata()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueMetadataEntry LLVMGlobalCopyAllMetadata( LLVMValueRef Value, out size_t NumEntries );

        /**
         * Returns the kind of a value metadata entry at a specific index.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMValueMetadataEntriesGetKind( LLVMValueMetadataEntry Entries, uint Index );

        /**
         * Returns the underlying metadata node of a value metadata entry at a
         * specific index.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMMetadataRef LLVMValueMetadataEntriesGetMetadata( LLVMValueMetadataEntry Entries, uint Index );

        /**
         * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables
         *
         * This group contains functions that operate on global variable values.
         *
         * @see llvm::GlobalVariable
         *
         * @{
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMAddGlobal( LLVMModuleRef M, LLVMTypeRef Ty, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMAddGlobalInAddressSpace( LLVMModuleRef M, LLVMTypeRef Ty, [MarshalAs( UnmanagedType.LPStr )]string Name, uint AddressSpace );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetNamedGlobal( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetFirstGlobal( LLVMModuleRef M );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetLastGlobal( LLVMModuleRef M );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetNextGlobal( LLVMValueRef GlobalVar );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetPreviousGlobal( LLVMValueRef GlobalVar );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMDeleteGlobal( LLVMValueRef GlobalVar );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetInitializer( LLVMValueRef GlobalVar );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetInitializer( LLVMValueRef GlobalVar, LLVMValueRef ConstantVal );

        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsThreadLocal( LLVMValueRef GlobalVar );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetThreadLocal( LLVMValueRef GlobalVar, [MarshalAs( UnmanagedType.Bool )]bool IsThreadLocal );

        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsGlobalConstant( LLVMValueRef GlobalVar );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetGlobalConstant( LLVMValueRef GlobalVar, [MarshalAs( UnmanagedType.Bool )]bool IsConstant );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMThreadLocalMode LLVMGetThreadLocalMode( LLVMValueRef GlobalVar );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetThreadLocalMode( LLVMValueRef GlobalVar, LLVMThreadLocalMode Mode );

        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsExternallyInitialized( LLVMValueRef GlobalVar );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetExternallyInitialized( LLVMValueRef GlobalVar, [MarshalAs( UnmanagedType.Bool )]bool IsExtInit );

        /**
         * @defgroup LLVMCoreValueConstantGlobalAlias Global Aliases
         *
         * This group contains function that operate on global alias values.
         *
         * @see llvm::GlobalAlias
         *
         * @{
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMAddAlias( LLVMModuleRef M, LLVMTypeRef Ty, LLVMValueRef Aliasee, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Obtain a GlobalAlias value from a Module by its name.
         *
         * The returned value corresponds to a llvm::GlobalAlias value.
         *
         * @see llvm::Module::getNamedAlias()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetNamedGlobalAlias( LLVMModuleRef M, [MarshalAs( UnmanagedType.LPStr )]string Name, size_t NameLen );

        /**
         * Obtain an iterator to the first GlobalAlias in a Module.
         *
         * @see llvm::Module::alias_begin()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetFirstGlobalAlias( LLVMModuleRef M );

        /**
         * Obtain an iterator to the last GlobalAlias in a Module.
         *
         * @see llvm::Module::alias_end()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetLastGlobalAlias( LLVMModuleRef M );

        /**
         * Advance a GlobalAlias iterator to the next GlobalAlias.
         *
         * Returns NULL if the iterator was already at the end and there are no more
         * global aliases.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetNextGlobalAlias( LLVMValueRef GA );

        /**
         * Decrement a GlobalAlias iterator to the previous GlobalAlias.
         *
         * Returns NULL if the iterator was already at the beginning and there are
         * no previous global aliases.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetPreviousGlobalAlias( LLVMValueRef GA );

        /**
         * Retrieve the target value of an alias.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMAliasGetAliasee( LLVMValueRef Alias );

        /**
         * Set the target value of an alias.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAliasSetAliasee( LLVMValueRef Alias, LLVMValueRef Aliasee );

        /**
         * Remove a function from its containing module and deletes it.
         *
         * @see llvm::Function::eraseFromParent()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMDeleteFunction( LLVMValueRef Fn );

        /**
         * Check whether the given function has a personality function.
         *
         * @see llvm::Function::hasPersonalityFn()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMHasPersonalityFn( LLVMValueRef Fn );

        /**
         * Obtain the personality function attached to the function.
         *
         * @see llvm::Function::getPersonalityFn()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetPersonalityFn( LLVMValueRef Fn );

        /**
         * Set the personality function attached to the function.
         *
         * @see llvm::Function::setPersonalityFn()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetPersonalityFn( LLVMValueRef Fn, LLVMValueRef PersonalityFn );

        /**
         * Obtain the ID number from a function instance.
         *
         * @see llvm::Function::getIntrinsicID()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetIntrinsicID( LLVMValueRef Fn );

        /**
         * Create or insert the declaration of an intrinsic.  For overloaded intrinsics,
         * parameter types must be provided to uniquely identify an overload.
         *
         * @see llvm::Intrinsic::getDeclaration()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetIntrinsicDeclaration( LLVMModuleRef Mod, uint ID, [MarshalAs( UnmanagedType.LPArray, ArraySubType = UnmanagedType.SysInt )]LLVMTypeRef[] ParamTypes, size_t ParamCount );

        /**
         * Retrieves the type of an intrinsic.  For overloaded intrinsics, parameter
         * types must be provided to uniquely identify an overload.
         *
         * @see llvm::Intrinsic::getType()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMIntrinsicGetType( LLVMContextRef Ctx, uint ID, [MarshalAs( UnmanagedType.LPArray, ArraySubType = UnmanagedType.SysInt )]LLVMTypeRef[] ParamTypes, size_t ParamCount );

        /**
         * Retrieves the name of an intrinsic.
         *
         * @see llvm::Intrinsic::getName()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMIntrinsicGetName( uint ID, out size_t NameLength );

        /**
         * Copies the name of an overloaded intrinsic identified by a given list of
         * parameter types.
         *
         * Unlike LLVMIntrinsicGetName, the caller is responsible for freeing the
         * returned string.
         *
         * @see llvm::Intrinsic::getName()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMIntrinsicCopyOverloadedName( uint ID, [MarshalAs( UnmanagedType.LPArray, ArraySubType = UnmanagedType.SysInt )]LLVMTypeRef[] ParamTypes, size_t ParamCount, out size_t NameLength );

        /**
         * Obtain if the intrinsic identified by the given ID is overloaded.
         *
         * @see llvm::Intrinsic::isOverloaded()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIntrinsicIsOverloaded( uint ID );

        /**
         * Obtain the calling function of a function.
         *
         * The returned value corresponds to the LLVMCallConv enumeration.
         *
         * @see llvm::Function::getCallingConv()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetFunctionCallConv( LLVMValueRef Fn );

        /**
         * Set the calling convention of a function.
         *
         * @see llvm::Function::setCallingConv()
         *
         * @param Fn Function to operate on
         * @param CC LLVMCallConv to set calling convention to
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetFunctionCallConv( LLVMValueRef Fn, uint CC );

        /**
         * Obtain the name of the garbage collector to use during code
         * generation.
         *
         * @see llvm::Function::getGC()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetGC( LLVMValueRef Fn );

        /**
         * Define the garbage collector to use during code generation.
         *
         * @see llvm::Function::setGC()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetGC( LLVMValueRef Fn, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Add an attribute to a function.
         *
         * @see llvm::Function::addAttribute()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddAttributeAtIndex( LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetAttributeCountAtIndex( LLVMValueRef F, LLVMAttributeIndex Idx );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetAttributesAtIndex( LLVMValueRef F, LLVMAttributeIndex Idx, out LLVMAttributeRef Attrs );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAttributeRef LLVMGetEnumAttributeAtIndex( LLVMValueRef F, LLVMAttributeIndex Idx, uint KindID );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAttributeRef LLVMGetStringAttributeAtIndex( LLVMValueRef F, LLVMAttributeIndex Idx, [MarshalAs( UnmanagedType.LPStr )]string K, uint KLen );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMRemoveEnumAttributeAtIndex( LLVMValueRef F, LLVMAttributeIndex Idx, uint KindID );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMRemoveStringAttributeAtIndex( LLVMValueRef F, LLVMAttributeIndex Idx, [MarshalAs( UnmanagedType.LPStr )]string K, uint KLen );

        /**
         * Add a target-dependent attribute to a function
         * @see llvm::AttrBuilder::addAttribute()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddTargetDependentFunctionAttr( LLVMValueRef Fn, [MarshalAs( UnmanagedType.LPStr )]string A, [MarshalAs( UnmanagedType.LPStr )]string V );

        /**
         * Obtain the number of parameters in a function.
         *
         * @see llvm::Function::arg_size()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMCountParams( LLVMValueRef Fn );

        /**
         * Obtain the parameters in a function.
         *
         * The takes a pointer to a pre-allocated array of LLVMValueRef that is
         * at least LLVMCountParams() long. This array will be filled with
         * LLVMValueRef instances which correspond to the parameters the
         * function receives. Each LLVMValueRef corresponds to a llvm::Argument
         * instance.
         *
         * @see llvm::Function::arg_begin()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetParams( LLVMValueRef Fn, out LLVMValueRef Params );

        /**
         * Obtain the parameter at the specified index.
         *
         * Parameters are indexed from 0.
         *
         * @see llvm::Function::arg_begin()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetParam( LLVMValueRef Fn, uint Index );

        /**
         * Obtain the function to which this argument belongs.
         *
         * Unlike other functions in this group, this one takes an LLVMValueRef
         * that corresponds to a llvm::Attribute.
         *
         * The returned LLVMValueRef is the llvm::Function to which this
         * argument belongs.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetParamParent( LLVMValueRef Inst );

        /**
         * Obtain the first parameter to a function.
         *
         * @see llvm::Function::arg_begin()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetFirstParam( LLVMValueRef Fn );

        /**
         * Obtain the last parameter to a function.
         *
         * @see llvm::Function::arg_end()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetLastParam( LLVMValueRef Fn );

        /**
         * Obtain the next parameter to a function.
         *
         * This takes an LLVMValueRef obtained from LLVMGetFirstParam() (which is
         * actually a wrapped iterator) and obtains the next parameter from the
         * underlying iterator.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetNextParam( LLVMValueRef Arg );

        /**
         * Obtain the previous parameter to a function.
         *
         * This is the opposite of LLVMGetNextParam().
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetPreviousParam( LLVMValueRef Arg );

        /**
         * Set the alignment for a function parameter.
         *
         * @see llvm::Argument::addAttr()
         * @see llvm::AttrBuilder::addAlignmentAttr()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetParamAlignment( LLVMValueRef Arg, uint Align );

        /**
         * Obtain a MDString value from a context.
         *
         * The returned instance corresponds to the llvm::MDString class.
         *
         * The instance is specified by string data of a specified length. The
         * string content is copied, so the backing memory can be freed after
         * this function returns.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMMDStringInContext( LLVMContextRef C, [MarshalAs( UnmanagedType.LPStr )]string Str, uint SLen );

        /**
         * Obtain a MDString value from the global context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMMDString( [MarshalAs( UnmanagedType.LPStr )]string Str, uint SLen );

        /**
         * Obtain a MDNode value from a context.
         *
         * The returned value corresponds to the llvm::MDNode class.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMMDNodeInContext( LLVMContextRef C, out LLVMValueRef Vals, uint Count );

        /**
         * Obtain a MDNode value from the global context.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMMDNode( out LLVMValueRef Vals, uint Count );

        /**
         * Obtain a Metadata as a Value.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMMetadataAsValue( LLVMContextRef C, LLVMMetadataRef MD );

        /**
         * Obtain a Value as a Metadata.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMMetadataRef LLVMValueAsMetadata( LLVMValueRef Val );

        /**
         * Obtain the underlying string from a MDString value.
         *
         * @param V Instance to obtain string from.
         * @param Length Memory address which will hold length of returned string.
         * @return String data in MDString.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetMDString( LLVMValueRef V, out uint Length );

        /**
         * Obtain the number of operands from an MDNode value.
         *
         * @param V MDNode to get number of operands from.
         * @return Number of operands of the MDNode.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetMDNodeNumOperands( LLVMValueRef V );

        /**
         * Obtain the given MDNode's operands.
         *
         * The passed LLVMValueRef pointer should point to enough memory to hold all of
         * the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as
         * LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the
         * MDNode's operands.
         *
         * @param V MDNode to get the operands from.
         * @param Dest Destination array for operands.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetMDNodeOperands( LLVMValueRef V, out LLVMValueRef Dest );

        /**
         * Convert a basic block instance to a value type.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBasicBlockAsValue( LLVMBasicBlockRef BB );

        /**
         * Determine whether an LLVMValueRef is itself a basic block.
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMValueIsBasicBlock( LLVMValueRef Val );

        /**
         * Convert an LLVMValueRef to an LLVMBasicBlockRef instance.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMValueAsBasicBlock( LLVMValueRef Val );

        /**
         * Obtain the string name of a basic block.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        [return: MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( AliasStringMarshaler ) )]
        public static extern string LLVMGetBasicBlockName( LLVMBasicBlockRef BB );

        /**
         * Obtain the function to which a basic block belongs.
         *
         * @see llvm::BasicBlock::getParent()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetBasicBlockParent( LLVMBasicBlockRef BB );

        /**
         * Obtain the terminator instruction for a basic block.
         *
         * If the basic block does not have a terminator (it is not well-formed
         * if it doesn't), then NULL is returned.
         *
         * The returned LLVMValueRef corresponds to an llvm::Instruction.
         *
         * @see llvm::BasicBlock::getTerminator()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetBasicBlockTerminator( LLVMBasicBlockRef BB );

        /**
         * Obtain the number of basic blocks in a function.
         *
         * @param Fn Function value to operate on.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMCountBasicBlocks( LLVMValueRef Fn );

        /**
         * Obtain all of the basic blocks in a function.
         *
         * This operates on a function value. The BasicBlocks parameter is a
         * pointer to a pre-allocated array of LLVMBasicBlockRef of at least
         * LLVMCountBasicBlocks() in length. This array is populated with
         * LLVMBasicBlockRef instances.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetBasicBlocks( LLVMValueRef Fn, out LLVMBasicBlockRef BasicBlocks );

        /**
         * Obtain the first basic block in a function.
         *
         * The returned basic block can be used as an iterator. You will likely
         * eventually call into LLVMGetNextBasicBlock() with it.
         *
         * @see llvm::Function::begin()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetFirstBasicBlock( LLVMValueRef Fn );

        /**
         * Obtain the last basic block in a function.
         *
         * @see llvm::Function::end()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetLastBasicBlock( LLVMValueRef Fn );

        /**
         * Advance a basic block iterator.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetNextBasicBlock( LLVMBasicBlockRef BB );

        /**
         * Go backwards in a basic block iterator.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetPreviousBasicBlock( LLVMBasicBlockRef BB );

        /**
         * Obtain the basic block that corresponds to the entry point of a
         * function.
         *
         * @see llvm::Function::getEntryBlock()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetEntryBasicBlock( LLVMValueRef Fn );

        /**
         * Create a new basic block without inserting it into a function.
         *
         * @see llvm::BasicBlock::Create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMCreateBasicBlockInContext( LLVMContextRef C, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Append a basic block to the end of a function.
         *
         * @see llvm::BasicBlock::Create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMAppendBasicBlockInContext( LLVMContextRef C, LLVMValueRef Fn, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Append a basic block to the end of a function using the global
         * context.
         *
         * @see llvm::BasicBlock::Create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMAppendBasicBlock( LLVMValueRef Fn, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Insert a basic block in a function before another basic block.
         *
         * The function to add to is determined by the function of the
         * passed basic block.
         *
         * @see llvm::BasicBlock::Create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMInsertBasicBlockInContext( LLVMContextRef C, LLVMBasicBlockRef BB, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Insert a basic block in a function using the global context.
         *
         * @see llvm::BasicBlock::Create()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMInsertBasicBlock( LLVMBasicBlockRef InsertBeforeBB, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Remove a basic block from a function and delete it.
         *
         * This deletes the basic block from its containing function and deletes
         * the basic block itself.
         *
         * @see llvm::BasicBlock::eraseFromParent()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMDeleteBasicBlock( LLVMBasicBlockRef BB );

        /**
         * Remove a basic block from a function.
         *
         * This deletes the basic block from its containing function but keep
         * the basic block alive.
         *
         * @see llvm::BasicBlock::removeFromParent()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMRemoveBasicBlockFromParent( LLVMBasicBlockRef BB );

        /**
         * Move a basic block to before another one.
         *
         * @see llvm::BasicBlock::moveBefore()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMMoveBasicBlockBefore( LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos );

        /**
         * Move a basic block to after another one.
         *
         * @see llvm::BasicBlock::moveAfter()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMMoveBasicBlockAfter( LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos );

        /**
         * Obtain the first instruction in a basic block.
         *
         * The returned LLVMValueRef corresponds to a llvm::Instruction
         * instance.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetFirstInstruction( LLVMBasicBlockRef BB );

        /**
         * Obtain the last instruction in a basic block.
         *
         * The returned LLVMValueRef corresponds to an LLVM:Instruction.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetLastInstruction( LLVMBasicBlockRef BB );

        /**
         * Determine whether an instruction has any metadata attached.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern int LLVMHasMetadata( LLVMValueRef Val );

        /**
         * Return metadata associated with an instruction value.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetMetadata( LLVMValueRef Val, uint KindID );

        /**
         * Set metadata associated with an instruction value.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetMetadata( LLVMValueRef Val, uint KindID, LLVMValueRef Node );

        /**
         * Returns the metadata associated with an instruction value, but filters out
         * all the debug locations.
         *
         * @see llvm::Instruction::getAllMetadataOtherThanDebugLoc()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueMetadataEntry LLVMInstructionGetAllMetadataOtherThanDebugLoc( LLVMValueRef Instr, out size_t NumEntries );

        /**
         * Obtain the basic block to which an instruction belongs.
         *
         * @see llvm::Instruction::getParent()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetInstructionParent( LLVMValueRef Inst );

        /**
         * Obtain the instruction that occurs after the one specified.
         *
         * The next instruction will be from the same basic block.
         *
         * If this is the last instruction in a basic block, NULL will be
         * returned.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetNextInstruction( LLVMValueRef Inst );

        /**
         * Obtain the instruction that occurred before this one.
         *
         * If the instruction is the first instruction in a basic block, NULL
         * will be returned.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetPreviousInstruction( LLVMValueRef Inst );

        /**
         * Remove and delete an instruction.
         *
         * The instruction specified is removed from its containing building
         * block but is kept alive.
         *
         * @see llvm::Instruction::removeFromParent()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMInstructionRemoveFromParent( LLVMValueRef Inst );

        /**
         * Remove and delete an instruction.
         *
         * The instruction specified is removed from its containing building
         * block and then deleted.
         *
         * @see llvm::Instruction::eraseFromParent()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMInstructionEraseFromParent( LLVMValueRef Inst );

        /**
         * Obtain the code opcode for an individual instruction.
         *
         * @see llvm::Instruction::getOpCode()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMOpcode LLVMGetInstructionOpcode( LLVMValueRef Inst );

        /**
         * Obtain the predicate of an instruction.
         *
         * This is only valid for instructions that correspond to llvm::ICmpInst
         * or llvm::ConstantExpr whose opcode is llvm::Instruction::ICmp.
         *
         * @see llvm::ICmpInst::getPredicate()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMIntPredicate LLVMGetICmpPredicate( LLVMValueRef Inst );

        /**
         * Obtain the float predicate of an instruction.
         *
         * This is only valid for instructions that correspond to llvm::FCmpInst
         * or llvm::ConstantExpr whose opcode is llvm::Instruction::FCmp.
         *
         * @see llvm::FCmpInst::getPredicate()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMRealPredicate LLVMGetFCmpPredicate( LLVMValueRef Inst );

        /**
         * Create a copy of 'this' instruction that is identical in all ways
         * except the following:
         *   * The instruction has no parent
         *   * The instruction has no name
         *
         * @see llvm::Instruction::clone()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMInstructionClone( LLVMValueRef Inst );

        /**
         * Determine whether an instruction is a terminator. This routine is named to
         * be compatible with historical functions that did this by querying the
         * underlying C++ type.
         *
         * @see llvm::Instruction::isTerminator()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMIsATerminatorInst( LLVMValueRef Inst );

        /**
         * Obtain the argument count for a call instruction.
         *
         * This expects an LLVMValueRef that corresponds to a llvm::CallInst,
         * llvm::InvokeInst, or llvm:FuncletPadInst.
         *
         * @see llvm::CallInst::getNumArgOperands()
         * @see llvm::InvokeInst::getNumArgOperands()
         * @see llvm::FuncletPadInst::getNumArgOperands()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetNumArgOperands( LLVMValueRef Instr );

        /**
         * Set the calling convention for a call instruction.
         *
         * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
         * llvm::InvokeInst.
         *
         * @see llvm::CallInst::setCallingConv()
         * @see llvm::InvokeInst::setCallingConv()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetInstructionCallConv( LLVMValueRef Instr, uint CC );

        /**
         * Obtain the calling convention for a call instruction.
         *
         * This is the opposite of LLVMSetInstructionCallConv(). Reads its
         * usage.
         *
         * @see LLVMSetInstructionCallConv()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetInstructionCallConv( LLVMValueRef Instr );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetInstrParamAlignment( LLVMValueRef Instr, uint index, uint Align );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddCallSiteAttribute( LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetCallSiteAttributeCount( LLVMValueRef C, LLVMAttributeIndex Idx );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetCallSiteAttributes( LLVMValueRef C, LLVMAttributeIndex Idx, out LLVMAttributeRef Attrs );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAttributeRef LLVMGetCallSiteEnumAttribute( LLVMValueRef C, LLVMAttributeIndex Idx, uint KindID );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAttributeRef LLVMGetCallSiteStringAttribute( LLVMValueRef C, LLVMAttributeIndex Idx, [MarshalAs( UnmanagedType.LPStr )]string K, uint KLen );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMRemoveCallSiteEnumAttribute( LLVMValueRef C, LLVMAttributeIndex Idx, uint KindID );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMRemoveCallSiteStringAttribute( LLVMValueRef C, LLVMAttributeIndex Idx, [MarshalAs( UnmanagedType.LPStr )]string K, uint KLen );

        /**
         * Obtain the function type called by this instruction.
         *
         * @see llvm::CallBase::getFunctionType()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMGetCalledFunctionType( LLVMValueRef C );

        /**
         * Obtain the pointer to the function invoked by this instruction.
         *
         * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
         * llvm::InvokeInst.
         *
         * @see llvm::CallInst::getCalledValue()
         * @see llvm::InvokeInst::getCalledValue()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetCalledValue( LLVMValueRef Instr );

        /**
         * Obtain whether a call instruction is a tail call.
         *
         * This only works on llvm::CallInst instructions.
         *
         * @see llvm::CallInst::isTailCall()
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsTailCall( LLVMValueRef CallInst );

        /**
         * Set whether a call instruction is a tail call.
         *
         * This only works on llvm::CallInst instructions.
         *
         * @see llvm::CallInst::setTailCall()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetTailCall( LLVMValueRef CallInst, [MarshalAs( UnmanagedType.Bool )]bool IsTailCall );

        /**
         * Return the normal destination basic block.
         *
         * This only works on llvm::InvokeInst instructions.
         *
         * @see llvm::InvokeInst::getNormalDest()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetNormalDest( LLVMValueRef InvokeInst );

        /**
         * Return the unwind destination basic block.
         *
         * Works on llvm::InvokeInst, llvm::CleanupReturnInst, and
         * llvm::CatchSwitchInst instructions.
         *
         * @see llvm::InvokeInst::getUnwindDest()
         * @see llvm::CleanupReturnInst::getUnwindDest()
         * @see llvm::CatchSwitchInst::getUnwindDest()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetUnwindDest( LLVMValueRef InvokeInst );

        /**
         * Set the normal destination basic block.
         *
         * This only works on llvm::InvokeInst instructions.
         *
         * @see llvm::InvokeInst::setNormalDest()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetNormalDest( LLVMValueRef InvokeInst, LLVMBasicBlockRef B );

        /**
         * Set the unwind destination basic block.
         *
         * Works on llvm::InvokeInst, llvm::CleanupReturnInst, and
         * llvm::CatchSwitchInst instructions.
         *
         * @see llvm::InvokeInst::setUnwindDest()
         * @see llvm::CleanupReturnInst::setUnwindDest()
         * @see llvm::CatchSwitchInst::setUnwindDest()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetUnwindDest( LLVMValueRef InvokeInst, LLVMBasicBlockRef B );

        /**
         * Return the number of successors that this terminator has.
         *
         * @see llvm::Instruction::getNumSuccessors
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetNumSuccessors( LLVMValueRef Term );

        /**
         * Return the specified successor.
         *
         * @see llvm::Instruction::getSuccessor
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetSuccessor( LLVMValueRef Term, uint i );

        /**
         * Update the specified successor to point at the provided block.
         *
         * @see llvm::Instruction::setSuccessor
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetSuccessor( LLVMValueRef Term, uint i, LLVMBasicBlockRef block );

        /**
         * Return if a branch is conditional.
         *
         * This only works on llvm::BranchInst instructions.
         *
         * @see llvm::BranchInst::isConditional
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsConditional( LLVMValueRef Branch );

        /**
         * Return the condition of a branch instruction.
         *
         * This only works on llvm::BranchInst instructions.
         *
         * @see llvm::BranchInst::getCondition
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetCondition( LLVMValueRef Branch );

        /**
         * Set the condition of a branch instruction.
         *
         * This only works on llvm::BranchInst instructions.
         *
         * @see llvm::BranchInst::setCondition
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetCondition( LLVMValueRef Branch, LLVMValueRef Cond );

        /**
         * Obtain the default destination basic block of a switch instruction.
         *
         * This only works on llvm::SwitchInst instructions.
         *
         * @see llvm::SwitchInst::getDefaultDest()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetSwitchDefaultDest( LLVMValueRef SwitchInstr );

        /**
         * Obtain the type that is being allocated by the alloca instruction.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMTypeRef LLVMGetAllocatedType( LLVMValueRef Alloca );

        /**
         * Check whether the given GEP instruction is inbounds.
         */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsInBounds( LLVMValueRef GEP );

        /**
         * Set the given GEP instruction to be inbounds or not.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetIsInBounds( LLVMValueRef GEP, [MarshalAs( UnmanagedType.Bool )]bool InBounds );

        /**
         * Add an incoming value to the end of a PHI list.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddIncoming( LLVMValueRef PhiNode, [MarshalAs( UnmanagedType.LPArray, ArraySubType = UnmanagedType.SysInt )]LLVMValueRef[] IncomingValues, [MarshalAs( UnmanagedType.LPArray, ArraySubType = UnmanagedType.SysInt )]LLVMBasicBlockRef[] IncomingBlocks, uint Count );

        /**
         * Obtain the number of incoming basic blocks to a PHI node.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMCountIncoming( LLVMValueRef PhiNode );

        /**
         * Obtain an incoming value to a PHI node as an LLVMValueRef.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetIncomingValue( LLVMValueRef PhiNode, uint Index );

        /**
         * Obtain an incoming value to a PHI node as an LLVMBasicBlockRef.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetIncomingBlock( LLVMValueRef PhiNode, uint Index );

        /**
         * Obtain the number of indices.
         * NB: This also works on GEP.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetNumIndices( LLVMValueRef Inst );

        /**
         * Obtain the indices as an array.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        unsafe public static extern uint* LLVMGetIndices( LLVMValueRef Inst );

        /**
         * @defgroup LLVMCCoreInstructionBuilder Instruction Builders
         *
         * An instruction builder represents a point within a basic block and is
         * the exclusive means of building instructions using the C interface.
         *
         * @{
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBuilderRef LLVMCreateBuilderInContext( LLVMContextRef C );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBuilderRef LLVMCreateBuilder(  );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMPositionBuilder( LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMPositionBuilderBefore( LLVMBuilderRef Builder, LLVMValueRef Instr );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMPositionBuilderAtEnd( LLVMBuilderRef Builder, LLVMBasicBlockRef Block );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMBasicBlockRef LLVMGetInsertBlock( LLVMBuilderRef Builder );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMClearInsertionPosition( LLVMBuilderRef Builder );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMInsertIntoBuilder( LLVMBuilderRef Builder, LLVMValueRef Instr );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMInsertIntoBuilderWithName( LLVMBuilderRef Builder, LLVMValueRef Instr, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetCurrentDebugLocation( LLVMBuilderRef Builder, LLVMValueRef L );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetCurrentDebugLocation( LLVMBuilderRef Builder );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetInstDebugLocation( LLVMBuilderRef Builder, LLVMValueRef Inst );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildRetVoid( LLVMBuilderRef _0 );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildRet( LLVMBuilderRef _0, LLVMValueRef V );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildAggregateRet( LLVMBuilderRef _0, out LLVMValueRef RetVals, uint N );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildBr( LLVMBuilderRef _0, LLVMBasicBlockRef Dest );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildCondBr( LLVMBuilderRef _0, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildSwitch( LLVMBuilderRef _0, LLVMValueRef V, LLVMBasicBlockRef Else, uint NumCases );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildIndirectBr( LLVMBuilderRef B, LLVMValueRef Addr, uint NumDests );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildInvoke2( LLVMBuilderRef _0, LLVMTypeRef Ty, LLVMValueRef Fn, out LLVMValueRef Args, uint NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildUnreachable( LLVMBuilderRef _0 );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildResume( LLVMBuilderRef B, LLVMValueRef Exn );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildLandingPad( LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, uint NumClauses, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildCleanupRet( LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildCatchRet( LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildCatchPad( LLVMBuilderRef B, LLVMValueRef ParentPad, out LLVMValueRef Args, uint NumArgs, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildCleanupPad( LLVMBuilderRef B, LLVMValueRef ParentPad, out LLVMValueRef Args, uint NumArgs, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildCatchSwitch( LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, uint NumHandlers, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddCase( LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddDestination( LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetNumClauses( LLVMValueRef LandingPad );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetClause( LLVMValueRef LandingPad, uint Idx );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddClause( LLVMValueRef LandingPad, LLVMValueRef ClauseVal );

        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsCleanup( LLVMValueRef LandingPad );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetCleanup( LLVMValueRef LandingPad, [MarshalAs( UnmanagedType.Bool )]bool Val );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMAddHandler( LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern uint LLVMGetNumHandlers( LLVMValueRef CatchSwitch );

        /**
         * Obtain the basic blocks acting as handlers for a catchswitch instruction.
         *
         * The Handlers parameter should point to a pre-allocated array of
         * LLVMBasicBlockRefs at least LLVMGetNumHandlers() large. On return, the
         * first LLVMGetNumHandlers() entries in the array will be populated
         * with LLVMBasicBlockRef instances.
         *
         * @param CatchSwitch The catchswitch instruction to operate on.
         * @param Handlers Memory address of an array to be filled with basic blocks.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMGetHandlers( LLVMValueRef CatchSwitch, out LLVMBasicBlockRef Handlers );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetArgOperand( LLVMValueRef Funclet, uint i );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetArgOperand( LLVMValueRef Funclet, uint i, LLVMValueRef value );

        /**
         * Get the parent catchswitch instruction of a catchpad instruction.
         *
         * This only works on llvm::CatchPadInst instructions.
         *
         * @see llvm::CatchPadInst::getCatchSwitch()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMGetParentCatchSwitch( LLVMValueRef CatchPad );

        /**
         * Set the parent catchswitch instruction of a catchpad instruction.
         *
         * This only works on llvm::CatchPadInst instructions.
         *
         * @see llvm::CatchPadInst::setCatchSwitch()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetParentCatchSwitch( LLVMValueRef CatchPad, LLVMValueRef CatchSwitch );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildAdd( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNSWAdd( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNUWAdd( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFAdd( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildSub( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNSWSub( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNUWSub( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFSub( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildMul( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNSWMul( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNUWMul( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFMul( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildUDiv( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildExactUDiv( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildSDiv( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildExactSDiv( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFDiv( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildURem( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildSRem( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFRem( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildShl( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildLShr( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildAShr( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildAnd( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildOr( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildXor( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildBinOp( LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNeg( LLVMBuilderRef _0, LLVMValueRef V, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNSWNeg( LLVMBuilderRef B, LLVMValueRef V, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNUWNeg( LLVMBuilderRef B, LLVMValueRef V, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFNeg( LLVMBuilderRef _0, LLVMValueRef V, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildNot( LLVMBuilderRef _0, LLVMValueRef V, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildMalloc( LLVMBuilderRef _0, LLVMTypeRef Ty, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildArrayMalloc( LLVMBuilderRef _0, LLVMTypeRef Ty, LLVMValueRef Val, [MarshalAs( UnmanagedType.LPStr )]string Name );

        /**
         * Creates and inserts a memset to the specified pointer and the 
         * specified value.
         *
         * @see llvm::IRRBuilder::CreateMemSet()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildMemSet( LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, uint Align );

        /**
         * Creates and inserts a memcpy between the specified pointers.
         *
         * @see llvm::IRRBuilder::CreateMemCpy()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildMemCpy( LLVMBuilderRef B, LLVMValueRef Dst, uint DstAlign, LLVMValueRef Src, uint SrcAlign, LLVMValueRef Size );

        /**
         * Creates and inserts a memmove between the specified pointers.
         *
         * @see llvm::IRRBuilder::CreateMemMove()
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildMemMove( LLVMBuilderRef B, LLVMValueRef Dst, uint DstAlign, LLVMValueRef Src, uint SrcAlign, LLVMValueRef Size );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildAlloca( LLVMBuilderRef _0, LLVMTypeRef Ty, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildArrayAlloca( LLVMBuilderRef _0, LLVMTypeRef Ty, LLVMValueRef Val, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFree( LLVMBuilderRef _0, LLVMValueRef PointerVal );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildLoad2( LLVMBuilderRef _0, LLVMTypeRef Ty, LLVMValueRef PointerVal, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildStore( LLVMBuilderRef _0, LLVMValueRef Val, LLVMValueRef Ptr );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildGEP2( LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, out LLVMValueRef Indices, uint NumIndices, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildInBoundsGEP2( LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, out LLVMValueRef Indices, uint NumIndices, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildStructGEP2( LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, uint Idx, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildGlobalString( LLVMBuilderRef B, [MarshalAs( UnmanagedType.LPStr )]string Str, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildGlobalStringPtr( LLVMBuilderRef B, [MarshalAs( UnmanagedType.LPStr )]string Str, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMGetVolatile( LLVMValueRef MemoryAccessInst );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetVolatile( LLVMValueRef MemoryAccessInst, [MarshalAs( UnmanagedType.Bool )]bool IsVolatile );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAtomicOrdering LLVMGetOrdering( LLVMValueRef MemoryAccessInst );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetOrdering( LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildTrunc( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildZExt( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildSExt( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFPToUI( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFPToSI( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildUIToFP( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildSIToFP( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFPTrunc( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFPExt( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildPtrToInt( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildIntToPtr( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildBitCast( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildAddrSpaceCast( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildZExtOrBitCast( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildSExtOrBitCast( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildTruncOrBitCast( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildCast( LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildPointerCast( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildIntCast2( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.Bool )]bool IsSigned, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFPCast( LLVMBuilderRef _0, LLVMValueRef Val, LLVMTypeRef DestTy, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildICmp( LLVMBuilderRef _0, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFCmp( LLVMBuilderRef _0, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildPhi( LLVMBuilderRef _0, LLVMTypeRef Ty, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildCall2( LLVMBuilderRef _0, LLVMTypeRef _1, LLVMValueRef Fn, out LLVMValueRef Args, uint NumArgs, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildSelect( LLVMBuilderRef _0, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildVAArg( LLVMBuilderRef _0, LLVMValueRef List, LLVMTypeRef Ty, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildExtractElement( LLVMBuilderRef _0, LLVMValueRef VecVal, LLVMValueRef Index, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildInsertElement( LLVMBuilderRef _0, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildShuffleVector( LLVMBuilderRef _0, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildExtractValue( LLVMBuilderRef _0, LLVMValueRef AggVal, uint Index, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildInsertValue( LLVMBuilderRef _0, LLVMValueRef AggVal, LLVMValueRef EltVal, uint Index, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildIsNull( LLVMBuilderRef _0, LLVMValueRef Val, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildIsNotNull( LLVMBuilderRef _0, LLVMValueRef Val, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildPtrDiff( LLVMBuilderRef _0, LLVMValueRef LHS, LLVMValueRef RHS, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildFence( LLVMBuilderRef B, LLVMAtomicOrdering ordering, [MarshalAs( UnmanagedType.Bool )]bool singleThread, [MarshalAs( UnmanagedType.LPStr )]string Name );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildAtomicRMW( LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, [MarshalAs( UnmanagedType.Bool )]bool singleThread );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMValueRef LLVMBuildAtomicCmpXchg( LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, [MarshalAs( UnmanagedType.Bool )]bool SingleThread );

        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsAtomicSingleThread( LLVMValueRef AtomicInst );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetAtomicSingleThread( LLVMValueRef AtomicInst, [MarshalAs( UnmanagedType.Bool )]bool SingleThread );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering( LLVMValueRef CmpXchgInst );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetCmpXchgSuccessOrdering( LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering( LLVMValueRef CmpXchgInst );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern void LLVMSetCmpXchgFailureOrdering( LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering );

        /**
         * Changes the type of M so it can be passed to FunctionPassManagers and the
         * JIT.  They take ModuleProviders for historical reasons.
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule( LLVMModuleRef M );

        /**
         * @defgroup LLVMCCoreMemoryBuffers Memory Buffers
         *
         * @{
         */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMCreateMemoryBufferWithContentsOfFile( [MarshalAs( UnmanagedType.LPStr )]string Path, out LLVMMemoryBufferRef OutMemBuf, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string OutMessage );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMStatus LLVMCreateMemoryBufferWithSTDIN( out LLVMMemoryBufferRef OutMemBuf, [MarshalAs( UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof( DisposeMessageMarshaler ) )]out string OutMessage );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange( [MarshalAs( UnmanagedType.LPStr )]string InputData, size_t InputDataLength, [MarshalAs( UnmanagedType.LPStr )]string BufferName, [MarshalAs( UnmanagedType.Bool )]bool RequiresNullTerminator );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy( [MarshalAs( UnmanagedType.LPStr )]string InputData, size_t InputDataLength, [MarshalAs( UnmanagedType.LPStr )]string BufferName );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern global::System.IntPtr LLVMGetBufferStart( LLVMMemoryBufferRef MemBuf );

        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern size_t LLVMGetBufferSize( LLVMMemoryBufferRef MemBuf );

        /** Return the global pass registry, for use with initialization functions.
            @see llvm::PassRegistry::getPassRegistry */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMPassRegistryRef LLVMGetGlobalPassRegistry(  );

        /** Constructs a new whole-module pass pipeline. This type of pipeline is
            suitable for link-time optimization and whole-module transformations.
            @see llvm::PassManager::PassManager */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMPassManagerRef LLVMCreatePassManager(  );

        /** Constructs a new function-by-function pass pipeline over the module
            provider. It does not take ownership of the module provider. This type of
            pipeline is suitable for code generation and JIT compilation tasks.
            @see llvm::FunctionPassManager::FunctionPassManager */
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule( LLVMModuleRef M );

        /** Initializes, executes on the provided module, and finalizes all of the
            passes scheduled in the pass manager. Returns 1 if any of the passes
            modified the module, 0 otherwise.
            @see llvm::PassManager::run(Module&) */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMRunPassManager( LLVMPassManagerRef PM, LLVMModuleRef M );

        /** Initializes all of the function passes scheduled in the function pass
            manager. Returns 1 if any of the passes modified the module, 0 otherwise.
            @see llvm::FunctionPassManager::doInitialization */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMInitializeFunctionPassManager( LLVMPassManagerRef FPM );

        /** Executes all of the function passes scheduled in the function pass manager
            on the provided function. Returns 1 if any of the passes modified the
            function, false otherwise.
            @see llvm::FunctionPassManager::run(Function&) */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMRunFunctionPassManager( LLVMPassManagerRef FPM, LLVMValueRef F );

        /** Finalizes all of the function passes scheduled in the function pass
            manager. Returns 1 if any of the passes modified the module, 0 otherwise.
            @see llvm::FunctionPassManager::doFinalization */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMFinalizeFunctionPassManager( LLVMPassManagerRef FPM );

        /** Check whether LLVM is executing in thread-safe mode or not.
            @see llvm::llvm_is_multithreaded */
        [return: MarshalAs( UnmanagedType.Bool )]
        [SuppressUnmanagedCodeSecurity]
        [DllImport( LibraryPath, CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
        public static extern bool LLVMIsMultithreaded(  );

    }
}
