// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 2.17941.31104.49410
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System.CodeDom.Compiler;
using System.Runtime.InteropServices;

namespace Llvm.NET.Interop
{
    /**
     * The type for the operand information call back function.  This is called to
     * get the symbolic information for an operand of an instruction.  Typically
     * this is from the relocation information, symbol table, etc.  That block of
     * information is saved when the disassembler context is created and passed to
     * the call back in the DisInfo parameter.  The instruction containing operand
     * is at the PC parameter.  For some instruction sets, there can be more than
     * one operand with symbolic information.  To determine the symbolic operand
     * information for each operand, the bytes for the specific operand in the
     * instruction are specified by the Offset parameter and its byte widith is the
     * size parameter.  For instructions sets with fixed widths and one symbolic
     * operand per instruction, the Offset parameter will be zero and Size parameter
     * will be the instruction width.  The information is returned in TagBuf and is
     * Triple specific with its specific information defined by the value of
     * TagType for that Triple.  If symbolic information is returned the function
     * returns 1, otherwise it returns 0.
     */
    [UnmanagedFunctionPointer( global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
    public delegate int LLVMOpInfoCallback( global::System.IntPtr DisInfo, ulong PC, ulong Offset, ulong Size, int TagType, global::System.IntPtr TagBuf );

    /**
     * The type for the symbol lookup function.  This may be called by the
     * disassembler for things like adding a comment for a PC plus a constant
     * offset load instruction to use a symbol name instead of a load address value.
     * It is passed the block information is saved when the disassembler context is
     * created and the ReferenceValue to look up as a symbol.  If no symbol is found
     * for the ReferenceValue NULL is returned.  The ReferenceType of the
     * instruction is passed indirectly as is the PC of the instruction in
     * ReferencePC.  If the output reference can be determined its type is returned
     * indirectly in ReferenceType along with ReferenceName if any, or that is set
     * to NULL.
     */
    [UnmanagedFunctionPointer( global::System.Runtime.InteropServices.CallingConvention.Cdecl )]
    public delegate string LLVMSymbolLookupCallback( global::System.IntPtr DisInfo, ulong ReferenceValue, out ulong ReferenceType, ulong ReferencePC, [MarshalAs( UnmanagedType.LPStr, ArraySubType = UnmanagedType.LPStr )]global::System.String[] ReferenceName );

    [StructLayout( LayoutKind.Sequential )]
    public struct LLVMOpInfoSymbol1
    {
        ulong Present;
        [MarshalAs( UnmanagedType.LPStr )]
        string Name;
        ulong Value;
    }

    [StructLayout( LayoutKind.Sequential )]
    public struct LLVMOpInfo1
    {
        global::Llvm.NET.Interop.LLVMOpInfoSymbol1 AddSymbol;
        global::Llvm.NET.Interop.LLVMOpInfoSymbol1 SubtractSymbol;
        ulong Value;
        ulong VariantKind;
    }

    public static partial class NativeMethods
    {
    }
}
