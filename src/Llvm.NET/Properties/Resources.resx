<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Linking_modules_from_different_contexts_is_not_allowed" xml:space="preserve">
    <value>Linking modules from different contexts is not allowed</value>
  </data>
  <data name="Module_link_error" xml:space="preserve">
    <value>Module link error</value>
  </data>
  <data name="Error_writing_bit_code_file_0" xml:space="preserve">
    <value>Error writing bit-code file '{0}'</value>
  </data>
  <data name="Signature_requires_debug_type_information" xml:space="preserve">
    <value>Signature requires debug type information</value>
  </data>
  <data name="Expected_to_get_a_debug_function_that_describes_the_provided_function" xml:space="preserve">
    <value>Expected to get a debug function that describes the provided function</value>
  </data>
  <data name="Intrinsic_0_is_not_overloaded_and_therefore_does_not_require_type_arguments" xml:space="preserve">
    <value>intrinsic {0} is not overloaded and therefore does not require type arguments</value>
  </data>
  <data name="Expected_to_get_a_module_bound_to_the_specified_context" xml:space="preserve">
    <value>Expected to get a module bound to the specified context</value>
  </data>
  <data name="Specified_bit_code_file_does_not_exist" xml:space="preserve">
    <value>Specified bit-code file does not exist</value>
  </data>
  <data name="Could_not_parse_bit_code_from_buffer" xml:space="preserve">
    <value>Could not parse bit code from buffer</value>
  </data>
  <data name="Context_mismatch_cannot_cache_modules_from_multiple_contexts" xml:space="preserve">
    <value>Context mismatch - cannot cache modules from multiple contexts</value>
  </data>
  <data name="Module_was_explicitly_destroyed_or_ownership_transferred_to_native_library" xml:space="preserve">
    <value>Module was explicitly destroyed or ownership transferred to native library</value>
  </data>
  <data name="Cannot_mix_types_from_different_contexts" xml:space="preserve">
    <value>Cannot mix types from different contexts</value>
  </data>
  <data name="Integer_bit_width_must_be_greater_than_0" xml:space="preserve">
    <value>integer bit width must be greater than 0</value>
  </data>
  <data name="Mismatched_context" xml:space="preserve">
    <value>Mismatched context</value>
  </data>
  <data name="Return_type_does_not_have_debug_information" xml:space="preserve">
    <value>Return type does not have debug information</value>
  </data>
  <data name="One_or_more_parameter_types_are_not_valid" xml:space="preserve">
    <value>One or more parameter types are not valid:
</value>
  </data>
  <data name="Argument_0_is_null" xml:space="preserve">
    <value>	Argument {0} is null</value>
  </data>
  <data name="Argument_0_does_not_contain_debug_type_information" xml:space="preserve">
    <value>	Argument {0} does not contain debug type information</value>
  </data>
  <data name="Assert_Should_have_a_valid_non_temp_type_by_now" xml:space="preserve">
    <value>Should have a valid non temp type by now</value>
  </data>
  <data name="structure_must_have_at_least_one_element" xml:space="preserve">
    <value>structure must have at least one element</value>
  </data>
  <data name="Cannot_create_named_constant_struct_with_type_from_another_context" xml:space="preserve">
    <value>Cannot create named constant struct with type from another context</value>
  </data>
  <data name="Number_of_values_provided_must_match_the_number_of_elements_in_the_specified_type" xml:space="preserve">
    <value>Number of values provided must match the number of elements in the specified type</value>
  </data>
  <data name="One_or_more_values_provided_do_not_match_the_corresponding_member_type_" xml:space="preserve">
    <value>One or more values provided do not match the corresponding member type:</value>
  </data>
  <data name="MismatchedType_0_member_type_equals_1_value_type_equals_2" xml:space="preserve">
    <value>	[{0}]: member type={1}; value type={2}</value>
  </data>
  <data name="Integer_type_required" xml:space="preserve">
    <value>Integer type required</value>
  </data>
  <data name="Attribute_0_requires_a_value" xml:space="preserve">
    <value>Attribute {0} requires a value</value>
  </data>
  <data name="Attribute_0_does_not_support_a_value" xml:space="preserve">
    <value>Attribute {0} does not support a value</value>
  </data>
  <data name="Incorrect_context_for_module" xml:space="preserve">
    <value>Incorrect context for module</value>
  </data>
  <data name="Assert_Unexpected_Debug_state" xml:space="preserve">
    <value>Unexpected Debug state</value>
  </data>
  <data name="Type_must_be_sized_to_get_target_size_information" xml:space="preserve">
    <value>Type must be sized to get target size information</value>
  </data>
  <data name="Cannot_change_type_of_an_extended_property_once_set" xml:space="preserve">
    <value> Cannot change type of an extended property once set</value>
  </data>
  <data name="start_plus_length_exceeds_size_of_buffer" xml:space="preserve">
    <value>start + length exceeds size of buffer</value>
  </data>
  <data name="Triple_specified_for_the_module_doesn_t_match_target_machine" xml:space="preserve">
    <value>Triple specified for the module doesn't match target machine</value>
  </data>
  <data name="Unsupported_Architecture" xml:space="preserve">
    <value>Unsupported Architecture</value>
  </data>
  <data name="Value_not_set" xml:space="preserve">
    <value>Value not set</value>
  </data>
  <data name="Value_already_set" xml:space="preserve">
    <value>Value already set</value>
  </data>
  <data name="ElementType_doesn_t_match_array_element_type" xml:space="preserve">
    <value>ElementType doesn't match array element type</value>
  </data>
  <data name="Module_needs_Layout_to_build_basic_types" xml:space="preserve">
    <value>Module needs Layout to build basic types</value>
  </data>
  <data name="Expected_a_primitive_type" xml:space="preserve">
    <value>Expected a primitive type</value>
  </data>
  <data name="LLVM_only_allows_one_DICompileUnit_per_module" xml:space="preserve">
    <value>DICompileUnit already defined, LLVM only allows one DICompileUnit per module.</value>
  </data>
  <data name="Temporaries_must_be_resolved_before_finalizing_debug_information" xml:space="preserve">
    <value>Temporaries must be resolved before finalizing debug information:</value>
  </data>
  <data name="Unresolved_Debug_temporary_0" xml:space="preserve">
    <value>	{0}</value>
  </data>
  <data name="Mismatched_scopes_for_location_and_variable" xml:space="preserve">
    <value>Mismatched scopes for location and variable</value>
  </data>
  <data name="Mismatched_scopes" xml:space="preserve">
    <value>Mismatched scopes</value>
  </data>
  <data name="Location_does_not_describe_the_specified_block_s_containing_function" xml:space="preserve">
    <value>Location does not describe the specified block's containing function</value>
  </data>
  <data name="Cannot_replace_a_temporary_with_another_temporary" xml:space="preserve">
    <value>Cannot replace a temporary with another temporary</value>
  </data>
  <data name="Cannot_replace_non_temporary_DIType_with_a_new_Type" xml:space="preserve">
    <value>Cannot replace non temporary DIType with a new Type</value>
  </data>
  <data name="Type_does_not_have_associated_Debug_type_from_which_to_construct_a_pointer_type" xml:space="preserve">
    <value>Type does not have associated Debug type from which to construct a pointer type</value>
  </data>
  <data name="Type_does_not_have_associated_Debug_type_from_which_to_construct_an_array_type" xml:space="preserve">
    <value>Type does not have associated Debug type from which to construct an array type</value>
  </data>
  <data name="Struct_type_used_as_basis_for_a_union_must_not_have_a_body" xml:space="preserve">
    <value>Struct type used as basis for a union must not have a body</value>
  </data>
  <data name="Cannot_determine_layout_for_element__The_element_must_have_an_explicit_layout_or_the_module_has_a_layout_to_use" xml:space="preserve">
    <value>Cannot determine layout for element; The element must have an explicit layout or the module has a layout to use</value>
  </data>
  <data name="Wrapped_node_is_null" xml:space="preserve">
    <value>Wrapped node is null</value>
  </data>
  <data name="Type_must_be_an_integral_data_type" xml:space="preserve">
    <value>Type must be an integral data type</value>
  </data>
  <data name="Type_must_be_a_floating_point_data_type" xml:space="preserve">
    <value>Type must be a floating point data type</value>
  </data>
  <data name="Invalid_handle_provided" xml:space="preserve">
    <value>Invalid handle provided</value>
  </data>
  <data name="Unknown_handle_value" xml:space="preserve">
    <value>Unknown handle value</value>
  </data>
  <data name="Failed_to_remove_module_from_engine_0" xml:space="preserve">
    <value>Failed to remove module from engine '{0}'</value>
  </data>
  <data name="Invalid_EngineKind" xml:space="preserve">
    <value>Invalid EngineKind</value>
  </data>
  <data name="Unresolved_Symbol_0_1" xml:space="preserve">
    <value>Unresolved Symbol: '{0}'; {1}</value>
  </data>
  <data name="Function_0_not_found" xml:space="preserve">
    <value>Function {0} not found</value>
  </data>
  <data name="Cannot_Replace_all_uses_of_a_null_descriptor" xml:space="preserve">
    <value>Cannot Replace all uses of a null descriptor</value>
  </data>
  <data name="Cannot_replace_non_temporary_or_resolved_MDNode" xml:space="preserve">
    <value>Cannot replace non temporary or resolved MDNode</value>
  </data>
  <data name="Expected_node_with_3_operands" xml:space="preserve">
    <value>Expected node with 3 operands</value>
  </data>
  <data name="Expected_ConstantAsMetadata_for_first_operand" xml:space="preserve">
    <value>Expected ConstantAsMetadata for first operand</value>
  </data>
  <data name="Expected_ConstantInt_wrapped_in_first_operand" xml:space="preserve">
    <value>Expected ConstantInt wrapped in first operand</value>
  </data>
  <data name="Expected_MDString_as_second_operand" xml:space="preserve">
    <value>Expected MDString as second operand</value>
  </data>
  <data name="Condition_value_must_be_an_i1_or_vector_of_i1" xml:space="preserve">
    <value>Condition value must be an i1 or vector of i1</value>
  </data>
  <data name="When_condition_is_a_vector__selected_values_must_be_a_vector_of_the_same_size" xml:space="preserve">
    <value>When condition is a vector, selected values must be a vector of the same size</value>
  </data>
  <data name="Selected_values_must_have_the_same_type" xml:space="preserve">
    <value>Selected values must have the same type</value>
  </data>
  <data name="Source_and_destination_arguments_are_the_same_value" xml:space="preserve">
    <value>Source and destination arguments are the same value</value>
  </data>
  <data name="Pointer_type_expected" xml:space="preserve">
    <value>Pointer type expected</value>
  </data>
  <data name="Integer_type_expected" xml:space="preserve">
    <value>Integer type expected</value>
  </data>
  <data name="Module_and_instruction_builder_must_come_from_the_same_context" xml:space="preserve">
    <value>Module and instruction builder must come from the same context</value>
  </data>
  <data name="Pointer_type_doesn_t_match_the_value_type" xml:space="preserve">
    <value>Pointer type doesn't match the value type</value>
  </data>
  <data name="Pointer_value_expected" xml:space="preserve">
    <value>Pointer value expected</value>
  </data>
  <data name="GEP_index_arguments_must_be_integers" xml:space="preserve">
    <value>GEP index arguments must be integers</value>
  </data>
  <data name="There_must_be_at_least_one_index_argument" xml:space="preserve">
    <value>There must be at least one index argument</value>
  </data>
  <data name="Cannot_insert_when_no_block_module_is_available" xml:space="preserve">
    <value>Cannot insert when no block/module is available</value>
  </data>
  <data name="Types_of_binary_operators_must_be_identical" xml:space="preserve">
    <value>Types of binary operators must be identical</value>
  </data>
  <data name="Expected_pointer_type" xml:space="preserve">
    <value>Expected pointer type</value>
  </data>
  <data name="Expected_pointer_to_function" xml:space="preserve">
    <value>Expected pointer to function</value>
  </data>
  <data name="A_pointer_to_a_function_is_required_for_an_indirect_call" xml:space="preserve">
    <value>A pointer to a function is required for an indirect call</value>
  </data>
  <data name="Mismatched_parameter_count_with_call_site" xml:space="preserve">
    <value>Mismatched parameter count with call site</value>
  </data>
  <data name="Call_site_argument_type_mismatch_for_function_0_at_index_1_argType_equals_2_signatureType_equals_3" xml:space="preserve">
    <value>Call site argument type mismatch for function {0} at index {1}; argType={2}; signatureType={3}</value>
  </data>
  <data name="Pointer_to_a_structure_expected" xml:space="preserve">
    <value>Pointer to a structure expected</value>
  </data>
  <data name="Cannot_get_element_of_unsized_opaque_structures" xml:space="preserve">
    <value>Cannot get element of unsized/opaque structures</value>
  </data>
  <data name="Index_exceeds_number_of_members_in_the_type" xml:space="preserve">
    <value>Index exceeds number of members in the type</value>
  </data>
  <data name="Expected_a_pointer_value" xml:space="preserve">
    <value>Expected a pointer value</value>
  </data>
  <data name="Expected_pointer_to_integral_type" xml:space="preserve">
    <value>Expected pointer to integral type</value>
  </data>
  <data name="Expecting_an_integer_or_pointer_type" xml:space="preserve">
    <value>Expecting an integer or pointer type</value>
  </data>
  <data name="Expecting_an_integer_type" xml:space="preserve">
    <value>Expecting an integer type</value>
  </data>
  <data name="0_is_not_a_valid_value_for_a_compare_predicate" xml:space="preserve">
    <value>'{0}' is not a valid value for a compare predicate</value>
  </data>
  <data name="Incompatible_types_destination_pointer_must_be_same_type_0_1" xml:space="preserve">
    <value>Incompatible types: destination pointer must be of the same type as the value stored.
Types are:
    Destination: {0}
    Value: {1}</value>
  </data>
  <data name="0_is_not_a_valid_option" xml:space="preserve">
    <value>'{0}' is not a valid option</value>
  </data>
  <data name="Marshaling_of_Generic_delegate_types_to_a_native_callbacks_is_not_supported" xml:space="preserve">
    <value>Marshaling of Generic delegate types to a native callbacks is not supported</value>
  </data>
  <data name="Marshalling_a_delegate_to_a_native_callback_requires_an_UnmanagedFunctionPointerAttribute_for_the_delegate_type" xml:space="preserve">
    <value>Marshalling a delegate to a native callback requires an UnmanagedFunctionPointerAttribute for the delegate type</value>
  </data>
  <data name="Name_cannot_be_null_or_empty" xml:space="preserve">
    <value>Name cannot be null or empty</value>
  </data>
  <data name="Return_instruction_for_void_function_must_not_have_a_value" xml:space="preserve">
    <value>Return instruction for void function must not have a value</value>
  </data>
  <data name="Value_for_return_must_match_the_function_signature_s_return_type" xml:space="preserve">
    <value>Value for return must match the function signature's return type</value>
  </data>
  <data name="Expected_pointer_value" xml:space="preserve">
    <value>Expected pointer value</value>
  </data>
  <data name="Array_type_reference_expected" xml:space="preserve">
    <value>Array type reference expected</value>
  </data>
  <data name="Pointer_type_reference_expected" xml:space="preserve">
    <value>Pointer type reference expected</value>
  </data>
  <data name="Expected_a_sequence_type" xml:space="preserve">
    <value>Expected a sequence type</value>
  </data>
  <data name="Vector_type_reference_expected" xml:space="preserve">
    <value>Vector type reference expected</value>
  </data>
  <data name="Specified_parameter_index_exceeds_the_number_of_parameters_in_the_function" xml:space="preserve">
    <value>Specified parameter index exceeds the number of parameters in the function</value>
  </data>
  <data name="Index_for_parameters_must_be_the_actual_position_of_the_argument" xml:space="preserve">
    <value>Index for parameters must be the actual position of the argument</value>
  </data>
  <data name="Attribute_not_allowed_on_functions" xml:space="preserve">
    <value>Attribute not allowed on functions</value>
  </data>
  <data name="Attribute_not_allowed_on_function_Return" xml:space="preserve">
    <value>Attribute not allowed on function Return</value>
  </data>
  <data name="Attribute_not_allowed_on_function_parameter" xml:space="preserve">
    <value>Attribute not allowed on function parameter</value>
  </data>
  <data name="Expected_a_32_bit_value_for_alignment" xml:space="preserve">
    <value>Expected a 32 bit value for alignment</value>
  </data>
  <data name="Expected_a_32_bit_value_for_stack_alignment" xml:space="preserve">
    <value>Expected a 32 bit value for stack alignment</value>
  </data>
  <data name="Stack_alignment_value_must_be_a_power_of_2" xml:space="preserve">
    <value>Stack alignment value must be a power of 2</value>
  </data>
  <data name="Attribute_0_does_not_support_an_argument" xml:space="preserve">
    <value>Attribute '{0}' does not support an argument</value>
  </data>
  <data name="Instruction_is_from_a_different_block" xml:space="preserve">
    <value>Instruction is from a different block</value>
  </data>
  <data name="Mismatched_modules_for_Comdat" xml:space="preserve">
    <value>Mismatched modules for Comdat</value>
  </data>
  <data name="Context_for_the_handle_provided_doesn_t_match_the_context_for_this_cache" xml:space="preserve">
    <value>Context for the handle provided doesn't match the context for this cache</value>
  </data>
  <data name="Location_does_not_describe_the_function_containing_the_provided_instruction" xml:space="preserve">
    <value>Location does not describe the function containing the provided instruction</value>
  </data>
  <data name="Scope_does_not_describe_the_function_containing_the_provided_instruction" xml:space="preserve">
    <value>Scope does not describe the function containing the provided instruction</value>
  </data>
  <data name="Assert_Should_not_get_a_null_pointer_from_LLVM" xml:space="preserve">
    <value>Should not get a null pointer from LLVM</value>
  </data>
  <data name="Cannot_get_null_for_labels_and_opaque_types" xml:space="preserve">
    <value>Cannot get a Null value for labels, functions and opaque types</value>
  </data>
  <data name="Alignment_only_allowed_on_memory_instructions" xml:space="preserve">
    <value>Alignment can only be set for instructions dealing with memory read/write (alloca, load, store)</value>
  </data>
  <data name="Non_pointer_type_expected" xml:space="preserve">
      <value>Non-pointer type expected</value>
  </data>
  <data name="Cannot_load_a_value_for_an_opaque_or_unsized_type" xml:space="preserve">
      <value>Cannot load a value for an opaque or unsized type</value>
  </data>
</root>
