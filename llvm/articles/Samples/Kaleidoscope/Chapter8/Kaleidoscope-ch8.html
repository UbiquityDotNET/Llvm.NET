<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>8. Kaleidoscope: Compiling to Object Code | Ubiquity.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="8. Kaleidoscope: Compiling to Object Code | Ubiquity.NET ">
      
      
      <link rel="icon" href="../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Chapter8/Kaleidoscope-ch8.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../llvm/DragonSharp48x48.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

        </div>

        <article data-uid="Kaleidoscope-ch8">
<h1 id="8-kaleidoscope-compiling-to-object-code">8. Kaleidoscope: Compiling to Object Code</h1>

<p>This tutorial describes how to adapt the Kaleidoscope JIT engine into an Ahead of Time (AOT)
compiler by generating target specific native object files.</p>
<h2 id="choosing-a-target">Choosing a target</h2>
<p>LLVM has built-in support for cross-compilation. This allows compiling to the architecture
of the platform you run the compiler on or, just as easily, for some other architecture. For
the Kaleidoscope tutorial we'll focus on just the native target the compiler is running on.</p>
<p>LLVM uses a &quot;Triple&quot; string to describe the target used for code generation. This takes the
form <code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code> (see the description of the <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Triple.html">Triple</a>
type for more details)</p>
<p>Fortunately, it is normally not required to build such strings directly.</p>
<h2 id="grammar">Grammar</h2>
<p>In the preceding chapters the Kaleidoscope implementation provided an interactive JIT based
on the classic Read Evaluate Print Loop (REPL). So the grammar focused on a top level rule
&quot;repl&quot; that processes individual expressions one at a time. For native compilation this
complicates the process of parsing and processing a complete file. To handle these two
distinct scenarios the grammar has different rules. For the interactive scenario the
previously mentioned &quot;repl&quot; rule is used. When parsing a full source file the &quot;fullsrc&quot; rule
is used as the start.</p>
<pre><code class="lang-antlr">// Full source parse accepts a series of definitions or prototypes, all top level expressions
// are generated into a single function called Main()
fullsrc
    : repl*;
</code></pre>
<p>This rule simply accepts any number of expressions so that a single source file is parsed to
a single complete parse tree. (This particular point will become even more valuable when
generating debug information in <a class="xref" href="../Chapter9/Kaleidoscope-ch9.html">Chapter 9</a> as the parse tree nodes
contain the source location information based on the original input stream).</p>
<h2 id="code-generation-changes">Code Generation Changes</h2>
<p>The changes in code generation are fairly straight forward and consist of the following
basic steps.</p>
<ol>
<li>Remove JIT engine support</li>
<li>Expose the bit code module generated, so it is available to the &quot;driver&quot;.</li>
<li>Saving the target machine (since it doesn't come from the JIT anymore)</li>
<li>Keep track of all generated top level anonymous expressions</li>
<li>Once generating from the parse tree is complete generate a main() that includes calls to
all the previously generated anonymous expressions.</li>
</ol>
<p>Most of these steps are pretty straight forward. The anonymous function handling is a bit
distinct. Since the language syntax allows anonymous expressions throughout the source file,
and they don't actually execute during generation - they need to be organized into an
executable form. Thus, a new list of the generated functions is maintained and, after the
tree is generated, a new main() function is created and a call to each anonymous expression
is made with a second call to printd() to show the results - just like they would appear if
typed in an interactive console. A trick used in the code generation is to mark each of the
anonymous functions as private and always inline so that a simple optimization pass can
eliminate the anonymous functions after inlining them all into the main() function.</p>
<pre><code class="lang-C#">// mark anonymous functions as always-inline and private so they can be removed
if(definition.IsAnonymous)
{
    function.AddAttribute( FunctionAttributeIndex.Function, &quot;alwaysinline&quot;u8 )
            .Linkage( Linkage.Private );

    AnonymousFunctions.Add( function );
}
</code></pre>
<p>These settings are leveraged after generating from the tree to create the main function. A
simple loop generates a call to each expression along with the call to print the results.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The always inliner will inline the functions marked as inline and the dead code
elimination pass will eliminate unused internal/private global symbols. This has the
effect of generating the main function with all top level expressions inlined and the
originally generated anonymous functions removed.</p>
</div>
<pre><code class="lang-csharp" name="Generate">public Module? Generate( IAstNode ast )
{
    ArgumentNullException.ThrowIfNull( ast );

    ast.Accept( this );

    if(AnonymousFunctions.Count &gt; 0)
    {
        var mainFunction = Module.CreateFunction( &quot;main&quot;, Context.GetFunctionType( Context.VoidType ) );
        var block = mainFunction.AppendBasicBlock( &quot;entry&quot; );
        using var irBuilder = new InstructionBuilder( block );
        var printdFunc = Module.CreateFunction( &quot;printd&quot;, Context.GetFunctionType( Context.DoubleType, Context.DoubleType ) );
        foreach(var anonFunc in AnonymousFunctions)
        {
            var value = irBuilder.Call( anonFunc );
            irBuilder.Call( printdFunc, value );
        }

        irBuilder.Return();

        using var errInfo = Module.TryRunPasses(&quot;default&lt;O3&gt;&quot;);
        errInfo.ThrowIfFailed();
    }

    return Module;
}
</code></pre>
<p>Most of the rest of the changes are pretty straightforward following the steps listed
previously.</p>
<h3 id="anonymous-function-definitions">Anonymous Function Definitions</h3>
<p>As previously mentioned, when generating the top level expression the resulting function is
added to the list of anonymous functions to generate a call to it from main().</p>
<pre><code class="lang-csharp" name="FunctionDefinition">public override Value? Visit( FunctionDefinition definition )
{
    ArgumentNullException.ThrowIfNull( definition );
    Debug.Assert( InstructionBuilder is not null, &quot;Internal error Instruction builder should be set in Generate already&quot; );

    var function = GetOrDeclareFunction( definition.Signature );
    if(!function.IsDeclaration)
    {
        throw new CodeGeneratorException( $&quot;Function {function.Name} cannot be redefined in the same module&quot; );
    }

    try
    {
        var entryBlock = function.AppendBasicBlock( &quot;entry&quot; );
        InstructionBuilder.PositionAtEnd( entryBlock );
        using(NamedValues.EnterScope())
        {
            foreach(var param in definition.Signature.Parameters)
            {
                var argSlot = InstructionBuilder.Alloca( function.Context.DoubleType )
                                                .RegisterName( param.Name );
                InstructionBuilder.Store( function.Parameters[ param.Index ], argSlot );
                NamedValues[ param.Name ] = argSlot;
            }

            foreach(LocalVariableDeclaration local in definition.LocalVariables)
            {
                var localSlot = InstructionBuilder.Alloca( function.Context.DoubleType )
                                                  .RegisterName( local.Name );
                NamedValues[ local.Name ] = localSlot;
            }

            EmitBranchToNewBlock( &quot;body&quot; );

            var funcReturn = definition.Body.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidFunc );
            InstructionBuilder.Return( funcReturn );
            function.Verify();

            if(definition.IsAnonymous)
            {
                function.AddAttribute( FunctionAttributeIndex.Function, &quot;alwaysinline&quot;u8 )
                        .Linkage( Linkage.Private );

                AnonymousFunctions.Add( function );
            }

            return function;
        }
    }
    catch(CodeGeneratorException)
    {
        function.EraseFromParent();
        throw;
    }
}
</code></pre><h2 id="driver-changes">Driver changes</h2>
<p>To support generating object files the &quot;driver&quot; application code needs some alterations. The
changes fall into two general categories:</p>
<ol>
<li>Command line argument handling</li>
<li>Generating the output files</li>
</ol>
<h3 id="adding-command-line-handling">Adding Command Line handling</h3>
<p>To allow providing a file like a traditional compiler the driver app needs to have some
basic command line argument handling. (&quot;Basic&quot; in this case means truly rudimentary üòÅ )
Generally this just gets a viable file path to use for the source code.</p>
<pre><code class="lang-csharp" name="ProcessArgs"></code></pre><h3 id="update-main">Update Main()</h3>
<p>The real work comes in the Main application driver, though there isn't a lot of additional
code here either. The general plan is:</p>
<ol>
<li>Process the arguments to get the path to compile</li>
<li>Open the file for reading</li>
<li>Create a new target machine from the default triple of the host</li>
<li>Create the parser stack</li>
<li>Parse the input file</li>
<li>Generate the IR code from the parse tree</li>
<li>Once the parsing has completed, verify the module and emit the object file</li>
<li>For diagnostics use, also emit the LLVM IR textual form and assembly files</li>
</ol>
<pre><code class="lang-csharp" name="Main">
/// &lt;summary&gt;C# version of the LLVM Kaleidoscope language tutorial&lt;/summary&gt;
/// &lt;param name=&quot;args&quot;&gt;Command line arguments to the application&lt;/param&gt;
/// &lt;returns&gt;0 on success; non-zero on error&lt;/returns&gt;
/// &lt;remarks&gt;
/// The command line options at present are just the source file name
/// &lt;/remarks&gt;
[SuppressMessage( &quot;Design&quot;, &quot;CA1062:Validate arguments of public methods&quot;, Justification = &quot;Provided by Platform&quot; )]
public static int Main( string[] args )
{
    var reporter = new ColoredConsoleReporter(MsgLevel.Information);
    if(!ArgsParsing.TryParse&lt;Options&gt;( args, reporter, out Options? options, out int exitCode ))
    {
        return exitCode;
    }

    // TODO: Reset Command line option to support reporting level from command line (if different)

    string sourceFilePath = options.SourcePath.FullName;

    string objFilePath = Path.ChangeExtension( sourceFilePath, &quot;.o&quot; );
    string irFilePath = Path.ChangeExtension( sourceFilePath, &quot;.ll&quot; );
    string asmPath = Path.ChangeExtension( sourceFilePath, &quot;.s&quot; );

    using var libLLVM = InitializeLLVM( );
    libLLVM.RegisterTarget( CodeGenTarget.Native );

    using var hostTriple = Triple.GetHostTriple();
    using var machine = new TargetMachine( hostTriple );
    var parser = new Parser( LanguageLevel.MutableVariables );

    using var generator = new CodeGenerator( parser.GlobalState, machine );
    Console.WriteLine( &quot;Ubiquity.NET.Llvm Kaleidoscope Compiler - {0}&quot;, parser.LanguageLevel );
    Console.WriteLine( &quot;Compiling {0}&quot;, sourceFilePath );

    // Create adapter to route parse messages for the Kaleidoscope language to the command line reporter for this app
    var errorLogger = new ParseErrorDiagnosticAdapter(reporter, &quot;KLS&quot;, new Uri(sourceFilePath) );

    // time the parse and code generation
    var timer = System.Diagnostics.Stopwatch.StartNew( );
    var ast = parser.ParseFrom( sourceFilePath );
    if(!errorLogger.CheckAndReportParseErrors( ast ))
    {
        Module? module = generator.Generate( ast );
        if(module is null)
        {
            Console.Error.WriteLine( &quot;No module generated&quot; );
        }
        else if(!module.Verify( out string errMsg ))
        {
            Console.Error.WriteLine( errMsg );
        }
        else
        {
            machine.EmitToFile( module, objFilePath, CodeGenFileKind.ObjectFile );
            timer.Stop(); // only time Object file generation (the rest is just useful reference)

            Console.WriteLine( &quot;Wrote {0}&quot;, objFilePath );
            if(!module.WriteToTextFile( irFilePath, out string msg ))
            {
                Console.Error.WriteLine( msg );
                return -1;
            }

            Console.WriteLine( &quot;Wrote {0}&quot;, irFilePath );

            machine.EmitToFile( module, asmPath, CodeGenFileKind.AssemblySource );
            Console.WriteLine( &quot;Wrote {0}&quot;, asmPath );

            Console.WriteLine( &quot;Compilation Time: {0}&quot;, timer.Elapsed );
        }
    }

    return 0;
}
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>That's it - seriously! Very little change was needed, mostly deleting code and adding the
special handling of the anonymous expressions. Looking at the changes it should be clear
that it is possible to support runtime choice between JIT and full native compilation
instead of deleting the JIT code. (Implementing this feature is &quot;left as an exercise for the
reader&quot; üòâ)</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Chapter8/Kaleidoscope-ch8.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright (C) 2017-2025, Ubiquity.NET Contributors
          - Build: 20.1.9
        </div>
      </div>
    </footer>
  </body>
</html>
