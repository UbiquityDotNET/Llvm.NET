<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>3. Kaleidoscope: Generating LLVM IR | Ubiquity.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="3. Kaleidoscope: Generating LLVM IR | Ubiquity.NET ">
      
      
      <link rel="icon" href="../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Chapter3/Kaleidoscope-ch3.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../llvm/DragonSharp48x48.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

        </div>

        <article data-uid="Kaleidoscope-ch3">
<h1 id="3-kaleidoscope-generating-llvm-ir">3. Kaleidoscope: Generating LLVM IR</h1>

<p>This chapter focuses on the basics of transforming the ANTLR parse tree into LLVM
IR. The general goal is to parse Kaleidoscope source code to generate a
<a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Module.html">Module</a> representing the source as LLVM IR.</p>
<h2 id="basic-code-flow">Basic code flow</h2>
<p>The basic flow of all of these samples is the same for the LLVM+JIT variants (Even
though this version doesn't use the JIT it is setting the stage to get there).</p>
<ol>
<li>A new <code>ReplEngine</code> is created to handle the standard REPL support with
customizations.
<ol>
<li>The application uses its own implementation to handle extension points for
the common support.</li>
</ol>
</li>
<li>A <code>CancellationTokenSource</code> is created and hooked up to cancel the REPL when
<code>CTRL-C is pressed</code> to allow normal expectations of termination for a command
line application.</li>
<li>Information on the specific app is reported to the console</li>
<li>LLVM is initialized
<ol>
<li>The native target is registered so that at least a Local JIT is workable</li>
</ol>
</li>
<li>The REPL engine is run to do the work</li>
</ol>
<h3 id="initializing-ubiquitynetllvm">Initializing Ubiquity.NET.Llvm</h3>
<p>The underlying LLVM library requires initialization for it's internal data,
furthermore Ubiquity.NET.Llvm must load the actual underlying library specific to
the current system architecture. Thus, the Ubiquity.NET.Llvm as a whole requires
initialization.</p>
<pre><code class="lang-C#">using static Ubiquity.NET.Llvm.Interop.Library;

// [...]

using( InitializeLLVM() )
{
    // [...]
}
</code></pre>
<p>The initialization returns an IDisposable so that the calling application can
shutdown/cleanup resources and potentially re-initialize for a different target, if
desired. This application only needs to generate one module and exit so it just
applies a standard C# <code>using</code> scope to ensure proper cleanup.</p>
<h3 id="initializing-targets">Initializing Targets</h3>
<p>LLVM supports a number of target architectures, however for the Kaleidoscope
tutorials the only supported target is the one the host application is running on.
So, only the native target is registered.</p>
<pre><code class="lang-C#">    RegisterNative();
</code></pre>
<h3 id="generator-and-repl-loop">Generator and REPL loop</h3>
<p>This chapter supports the simple expressions of the language that are parsed and
generated to an LLVM <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Values.Value.html">Value</a>. This forms the
foundation of the Kaleidoscope samples outer generation loop. Subsequent, chapters
will focus on additional functionality including JIT compilation, Debugging
information, and Native Module generation. Processing the results for this chapter,
is pretty simple, it just prints out a textual form of the generated LLVM IR.</p>
<pre><code class="lang-csharp" name="Main">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System;

using Kaleidoscope.Grammar;
using Kaleidoscope.Runtime;

using Ubiquity.NET.Llvm.Values;
using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Chapter3
{
    internal class ReplEngine
        : KaleidoscopeReadEvaluatePrintLoopBase&lt;Value&gt;
    {
        public ReplEngine( )
            : base( LanguageLevel.SimpleExpressions )
        {
        }

        public override ICodeGenerator&lt;Value&gt; CreateGenerator( DynamicRuntimeState state )
        {
            return new CodeGenerator( state );
        }

        public override void ProcessResults( Value resultValue )
        {
            switch(resultValue)
            {
            case Function function:
                Console.WriteLine( &quot;Defined function: {0}&quot;, function.Name );
                Console.WriteLine( function );
                break;

            default:
                throw new InvalidOperationException();
            }
        }
    }
}
</code></pre><h2 id="code-generation">Code generation</h2>
<h3 id="initialization">Initialization</h3>
<p>The code generation maintains state for the transformation as private members.</p>
<pre><code class="lang-csharp" name="Main">private readonly Module Module;
private readonly DynamicRuntimeState RuntimeState;
private readonly Context Context;
private readonly InstructionBuilder InstructionBuilder;
private readonly Dictionary&lt;string, Value&gt; NamedValues = [];
</code></pre>
<p>These are initialized in the constructor</p>
<pre><code class="lang-csharp" name="Main">public CodeGenerator( DynamicRuntimeState globalState )
    : base( null )
{
    ArgumentNullException.ThrowIfNull( globalState );

    if(globalState.LanguageLevel &gt; LanguageLevel.SimpleExpressions)
    {
        throw new ArgumentException( &quot;Language features not supported by this generator&quot;, nameof( globalState ) );
    }

    RuntimeState = globalState;
    Context = new Context();
    Module = Context.CreateBitcodeModule( &quot;Kaleidoscope&quot; );
    InstructionBuilder = new InstructionBuilder( Context );
}
</code></pre>
<p>The exact set of members varies for each chapter but the basic ideas remain across
each chapter.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>RuntimeState</td>
<td>Contains information about the language and dynamic runtime state needed for resolving operator precedence</td>
</tr>
<tr>
<td>Context</td>
<td>Current <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Context.html">Context</a> for LLVM generation</td>
</tr>
<tr>
<td>Module</td>
<td>Current <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Module.html">Module</a> to generate LLVM IR in</td>
</tr>
<tr>
<td>InstructionBuilder</td>
<td>Current  <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html">InstructionBuilder</a> used to generate LLVM IR instructions</td>
</tr>
<tr>
<td>NamedValues</td>
<td>Contains a mapping of named variables to the generated <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Values.Value.html">Value</a></td>
</tr>
</tbody>
</table>
<h3 id="generate-method">Generate Method</h3>
<p>The Generate method is used by the REPL loop to generate the final output from a
parse tree. The common implementation simply passes the tree to the AST generating
parse tree visitor to generate the AST and process the AST nodes from that. Due to
the simplicity of the Kaleidoscope language the AST is more of a List than a tree.
In fact, the AstBuilder creates an enumerable sequence of nodes that are either a
function declaration or a function definition. For the interactive mode only a
single element is parsed at a time. However, when doing Ahead of Time (AOT)
compilation in <a class="xref" href="../Chapter8/Kaleidoscope-ch8.html">Chapter 8</a> this sequence can contain many
declarations and definitions in any order. To handle the different node types the
generate method simply uses pattern matching to detect the type of node to dispatch to a visitor
function for that kind of node.</p>
<pre><code class="lang-csharp" name="Main">public Value? Generate( IAstNode ast )
{
    ArgumentNullException.ThrowIfNull( ast );

    // Prototypes, including extern are ignored as AST generation
    // adds them to the RuntimeState so that already has the declarations
    // They are looked up and added to the module as extern if not already
    // present if they are called.
    if(ast is not FunctionDefinition definition)
    {
        return default;
    }

    var function = definition.Accept( this ) as Function ?? throw new CodeGeneratorException(ExpectValidFunc);
    return function.ParentModule.Verify( out string msg ) ? (Value)function : throw new CodeGeneratorException( msg );
}
</code></pre><h3 id="function-declarations">Function Declarations</h3>
<p>Function declarations don't actually generate any code. Instead they are captured
and added to a collection of declarations used in validating subsequent function
calls when generating the AST for function definitions.</p>
<pre><code class="lang-csharp" name="Main">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System.Collections.Generic;
using System.Linq;
using System.Text;

using Ubiquity.NET.Runtime.Utils;
using Ubiquity.NET.TextUX;

namespace Kaleidoscope.Grammar.AST
{
    /// &lt;summary&gt;Encapsulates data describing a function signature&lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This is used to enable consistent representation when the prototype
    /// is synthesized during code generation (i.e. Anonymous expressions)
    /// &lt;/remarks&gt;
    public sealed class Prototype
        : AstNode
        , IAstNode
    {
        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Source location covering the complete signature&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;&lt;see cref=&quot;Name&quot;/&gt; containing the name of the function&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;Collection of &lt;see cref=&quot;Name&quot;/&gt;s for the names of each parameter&lt;/param&gt;
        public Prototype( SourceRange location, string name, params ParameterDeclaration[] parameters )
            : this( location, name, false, false, parameters )
        {
        }

        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Source location covering the complete signature&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;&lt;see cref=&quot;Name&quot;/&gt; containing the name of the function&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;Collection of &lt;see cref=&quot;Name&quot;/&gt;s for the names of each parameter&lt;/param&gt;
        public Prototype( SourceRange location, string name, IEnumerable&lt;ParameterDeclaration&gt; parameters )
            : this( location, name, false, false, parameters )
        {
        }

        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;Name of the function&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;Names of each parameter&lt;/param&gt;
        /// &lt;remarks&gt;
        /// This version of the constructor is used to create synthetic prototypes that don't
        /// exist within the original source.
        /// &lt;/remarks&gt;
        public Prototype( string name, params string[] parameters )
            : this( default, name, false, false, parameters.Select( ( n, i ) =&gt; new ParameterDeclaration( default, name, i ) ) )
        {
        }

        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Source location covering the complete signature&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;name of the function&lt;/param&gt;
        /// &lt;param name=&quot;isCompilerGenerated&quot;&gt;Indicates if this is a compiler generated prototype&lt;/param&gt;
        public Prototype( SourceRange location, string name, bool isCompilerGenerated )
            : this( location, name, isCompilerGenerated, false, [] )
        {
        }

        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Source location covering the complete signature&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;name of the function&lt;/param&gt;
        /// &lt;param name=&quot;isCompilerGenerated&quot;&gt;Indicates if this is a compiler generated prototype&lt;/param&gt;
        /// &lt;param name=&quot;isExtern&quot;&gt;Indicates if this is an external prototype&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;names of each parameter&lt;/param&gt;
        public Prototype(
            SourceRange location,
            string name,
            bool isCompilerGenerated,
            bool isExtern,
            IEnumerable&lt;ParameterDeclaration&gt; parameters
            )
            : base( location )
        {
            Name = name;
            Parameters = [ .. parameters ];
            IsCompilerGenerated = isCompilerGenerated;
            IsExtern = isExtern;
        }

        /// &lt;summary&gt;Gets the name of the function&lt;/summary&gt;
        public string Name { get; }

        /// &lt;summary&gt;Gets a value indicating whether the function prototype is an extern declaration&lt;/summary&gt;
        public bool IsExtern { get; }

        /// &lt;summary&gt;Gets a value indicating whether the function prototype is generated internally by compiler&lt;/summary&gt;
        public bool IsCompilerGenerated { get; }

        /// &lt;summary&gt;Gets the parameters for the function&lt;/summary&gt;
        public IReadOnlyList&lt;ParameterDeclaration&gt; Parameters { get; }

        public override TResult? Accept&lt;TResult&gt;( IAstVisitor&lt;TResult&gt; visitor )
            where TResult : default
        {
            return visitor is IKaleidoscopeAstVisitor&lt;TResult&gt; klsVisitor
                   ? klsVisitor.Visit( this )
                   : visitor.Visit( this );
        }

        public override TResult? Accept&lt;TResult, TArg&gt;( IAstVisitor&lt;TResult, TArg&gt; visitor, ref readonly TArg arg )
            where TResult : default
        {
            return visitor is IKaleidoscopeAstVisitor&lt;TResult, TArg&gt; klsVisitor
                   ? klsVisitor.Visit( this, in arg )
                   : visitor.Visit( this, in arg );
        }

        /// &lt;inheritdoc/&gt;
        public override IEnumerable&lt;IAstNode&gt; Children =&gt; Parameters;

        /// &lt;inheritdoc/&gt;
        public override string ToString( )
        {
            var bldr = new StringBuilder( );
            if(IsExtern)
            {
                bldr.Append( &quot;[extern]&quot; );
            }

            if(IsCompilerGenerated)
            {
                bldr.Append( &quot;[CompilerGenerated]&quot; );
            }

            bldr.Append( Name );
            bldr.Append( '(' );
            if(Parameters.Count &gt; 0)
            {
                bldr.Append( string.Join( &quot;, &quot;, Parameters.Select( p =&gt; p.ToString() ) ) );
            }

            bldr.Append( ')' );
            return bldr.ToString();
        }
    }
}
</code></pre><h3 id="function-definition">Function Definition</h3>
<p>Functions with bodies (e.g. not just a declaration to a function defined elsewhere) are handled via the
VisitFunctionDefinition() Method.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( FunctionDefinition definition )
{
    ArgumentNullException.ThrowIfNull( definition );

    var function = GetOrDeclareFunction( definition.Signature );
    if(!function.IsDeclaration)
    {
        throw new CodeGeneratorException( $&quot;Function {function.Name} cannot be redefined in the same module&quot; );
    }

    try
    {
        var entryBlock = function.AppendBasicBlock( &quot;entry&quot; );
        InstructionBuilder.PositionAtEnd( entryBlock );
        NamedValues.Clear();
        foreach(var param in definition.Signature.Parameters)
        {
            NamedValues[ param.Name ] = function.Parameters[ param.Index ];
        }

        var funcReturn = definition.Body.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidFunc );
        InstructionBuilder.Return( funcReturn );
        function.Verify();
        return function;
    }
    catch(CodeGeneratorException)
    {
        function.EraseFromParent();
        throw;
    }
}
</code></pre>
<p>VisitFunctionDefinition() simply extracts the function prototype from the AST node. A private utility
method GetOrDeclareFunction() is used to get an existing function or declare a new
one.</p>
<pre><code class="lang-csharp" name="Main">
// Retrieves a Function for a prototype from the current module if it exists,
// otherwise declares the function and returns the newly declared function.
private Function GetOrDeclareFunction( Prototype prototype )
{
    if(Module.TryGetFunction( prototype.Name, out Function? function ))
    {
        return function;
    }

    var llvmSignature = Context.GetFunctionType( returnType: Context.DoubleType, args: prototype.Parameters.Select( _ =&gt; Context.DoubleType ) );
    var retVal = Module.CreateFunction( prototype.Name, llvmSignature );

    int index = 0;
    foreach(var argId in prototype.Parameters)
    {
        retVal.Parameters[ index ].Name = argId.Name;
        ++index;
    }

    return retVal;
}
</code></pre>
<p>GetOrDeclareFunction() will first attempt to get an existing function and if found
returns that function. Otherwise it creates a function signature type then adds a
function to the module with the given name and signature and adds the parameter
names to the function. In LLVM the signature only contains type information and no
names, allowing for sharing the same signature for completely different functions.</p>
<p>The function and the expression representing the body of the function is then used
to emit IR for the function.</p>
<p>The generation verifies that the function is a declaration (e.g. does not have a
body) as Kaleidoscope doesn't support any sort of overloaded functions.</p>
<p>The generation of a function starts by constructing a basic block for the entry
point of the function and attaches the InstructionBuilder to the end of that block.
(It's empty so it is technically at the beginning but placing it at the end it will
track the end position as new instructions are added so that each instruction added
will go on the end of the block). At this point there will only be the one block as
the language doesn't yet have support for control flow. (That is introduced in
<a class="xref" href="../Chapter5/Kaleidoscope-ch5.html">Chapter 5</a>)</p>
<p>The NamedValues map is cleared and each of the parameters is mapped in the
NamedValues map to its argument value in IR. The body of the function is visited to
produce an LLVM Value. The visiting will, in turn add instructions, and possibly
new blocks, as needed to represent the body expression in proper execution order.</p>
<p>If generating the body results in an error, then the function is removed from the
parent and the exception propagates up. This allows the user to define the function
again, if appropriate.</p>
<p>Finally, a return instruction is applied to return the result of the expression
followed by a verification of the function to ensure internal consistency.
(Generally the verify is not used in production releases as it is an expensive
operation to perform on every function. But when building up a language generator it
is quite useful to detect errors early.)</p>
<h4 id="top-level-expression">Top Level Expression</h4>
<p>Top level expressions in Kaleidoscope are transformed into an anonymous function
definition by the AstBuilder. Since this chapter is focused on generating the IR
module there isn't any special handling needed for a top level expression - they
are simply just another function definition. (JIT execution of the top level
expression comes in the next chapter)</p>
<h3 id="constant-expression">Constant expression</h3>
<p>In Kaleidoscope all values are floating point and constants are represented in LLVM
IR as <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Values.ConstantFP.html">ConstantFP</a>. The AST provides the
value of the constant as a C# <code>double</code>.</p>
<pre><code class="lang-csharp" name="Main">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System.Collections.Generic;
using System.Globalization;

using Ubiquity.NET.Runtime.Utils;
using Ubiquity.NET.TextUX;

namespace Kaleidoscope.Grammar.AST
{
    public sealed class ConstantExpression
        : AstNode
        , IExpression
    {
        public ConstantExpression( SourceRange location, double value )
            : base( location )
        {
            Value = value;
        }

        public double Value { get; }

        public override TResult? Accept&lt;TResult&gt;( IAstVisitor&lt;TResult&gt; visitor )
            where TResult : default
        {
            return visitor is IKaleidoscopeAstVisitor&lt;TResult&gt; klsVisitor
                   ? klsVisitor.Visit( this )
                   : visitor.Visit( this );
        }

        public override TResult? Accept&lt;TResult, TArg&gt;( IAstVisitor&lt;TResult, TArg&gt; visitor, ref readonly TArg arg )
            where TResult : default
        {
            return visitor is IKaleidoscopeAstVisitor&lt;TResult, TArg&gt; klsVisitor
                   ? klsVisitor.Visit( this, in arg )
                   : visitor.Visit( this, in arg );
        }

        public override IEnumerable&lt;IAstNode&gt; Children =&gt; [];

        public override string ToString( )
        {
            return Value.ToString( CultureInfo.CurrentCulture );
        }
    }
}
</code></pre>
<p>Generation of the LLVM IR for a constant is quite simple.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( ConstantExpression constant )
{
    ArgumentNullException.ThrowIfNull( constant );

    return Context.CreateConstant( constant.Value );
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The constant value is uniqued in LLVM so that multiple calls given the same input
value will produce the same LLVM Value. Ubiquity.NET.Llvm honors this via value
equality tests. It does <em><strong>NOT</strong></em> guarantee reference equality. (It used to in
older versions but no longer does as that led to subtle problems with ownership
and multi-threaded JIT)</p>
</div>
<h3 id="variable-reference-expression">Variable reference expression</h3>
<p>References to variables in Kaleidoscope, like most other languages, use a name. In
this chapter the support of variables is rather simple. The Variable expression
generator assumes the variable is declared somewhere else already and simply looks
up the value from the private map. At this stage of the development of Kaleidoscope
the only place where the named values are generated are function arguments, later
chapters will introduce loop induction variables and variable assignment. The
implementation uses a standard &quot;Try/Get&quot; pattern to retrieve the value or throw an
exception if the variable doesn't exist.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( VariableReferenceExpression reference )
{
    ArgumentNullException.ThrowIfNull( reference );

    if(!NamedValues.TryGetValue( reference.Name, out Value? value ))
    {
        // Source input is validated by the parser and AstBuilder, therefore
        // this is the result of an internal error in the generator rather
        // then some sort of user error.
        throw new CodeGeneratorException( $&quot;ICE: Unknown variable name: {reference.Name}&quot; );
    }

    return value;
}
</code></pre><h3 id="binary-operator-expression">Binary Operator Expression</h3>
<p>Things start to get a good bit more interesting with binary operators. The AST node
for an expression is a simple empty &quot;tagging&quot; interface. Since the interface also
requires the IAstNode interface it contains support for walking the chain of
operators that form an expression in left to right order, accounting for precedence.</p>
<pre><code class="lang-csharp" name="Main">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Grammar.AST
{
    /// &lt;summary&gt;This is a grouping interface for all AST nodes that are valid expressions&lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This is a grouping interface to allow other parts of the system to distinguish between
    /// an arbitrary node and one that is ultimately an expression. This helps to ensure correctness
    /// (e.g. a function declaration is not valid as an argument to an operator, only an expression is.
    /// &lt;/remarks&gt;
    public interface IExpression
        : IAstNode
    {
    }
}
</code></pre>
<p>Generation of an expression consists a simple visitor method to emit the code for
the operands and the actual operator.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( BinaryOperatorExpression binaryOperator )
{
    ArgumentNullException.ThrowIfNull( binaryOperator );

    switch(binaryOperator.Op)
    {
    case BuiltInOperatorKind.Less:
    {
        var tmp = InstructionBuilder.Compare( RealPredicate.UnorderedOrLessThan
                                                , binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                                , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                                ).RegisterName( &quot;cmptmp&quot; );
        return InstructionBuilder.UIToFPCast( tmp, InstructionBuilder.Context.DoubleType )
                                 .RegisterName( &quot;booltmp&quot; );
    }

    case BuiltInOperatorKind.Pow:
    {
        var pow = GetOrDeclareFunction( new Prototype( &quot;llvm.pow.f64&quot;, &quot;value&quot;, &quot;power&quot; ) );
        return InstructionBuilder.Call( pow
                                      , binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;powtmp&quot; );
    }

    case BuiltInOperatorKind.Add:
        return InstructionBuilder.FAdd( binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;addtmp&quot; );

    case BuiltInOperatorKind.Subtract:
        return InstructionBuilder.FSub( binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;subtmp&quot; );

    case BuiltInOperatorKind.Multiply:
        return InstructionBuilder.FMul( binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;multmp&quot; );

    case BuiltInOperatorKind.Divide:
        return InstructionBuilder.FDiv( binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;divtmp&quot; );

    default:
        throw new CodeGeneratorException( $&quot;ICE: Invalid binary operator {binaryOperator.Op}&quot; );
    }
}
</code></pre>
<p>The process of transforming the operator starts by generating an LLVM IR Value from
the right-hand side expression. A simple switch statement based on the token type
of the operator is used to generate the actual LLVM IR instruction(s) for the
operator.</p>
<p>LLVM has strict rules on the operators and their values for the IR, in particular
the types of the operands must be identical and, usually must also match the type
of the result. For the Kaleidoscope language that's easy to manage as it only
supports one data type. Other languages might need to insert additional conversion
logic as part of emitting the operators. (Kaleidoscope does this for boolean values
when supporting conditional control flow in <a class="xref" href="../Chapter5/Kaleidoscope-ch5.html">Chapter 5</a>)</p>
<p>The Generation of the IR instructions uses the current InstructionBuilder and the
<a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Values.ValueExtensions.RegisterName.html#Ubiquity_NET_Llvm_Values_ValueExtensions_RegisterName__1___0_System_String_">RegisterName</a>
extension method to provide a name for the result in LLVM IR. The name helps with
readability of the IR when generated in the textual form of LLVM IR assembly. A
nice feature of LLVM is that it will automatically handle duplicate names by
appending an integral value to the name automatically so that generators don't
need to keep track of the names to ensure uniqueness.</p>
<p>The <code>Less</code> operator uses a floating point <code>unordered less than</code> IR instruction
followed by an integer to float cast to translate the LLVM IR i1 result into a
floating point value needed by Kaleidoscope.</p>
<p>The <code>^</code> operator for exponentiation uses the <code>llvm.pow.f64</code> intrinsic to perform
the exponentiation a efficiently as the back-end generator can.</p>
<h2 id="examples">Examples</h2>
<pre><code class="lang-Console">Ubiquity.NET.Llvm Kaleidoscope Interpreter - SimpleExpressions
Ready&gt;# simple top level expression
&gt;4+5;
Defined function: __anon_expr$0

define double @&quot;__anon_expr$0&quot;() {
entry:
  ret double 9.000000e+00
}

Ready&gt;
Ready&gt;# function definitions
&gt;def foo(a b) a*a + 2*a*b + b*b;
Defined function: foo

define double @foo(double %a, double %b) {
entry:
  %multmp = fmul double %a, %a
  %multmp1 = fmul double 2.000000e+00, %a
  %multmp2 = fmul double %multmp1, %b
  %addtmp = fadd double %multmp, %multmp2
  %multmp3 = fmul double %b, %b
  %addtmp4 = fadd double %addtmp, %multmp3
  ret double %addtmp4
}

Ready&gt;
Ready&gt;def bar(a) foo(a, 4.0) + bar(31337);
Defined function: bar

define double @bar(double %a) {
entry:
  %calltmp = call double @foo(double %a, double 4.000000e+00)
  %calltmp1 = call double @bar(double 3.133700e+04)
  %addtmp = fadd double %calltmp, %calltmp1
  ret double %addtmp
}

Ready&gt;
Ready&gt;# external declaration
&gt;extern cos(x);
Defined function: cos

declare double @cos(double)

Ready&gt;
Ready&gt;# calling external function
&gt;cos(1.234);
Defined function: __anon_expr$1

define double @&quot;__anon_expr$1&quot;() {
entry:
  %calltmp = call double @cos(double 1.234000e+00)
  ret double %calltmp
}

Ready&gt;
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Chapter3/Kaleidoscope-ch3.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright (C) 2017-2025, Ubiquity.NET Contributors
          - Build: 20.1.8-beta
        </div>
      </div>
    </footer>
  </body>
</html>
