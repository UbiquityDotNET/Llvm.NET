<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>3. Kaleidoscope: Generating LLVM IR | Ubiquity.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="3. Kaleidoscope: Generating LLVM IR | Ubiquity.NET ">
      
      
      <link rel="icon" href="../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Chapter3/Kaleidoscope-ch3.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../llvm/DragonSharp48x48.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

        </div>

        <article data-uid="Kaleidoscope-ch3">
<h1 id="3-kaleidoscope-generating-llvm-ir">3. Kaleidoscope: Generating LLVM IR</h1>

<p>This chapter focuses on the basics of transforming the ANTLR parse tree into LLVM IR. The
general goal is to parse Kaleidoscope source code to generate a
<a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Module.html">Module</a> representing the source as LLVM IR.</p>
<h2 id="basic-code-flow">Basic code flow</h2>
<p>The basic flow of all of these samples is the same for the LLVM+JIT variants (Even though
this version doesn't use the JIT it is setting the stage to get there).</p>
<ol>
<li>A new <code>ReplEngine</code> is created to handle the standard REPL support with customizations.
<ol>
<li>The application uses its own implementation to handle extension points for the common
support.</li>
</ol>
</li>
<li>A <code>CancellationTokenSource</code> is created and hooked up to cancel the REPL when
<code>CTRL-C</code> is pressed to allow normal expectations of termination for a command line
application.</li>
<li>Information on the specific app is reported to the console</li>
<li>LLVM is initialized
<ol>
<li>The native target is registered so that at least a Local JIT is workable</li>
</ol>
</li>
<li>The REPL engine is run to do the work</li>
</ol>
<h3 id="initializing-ubiquitynetllvm">Initializing Ubiquity.NET.Llvm</h3>
<p>The underlying LLVM library requires initialization for it's internal data, furthermore
<code>Ubiquity.NET.Llvm</code> must load the actual underlying library specific to the current system
and architecture (RID). Thus, the <code>Ubiquity.NET.Llvm</code> library as a whole requires
initialization.</p>
<pre><code class="lang-C#">using static Ubiquity.NET.Llvm.Interop.Library;

// [...]

using( InitializeLLVM() )
{
    // [...]
}
</code></pre>
<p>The initialization returns an <code>IDisposable</code> so that the calling application can
shutdown/cleanup resources and potentially re-initialize for a different target, if desired.
This application only needs to generate one module and exit so it just applies a standard C#
<code>using</code> scope to ensure proper cleanup.</p>
<h3 id="initializing-targets">Initializing Targets</h3>
<p>LLVM supports a number of target architectures, however for the Kaleidoscope tutorials the
only supported target is the one the host application is running on. So, only the native
target is registered.</p>
<pre><code class="lang-C#">    RegisterNative();
</code></pre>
<h3 id="generator-and-repl-loop">Generator and REPL loop</h3>
<p>This chapter supports the simple expressions of the language that are parsed and generated
to an LLVM <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Values.Value.html">Value</a>. This forms the foundation of the
Kaleidoscope samples outer generation loop. Subsequent, chapters will focus on additional
functionality including JIT compilation, Debugging information, and Native Module
generation. Processing the results for this chapter, is pretty simple, it just prints out a
textual form of the generated LLVM IR.</p>
<pre><code class="lang-csharp" name="Main">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System;

using Kaleidoscope.Grammar;
using Kaleidoscope.Runtime;

using Ubiquity.NET.Llvm.Values;
using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Chapter3
{
    internal class ReplEngine
        : ReadEvaluatePrintLoopBase&lt;Value&gt;
    {
        public ReplEngine( )
            : base( LanguageLevel.SimpleExpressions )
        {
        }

        public override ICodeGenerator&lt;Value&gt; CreateGenerator( DynamicRuntimeState state )
        {
            return new CodeGenerator( state );
        }

        public override void ProcessResults( Value resultValue )
        {
            switch(resultValue)
            {
            case Function function:
                Console.WriteLine( &quot;Defined function: {0}&quot;, function.Name );
                Console.WriteLine( function );
                break;

            default:
                throw new InvalidOperationException();
            }
        }
    }
}
</code></pre><h2 id="code-generation">Code generation</h2>
<h3 id="initialization">Initialization</h3>
<p>The code generation maintains state for the transformation as private members.</p>
<pre><code class="lang-csharp" name="Main">private readonly Module Module;
private readonly DynamicRuntimeState RuntimeState;
private readonly Context Context;
private readonly InstructionBuilder InstructionBuilder;
private readonly Dictionary&lt;string, Value&gt; NamedValues = [];
</code></pre>
<p>These are initialized in the constructor</p>
<pre><code class="lang-csharp" name="Main">public CodeGenerator( DynamicRuntimeState globalState )
    : base( null )
{
    ArgumentNullException.ThrowIfNull( globalState );

    if(globalState.LanguageLevel &gt; LanguageLevel.SimpleExpressions)
    {
        throw new ArgumentException( &quot;Language features not supported by this generator&quot;, nameof( globalState ) );
    }

    RuntimeState = globalState;
    Context = new Context();
    Module = Context.CreateBitcodeModule( &quot;Kaleidoscope&quot; );
    InstructionBuilder = new InstructionBuilder( Context );
}
</code></pre>
<p>The exact set of members varies for each chapter but the basic ideas remain across each
chapter.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>RuntimeState</td>
<td>Contains information about the language and dynamic runtime state needed for resolving operator precedence</td>
</tr>
<tr>
<td>Context</td>
<td>Current <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Context.html">Context</a> for LLVM generation</td>
</tr>
<tr>
<td>Module</td>
<td>Current <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Module.html">Module</a> to generate LLVM IR in</td>
</tr>
<tr>
<td>InstructionBuilder</td>
<td>Current  <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Instructions.InstructionBuilder.html">InstructionBuilder</a> used to generate LLVM IR instructions</td>
</tr>
<tr>
<td>NamedValues</td>
<td>Contains a mapping of named variables to the generated <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Values.Value.html">Value</a></td>
</tr>
</tbody>
</table>
<h3 id="generate-method">Generate Method</h3>
<p>The Generate method is used by the REPL loop to generate the final output from a parse tree.
The common implementation simply passes the tree to the AST generating parse tree visitor to
generate the AST and process the AST nodes from that. Due to the simplicity of the
Kaleidoscope language the AST is more of a List than a tree. In fact, the AstBuilder creates
an enumerable sequence of nodes that are either a function declaration or a function
definition. For the interactive mode only a single element is parsed at a time. However,
when doing Ahead of Time (AOT) compilation in <a class="xref" href="../Chapter8/Kaleidoscope-ch8.html">Chapter 8</a> this
sequence can contain many declarations and definitions in any order. To handle the different
node types the generate method simply uses pattern matching to detect the type of node to
dispatch to a visitor function for that kind of node.</p>
<pre><code class="lang-csharp" name="Main">public Value? Generate( IAstNode ast )
{
    ArgumentNullException.ThrowIfNull( ast );

    // Prototypes, including extern are ignored as AST generation
    // adds them to the RuntimeState so that already has the declarations
    // They are looked up and added to the module as extern if not already
    // present if they are called.
    if(ast is not FunctionDefinition definition)
    {
        return default;
    }

    var function = definition.Accept( this ) as Function ?? throw new CodeGeneratorException(ExpectValidFunc);
    return function.ParentModule.Verify( out string msg ) ? (Value)function : throw new CodeGeneratorException( msg );
}
</code></pre><h3 id="function-declarations">Function Declarations</h3>
<p>Function declarations don't actually generate any code. Instead they are captured and added
to a collection of declarations used in validating subsequent function calls when generating
the AST for function definitions.</p>
<pre><code class="lang-csharp" name="Main">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System.Collections.Generic;
using System.Linq;
using System.Text;

using Ubiquity.NET.Extensions;
using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Grammar.AST
{
    /// &lt;summary&gt;Encapsulates data describing a function signature&lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This is used to enable consistent representation when the prototype
    /// is synthesized during code generation (i.e. Anonymous expressions)
    /// &lt;/remarks&gt;
    public sealed class Prototype
        : AstNode
        , IAstNode
    {
        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Source location covering the complete signature&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;&lt;see cref=&quot;Name&quot;/&gt; containing the name of the function&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;Collection of &lt;see cref=&quot;Name&quot;/&gt;s for the names of each parameter&lt;/param&gt;
        public Prototype( SourceRange location, string name, params ParameterDeclaration[] parameters )
            : this( location, name, false, false, parameters )
        {
        }

        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Source location covering the complete signature&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;&lt;see cref=&quot;Name&quot;/&gt; containing the name of the function&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;Collection of &lt;see cref=&quot;Name&quot;/&gt;s for the names of each parameter&lt;/param&gt;
        public Prototype( SourceRange location, string name, IEnumerable&lt;ParameterDeclaration&gt; parameters )
            : this( location, name, false, false, parameters )
        {
        }

        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;Name of the function&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;Names of each parameter&lt;/param&gt;
        /// &lt;remarks&gt;
        /// This version of the constructor is used to create synthetic prototypes that don't
        /// exist within the original source.
        /// &lt;/remarks&gt;
        public Prototype( string name, params string[] parameters )
            : this( default, name, false, false, parameters.Select( ( n, i ) =&gt; new ParameterDeclaration( default, name, i ) ) )
        {
        }

        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Source location covering the complete signature&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;name of the function&lt;/param&gt;
        /// &lt;param name=&quot;isCompilerGenerated&quot;&gt;Indicates if this is a compiler generated prototype&lt;/param&gt;
        public Prototype( SourceRange location, string name, bool isCompilerGenerated )
            : this( location, name, isCompilerGenerated, false, [] )
        {
        }

        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;Prototype&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Source location covering the complete signature&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;name of the function&lt;/param&gt;
        /// &lt;param name=&quot;isCompilerGenerated&quot;&gt;Indicates if this is a compiler generated prototype&lt;/param&gt;
        /// &lt;param name=&quot;isExtern&quot;&gt;Indicates if this is an external prototype&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;names of each parameter&lt;/param&gt;
        public Prototype(
            SourceRange location,
            string name,
            bool isCompilerGenerated,
            bool isExtern,
            IEnumerable&lt;ParameterDeclaration&gt; parameters
            )
            : base( location )
        {
            Name = name;
            Parameters = [ .. parameters ];
            IsCompilerGenerated = isCompilerGenerated;
            IsExtern = isExtern;
        }

        /// &lt;summary&gt;Gets the name of the function&lt;/summary&gt;
        public string Name { get; }

        /// &lt;summary&gt;Gets a value indicating whether the function prototype is an extern declaration&lt;/summary&gt;
        public bool IsExtern { get; }

        /// &lt;summary&gt;Gets a value indicating whether the function prototype is generated internally by compiler&lt;/summary&gt;
        public bool IsCompilerGenerated { get; }

        /// &lt;summary&gt;Gets the parameters for the function&lt;/summary&gt;
        public IReadOnlyList&lt;ParameterDeclaration&gt; Parameters { get; }

        /// &lt;inheritdoc cref=&quot;BinaryOperatorExpression.Accept{TResult}(IAstVisitor{TResult})&quot;/&gt;
        public override TResult? Accept&lt;TResult&gt;( IAstVisitor&lt;TResult&gt; visitor )
            where TResult : default
        {
            return visitor is IKaleidoscopeAstVisitor&lt;TResult&gt; klsVisitor
                   ? klsVisitor.Visit( this )
                   : visitor.Visit( this );
        }

        /// &lt;inheritdoc cref=&quot;BinaryOperatorExpression.Accept{TResult, TArg}(IAstVisitor{TResult, TArg}, ref readonly TArg)&quot;/&gt;
        public override TResult? Accept&lt;TResult, TArg&gt;( IAstVisitor&lt;TResult, TArg&gt; visitor, ref readonly TArg arg )
            where TResult : default
        {
            return visitor is IKaleidoscopeAstVisitor&lt;TResult, TArg&gt; klsVisitor
                   ? klsVisitor.Visit( this, in arg )
                   : visitor.Visit( this, in arg );
        }

        /// &lt;inheritdoc/&gt;
        public override IEnumerable&lt;IAstNode&gt; Children =&gt; Parameters;

        /// &lt;inheritdoc/&gt;
        public override string ToString( )
        {
            var bldr = new StringBuilder( );
            if(IsExtern)
            {
                bldr.Append( &quot;[extern]&quot; );
            }

            if(IsCompilerGenerated)
            {
                bldr.Append( &quot;[CompilerGenerated]&quot; );
            }

            bldr.Append( Name );
            bldr.Append( '(' );
            if(Parameters.Count &gt; 0)
            {
                bldr.Append( string.Join( &quot;, &quot;, Parameters.Select( p =&gt; p.ToString() ) ) );
            }

            bldr.Append( ')' );
            return bldr.ToString();
        }
    }
}
</code></pre><h3 id="function-definition">Function Definition</h3>
<p>Functions with bodies (e.g. not just a declaration to a function defined elsewhere) are
handled via the VisitFunctionDefinition() Method.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( FunctionDefinition definition )
{
    ArgumentNullException.ThrowIfNull( definition );

    var function = GetOrDeclareFunction( definition.Signature );
    if(!function.IsDeclaration)
    {
        throw new CodeGeneratorException( $&quot;Function {function.Name} cannot be redefined in the same module&quot; );
    }

    try
    {
        var entryBlock = function.AppendBasicBlock( &quot;entry&quot; );
        InstructionBuilder.PositionAtEnd( entryBlock );
        NamedValues.Clear();
        foreach(var param in definition.Signature.Parameters)
        {
            NamedValues[ param.Name ] = function.Parameters[ param.Index ];
        }

        var funcReturn = definition.Body.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidFunc );
        InstructionBuilder.Return( funcReturn );
        function.Verify();
        return function;
    }
    catch(CodeGeneratorException)
    {
        function.EraseFromParent();
        throw;
    }
}
</code></pre>
<p>VisitFunctionDefinition() simply extracts the function prototype from the AST node. A
private utility method GetOrDeclareFunction() is used to get an existing function or declare
a new one.</p>
<pre><code class="lang-csharp" name="Main">
// Retrieves a Function for a prototype from the current module if it exists,
// otherwise declares the function and returns the newly declared function.
private Function GetOrDeclareFunction( Prototype prototype )
{
    if(Module.TryGetFunction( prototype.Name, out Function? function ))
    {
        return function;
    }

    var llvmSignature = Context.GetFunctionType( returnType: Context.DoubleType, args: prototype.Parameters.Select( _ =&gt; Context.DoubleType ) );
    var retVal = Module.CreateFunction( prototype.Name, llvmSignature );

    int index = 0;
    foreach(var argId in prototype.Parameters)
    {
        retVal.Parameters[ index ].Name = argId.Name;
        ++index;
    }

    return retVal;
}
</code></pre>
<p>GetOrDeclareFunction() will first attempt to get an existing function and if found returns
that function. Otherwise it creates a function signature type then adds a function to the
module with the given name and signature and adds the parameter names to the function. In
LLVM the signature only contains type information and no names, allowing for sharing the
same signature for completely different functions.</p>
<p>The function and the expression representing the body of the function is then used to emit
IR for the function.</p>
<p>The generation verifies that the function is a declaration (e.g. does not have a body) as
Kaleidoscope doesn't support any sort of overloaded functions.</p>
<p>The generation of a function starts by constructing a basic block for the entry point of the
function and attaches the InstructionBuilder to the end of that block. (It's empty so it is
technically at the beginning but placing it at the end it will track the end position as new
instructions are added so that each instruction added will go on the end of the block). At
this point there will only be the one block as the language doesn't yet have support for
control flow. (That is introduced in <a class="xref" href="../Chapter5/Kaleidoscope-ch5.html">Chapter 5</a>)</p>
<p>The NamedValues map is cleared and each of the parameters is mapped in the NamedValues map
to its argument value in IR. The body of the function is visited to produce an LLVM Value.
The visiting will, in turn add instructions, and possibly new blocks, as needed to represent
the body expression in proper execution order.</p>
<p>If generating the body results in an error, then the function is removed from the parent and
the exception propagates up. This allows the user to define the function again, if
appropriate.</p>
<p>Finally, a return instruction is applied to return the result of the expression followed by
a verification of the function to ensure internal consistency. (Generally the verify is not
used in production releases as it is an expensive operation to perform on every function.
But when building up a language generator it is quite useful to detect errors early.)</p>
<h4 id="top-level-expression">Top Level Expression</h4>
<p>Top level expressions in Kaleidoscope are transformed into an anonymous function definition
by the AstBuilder. Since this chapter is focused on generating the IR module there isn't
any special handling needed for a top level expression - they are simply just another
function definition. (JIT execution of the top level expression comes in the next chapter)</p>
<h3 id="constant-expression">Constant expression</h3>
<p>In Kaleidoscope all values are floating point and constants are represented in LLVM IR as
<a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Values.ConstantFP.html">ConstantFP</a>. The AST provides the value of the
constant as a C# <code>double</code>.</p>
<pre><code class="lang-csharp" name="Main">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System.Collections.Generic;
using System.Globalization;

using Ubiquity.NET.Extensions;
using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Grammar.AST
{
    /// &lt;summary&gt;Kaleidoscope AST node for a constant&lt;/summary&gt;
    public sealed class ConstantExpression
        : AstNode
        , IExpression
    {
        /// &lt;summary&gt;Initializes a new instance of the &lt;see cref=&quot;ConstantExpression&quot;/&gt; class.&lt;/summary&gt;
        /// &lt;param name=&quot;location&quot;&gt;Location of the expression in the original source&lt;/param&gt;
        /// &lt;param name=&quot;value&quot;&gt;Value of the constant&lt;/param&gt;
        public ConstantExpression( SourceRange location, double value )
            : base( location )
        {
            Value = value;
        }

        /// &lt;summary&gt;Gets the value of this constant expression&lt;/summary&gt;
        public double Value { get; }

        /// &lt;inheritdoc cref=&quot;BinaryOperatorExpression.Accept{TResult}(IAstVisitor{TResult})&quot;/&gt;
        public override TResult? Accept&lt;TResult&gt;( IAstVisitor&lt;TResult&gt; visitor )
            where TResult : default
        {
            return visitor is IKaleidoscopeAstVisitor&lt;TResult&gt; klsVisitor
                   ? klsVisitor.Visit( this )
                   : visitor.Visit( this );
        }

        /// &lt;inheritdoc cref=&quot;BinaryOperatorExpression.Accept{TResult, TArg}(IAstVisitor{TResult, TArg}, ref readonly TArg)&quot;/&gt;
        public override TResult? Accept&lt;TResult, TArg&gt;( IAstVisitor&lt;TResult, TArg&gt; visitor, ref readonly TArg arg )
            where TResult : default
        {
            return visitor is IKaleidoscopeAstVisitor&lt;TResult, TArg&gt; klsVisitor
                   ? klsVisitor.Visit( this, in arg )
                   : visitor.Visit( this, in arg );
        }

        /// &lt;inheritdoc/&gt;
        public override IEnumerable&lt;IAstNode&gt; Children =&gt; [];

        /// &lt;inheritdoc/&gt;
        public override string ToString( )
        {
            return Value.ToString( CultureInfo.CurrentCulture );
        }
    }
}
</code></pre>
<p>Generation of the LLVM IR for a constant is quite simple.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( ConstantExpression constant )
{
    ArgumentNullException.ThrowIfNull( constant );

    return Context.CreateConstant( constant.Value );
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The constant value is uniqued in LLVM so that multiple calls given the same input value
will produce the same LLVM Value. Ubiquity.NET.Llvm honors this via value equality tests.
It does <em><strong>NOT</strong></em> guarantee reference equality. (It used to in older versions but no
longer does as that led to subtle problems with ownership and multi-threaded JIT)</p>
</div>
<h3 id="variable-reference-expression">Variable reference expression</h3>
<p>References to variables in Kaleidoscope, like most other languages, use a name. In this
chapter the support of variables is rather simple. The Variable expression generator assumes
the variable is declared somewhere else already and simply looks up the value from the
private map. At this stage of the development of Kaleidoscope the only place where the named
values are generated are function arguments, later chapters will introduce loop induction
variables and variable assignment. The implementation uses a standard &quot;Try/Get&quot; pattern to
retrieve the value or throw an exception if the variable doesn't exist.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( VariableReferenceExpression reference )
{
    ArgumentNullException.ThrowIfNull( reference );

    if(!NamedValues.TryGetValue( reference.Name, out Value? value ))
    {
        // Source input is validated by the parser and AstBuilder, therefore
        // this is the result of an internal error in the generator rather
        // then some sort of user error.
        throw new CodeGeneratorException( $&quot;ICE: Unknown variable name: {reference.Name}&quot; );
    }

    return value;
}
</code></pre><h3 id="binary-operator-expression">Binary Operator Expression</h3>
<p>Things start to get a good bit more interesting with binary operators. The AST node for an
expression is a simple empty &quot;tagging&quot; interface. Since the interface also requires the
<code>IAstNode</code> interface it contains support for walking the chain of operators that form an
expression in left to right order, accounting for precedence.</p>
<pre><code class="lang-csharp" name="Main">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Grammar.AST
{
    /// &lt;summary&gt;This is a grouping interface for all AST nodes that are valid expressions&lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This is a grouping interface to allow other parts of the system to distinguish between
    /// an arbitrary node and one that is ultimately an expression. This helps to ensure correctness
    /// (e.g. a function declaration is not valid as an argument to an operator, only an expression is.
    /// &lt;/remarks&gt;
    public interface IExpression
        : IAstNode
    {
    }
}
</code></pre>
<p>Generation of an expression consists a simple visitor method to emit the code for the
operands and the actual operator.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( BinaryOperatorExpression binaryOperator )
{
    ArgumentNullException.ThrowIfNull( binaryOperator );

    switch(binaryOperator.Op)
    {
    case BuiltInOperatorKind.Less:
    {
        var tmp = InstructionBuilder.Compare( RealPredicate.UnorderedOrLessThan
                                                , binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                                , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                                ).RegisterName( &quot;cmptmp&quot; );
        return InstructionBuilder.UIToFPCast( tmp, InstructionBuilder.Context.DoubleType )
                                 .RegisterName( &quot;booltmp&quot; );
    }

    case BuiltInOperatorKind.Pow:
    {
        var pow = GetOrDeclareFunction( new Prototype( &quot;llvm.pow.f64&quot;, &quot;value&quot;, &quot;power&quot; ) );
        return InstructionBuilder.Call( pow
                                      , binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;powtmp&quot; );
    }

    case BuiltInOperatorKind.Add:
        return InstructionBuilder.FAdd( binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;addtmp&quot; );

    case BuiltInOperatorKind.Subtract:
        return InstructionBuilder.FSub( binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;subtmp&quot; );

    case BuiltInOperatorKind.Multiply:
        return InstructionBuilder.FMul( binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;multmp&quot; );

    case BuiltInOperatorKind.Divide:
        return InstructionBuilder.FDiv( binaryOperator.Left.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      , binaryOperator.Right.Accept( this ) ?? throw new CodeGeneratorException( ExpectValidExpr )
                                      ).RegisterName( &quot;divtmp&quot; );

    default:
        throw new CodeGeneratorException( $&quot;ICE: Invalid binary operator {binaryOperator.Op}&quot; );
    }
}
</code></pre>
<p>The process of transforming the operator starts by generating an LLVM IR Value from the
right-hand side expression. A simple switch statement based on the token type of the
operator is used to generate the actual LLVM IR instruction(s) for the operator.</p>
<p>LLVM has strict rules on the operators and their values for the IR, in particular the types
of the operands must be identical and, usually must also match the type of the result. For
the Kaleidoscope language that's easy to manage as it only supports one data type. Other
languages might need to insert additional conversion logic as part of emitting the
operators. (Kaleidoscope does this for boolean values when supporting conditional control
flow in <a class="xref" href="../Chapter5/Kaleidoscope-ch5.html">Chapter 5</a>)</p>
<p>The Generation of the IR instructions uses the current InstructionBuilder and the
<a class="xref" href="../../../../api/Ubiquity.NET.Llvm.Values.ValueExtensions.RegisterName.html#Ubiquity_NET_Llvm_Values_ValueExtensions_RegisterName__1___0_System_String_">RegisterName</a>
extension method to provide a name for the result in LLVM IR. The name helps with
readability of the IR when generated in the textual form of LLVM IR assembly. A nice feature
of LLVM is that it will automatically handle duplicate names by appending an integral value
to the name automatically so that generators don't need to keep track of the names to ensure
uniqueness.</p>
<p>The <code>Less</code> operator uses a floating point <code>unordered less than</code> IR instruction followed by
an integer to float cast to translate the LLVM IR i1 result into a floating point value
needed by Kaleidoscope.</p>
<p>The <code>^</code> operator for exponentiation uses the <code>llvm.pow.f64</code> intrinsic to perform the
exponentiation a efficiently as the back-end generator can.</p>
<h2 id="examples">Examples</h2>
<pre><code class="lang-Console">Ubiquity.NET.Llvm Kaleidoscope Interpreter - SimpleExpressions
Ready&gt;# simple top level expression
&gt;4+5;
Defined function: __anon_expr$0

define double @&quot;__anon_expr$0&quot;() {
entry:
  ret double 9.000000e+00
}

Ready&gt;
Ready&gt;# function definitions
&gt;def foo(a b) a*a + 2*a*b + b*b;
Defined function: foo

define double @foo(double %a, double %b) {
entry:
  %multmp = fmul double %a, %a
  %multmp1 = fmul double 2.000000e+00, %a
  %multmp2 = fmul double %multmp1, %b
  %addtmp = fadd double %multmp, %multmp2
  %multmp3 = fmul double %b, %b
  %addtmp4 = fadd double %addtmp, %multmp3
  ret double %addtmp4
}

Ready&gt;
Ready&gt;def bar(a) foo(a, 4.0) + bar(31337);
Defined function: bar

define double @bar(double %a) {
entry:
  %calltmp = call double @foo(double %a, double 4.000000e+00)
  %calltmp1 = call double @bar(double 3.133700e+04)
  %addtmp = fadd double %calltmp, %calltmp1
  ret double %addtmp
}

Ready&gt;
Ready&gt;# external declaration
&gt;extern cos(x);
Defined function: cos

declare double @cos(double)

Ready&gt;
Ready&gt;# calling external function
&gt;cos(1.234);
Defined function: __anon_expr$1

define double @&quot;__anon_expr$1&quot;() {
entry:
  %calltmp = call double @cos(double 1.234000e+00)
  ret double %calltmp
}

Ready&gt;
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Chapter3/Kaleidoscope-ch3.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright (C) 2017-2025, Ubiquity.NET Contributors
          - Build: 20.1.8-rc
        </div>
      </div>
    </footer>
  </body>
</html>
