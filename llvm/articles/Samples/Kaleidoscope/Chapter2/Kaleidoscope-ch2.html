<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>2. Kaleidoscope: Implementing the parser | Ubiquity.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="2. Kaleidoscope: Implementing the parser | Ubiquity.NET ">
      
      
      <link rel="icon" href="../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Chapter2/Kaleidoscope-ch2.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../llvm/DragonSharp48x48.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

        </div>

        <article data-uid="Kaleidoscope-ch2">
<h1 id="2-kaleidoscope-implementing-the-parser">2. Kaleidoscope: Implementing the parser</h1>

<p>The chapter 2 sample doesn't actually generate any code. Instead it focuses on the general
structure of the samples and parsing of the language. The sample for this chapter enables
all language features to allow exploring the language and how it is parsed to help better
understand the rest of the chapters better. It is hoped that users of this library find this
helpful.</p>
<p>The Ubiquity.NET.Llvm version of Kaleidoscope leverages ANTLR4 to parse the language into a
parse tree. The parse tree is visited to transform it into a an Abstract Syntax Tree (AST).
This has several advantages including logical isolation of the parsing and code generation.
Additionally, it provides a single formal definition of the grammar for the language.
Understanding the language grammar from reading the LVM tutorials and source was a difficult
task since it isn't formally defined in one place. (There are some EBNF like comments in the
official LLVM tutorial code but it is spread around without much real discussion of the
language the tutorials guide you to implement)</p>
<h2 id="formal-grammar">Formal Grammar</h2>
<p>The following sections cover the formal grammar of the Kaleidoscope language.</p>
<h3 id="lexer-symbols">Lexer symbols</h3>
<p>The Kaleidoscope lexer consists of several tokens and is defined in the
<a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Kaleidoscope.Grammar/ANTLR/Kaleidoscope.g4">Kaleidoscope.g4</a>
grammar file.</p>
<pre><code class="lang-antlr">// Lexer Rules -------
fragment NonZeroDecimalDigit_: [1-9];
fragment DecimalDigit_: [0-9];
fragment Digits_: '0' | [1-9][0-9]*;
fragment EndOfFile_: '\u0000' | '\u001A';
fragment EndOfLine_
    : ('\r' '\n')
    | ('\r' |'\n' | '\u2028' | '\u2029')
    | EndOfFile_
    ;

LPAREN: '(';
RPAREN: ')';
COMMA: ',';
SEMICOLON: ';';
DEF: 'def';
EXTERN: 'extern';

ASSIGN:'=';
ASTERISK: '*';
PLUS: '+';
MINUS:'-';
LEFTANGLE: '&lt;';
SLASH: '/';

EXCLAMATION: '!';
PERCENT: '%';
AMPERSAND:'&amp;';
PERIOD:'.';
COLON: ':';
RIGHTANGLE: '&gt;';
QMARK: '?';
ATSIGN: '@';
BACKSLASH: '\\';
CARET: '^';
UNDERSCORE: '_';
VBAR: '|';
EQUALEQUAL: '==';
NOTEQUAL: '!=';
PLUSPLUS: '++';
MINUSMINUS: '--';

IF:     {FeatureControlFlow}? 'if';
THEN:   {FeatureControlFlow}? 'then';
ELSE:   {FeatureControlFlow}? 'else';
FOR:    {FeatureControlFlow}? 'for';
IN:     {FeatureControlFlow}? 'in';
VAR:    {FeatureMutableVars}? 'var';
UNARY:  {FeatureUserOperators}? 'unary';
BINARY: {FeatureUserOperators}? 'binary';

LineComment: '#' ~[\r\n]* EndOfLine_ -&gt; skip;
WhiteSpace: [ \t\r\n\f]+ -&gt; skip;

Identifier: [a-zA-Z][a-zA-Z0-9]*;
Number: Digits_ ('.' DecimalDigit_+)?;
</code></pre>
<p>This includes basic numeric patterns as well as Identifiers and the symbols allowed for
operators and keywords for the language. Subsequent chapters will introduce the meaning and
use of each of these.</p>
<h4 id="language-feature-defined-keywords">Language Feature Defined Keywords</h4>
<p>Chapters 5-7 each introduce new language features that introduce new keywords into the
language. In order to maintain a single grammar for all chapters the lexer uses a technique
of ANTLR4 called <a href="https://github.com/antlr/antlr4/blob/master/doc/predicates.md">Semantic Predicates</a>.
These are basically boolean expressions that determine if a given rule should be applied
while parsing the input language. These are applied to the rules for the feature specific
keywords. Thus, at runtime, if a given feature is disabled then the keyword is not
recognized.</p>
<pre><code class="lang-antlr">IF:     {FeatureControlFlow}? 'if';
THEN:   {FeatureControlFlow}? 'then';
ELSE:   {FeatureControlFlow}? 'else';
FOR:    {FeatureControlFlow}? 'for';
IN:     {FeatureControlFlow}? 'in';
VAR:    {FeatureMutableVars}? 'var';
UNARY:  {FeatureUserOperators}? 'unary';
BINARY: {FeatureUserOperators}? 'binary';
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>There are some important distinctions in the Ubiquity.NET.Llvm implementation of
Kaleidoscope, with regard to the symbols allowed for user defined operators. The official
LLVM version allows defining an operator '=', (in chapter 6). However, in Chapter 7, when
Mutable variables are introduced the '=' is reserved by the language for assignment. Thus,
any code written for chapter 6 with a user defined '=' operator would not work in later
versions. Thus, the Ubiquity.NET.Llvm version reserves the '=' in all versions, but uses
the '==' operator for equality comparisons. (It also adds the '++' and '--' tokens as user
operators [The official LLVM implementation only allows a single character as the operator
lexeme])</p>
<p>Additionally the Ubiquity.NET.Llvm implementation adds the built-in '^' operator for
exponentiation.</p>
</div>
<h3 id="parser">Parser</h3>
<p>The parser, like the lexer, uses Semantic Predicates, which allows for dynamic adaptation of
the grammar and parser to handle variations or versions of the language. The Sample code
uses the predicates to selectively enable language features as the chapters progress,
without needing to change the grammar or generated parser code. The parser code provides a
simple means of expressing the language support level. Semantic predicates play a vital role
in supporting user defined operators with user defined precedence.</p>
<h4 id="parser-grammar">Parser grammar</h4>
<p>A full tutorial on ANTLR is beyond the scope of this article but the basics should be
familiar enough to anyone acquainted with EBNF form to make enough sense out of it. Don't
worry too much about the details at this point as subsequent chapters will cover salient
points as new features are enabled.</p>
<h5 id="operators">Operators</h5>
<p>In order to support the parser detecting attempts to overload built-in operators and to
handle the fact that some operators don't make any sense as unary operators (e.g. you can't
create a user defined unary '=' operator. Technically, you could implement that but it would
make for some confusing code. If you really like hard to read and comprehend code there are
<a href="https://en.wikipedia.org/wiki/Brainfuck">other languages</a> better suited to that end 8^) )</p>
<p>To manage detection of appropriate operator tokens the grammar uses a set of parser rules
that group the operator tokens by their allowed kinds. This allows subsequent rules to
simply refer to the kind of operator expected and not worry about the actual tokens
involved. It also allows the parser to detect syntax and usage errors like trying to create
a user defined '+' operator.</p>
<pre><code class="lang-antlr">// built-in operator symbols
builtinop
    : ASSIGN
    | ASTERISK
    | PLUS
    | MINUS
    | SLASH
    | LEFTANGLE
    | CARET
    ;

// Allowed user defined binary symbols
userdefinedop
    : EXCLAMATION
    | PERCENT
    | AMPERSAND
    | PERIOD
    | COLON
    | RIGHTANGLE
    | QMARK
    | ATSIGN
    | BACKSLASH
    | UNDERSCORE
    | VBAR
    | EQUALEQUAL
    | NOTEQUAL
    | PLUSPLUS
    | MINUSMINUS
    ;

// unary ops can re-use built-in binop symbols (Except ASSIGN)
unaryop
    : ASTERISK
    | PLUS
    | MINUS
    | SLASH
    | LEFTANGLE
    | CARET
    | EXCLAMATION
    | PERCENT
    | AMPERSAND
    | PERIOD
    | COLON
    | RIGHTANGLE
    | QMARK
    | ATSIGN
    | BACKSLASH
    | UNDERSCORE
    | VBAR
    | EQUALEQUAL
    | NOTEQUAL
    | PLUSPLUS
    | MINUSMINUS
    ;

// All binary operators
binaryop
    : ASSIGN
    | ASTERISK
    | PLUS
    | MINUS
    | SLASH
    | LEFTANGLE
    | CARET
    | EXCLAMATION
    | PERCENT
    | AMPERSAND
    | PERIOD
    | COLON
    | RIGHTANGLE
    | QMARK
    | ATSIGN
    | BACKSLASH
    | UNDERSCORE
    | VBAR
    | EQUALEQUAL
    | NOTEQUAL
    | PLUSPLUS
    | MINUSMINUS
    ;
</code></pre>
<h3 id="initializers">Initializers</h3>
<p>The Initializers rule provides a way to handle a common sequence in the language in multiple
different contexts (sort of like a function in most programming languages, in fact, ANTLR
rules are implemented in the generated parser as methods).</p>
<pre><code class="lang-antlr">// pull the initializer out to a distinct rule so it is easier to get at
// the list of initializers when walking the parse tree
initializer
    : Identifier (ASSIGN expression[0])?
    ;

</code></pre>
<h3 id="primary-expressions-atoms">Primary Expressions (Atoms)</h3>
<p>There are a number of primary expressions (also known as 'Atoms') that are not left
recursive in their definition. These are split out to a distinct rule to aid in the support
of left recursion and the need for user defined operator precedence.</p>
<pre><code class="lang-antlr">// Non Left recursive expressions (a.k.a. atoms)
primaryExpression
    : LPAREN expression[0] RPAREN                                                 # ParenExpression
    | Identifier LPAREN (expression[0] (COMMA expression[0])*)? RPAREN            # FunctionCallExpression
    | VAR initializer (COMMA initializer)* IN expression[0]                       # VarInExpression
    | IF expression[0] THEN expression[0] ELSE expression[0]                      # ConditionalExpression
    | FOR initializer COMMA expression[0] (COMMA expression[0])? IN expression[0] # ForExpression
    | {IsPrefixOp()}? unaryop expression[0]                                       # UnaryOpExpression
    | Identifier                                                                  # VariableExpression
    | Number                                                                      # ConstExpression
    ;
</code></pre>
<p>Let's look at each of these in turn to get a better understanding of the language.</p>
<h3 id="parenexpression">ParenExpression</h3>
<pre><code class="lang-antlr">LPAREN expression[0] RPAREN
</code></pre>
<p>This is a simple rule for sub-expressions within parenthesis for example: <code>(1+2)/3</code> the
parenthesis groups the addition so that it occurs before the division since, normally the
precedence of division is higher. The parse tree for that expression looks like this:</p>
<p><img src="parsetree-paren-expr.svg" alt="Parse Tree"></p>
<h3 id="functioncallexpression">FunctionCallExpression</h3>
<pre><code class="lang-antlr">Identifier LPAREN (expression[0] (COMMA expression[0])*)? RPAREN
</code></pre>
<p>This rule covers a function call which can have 0 or more comma delimited arguments. The
parse tree for the call <code>foo(1, 2, 3);</code> is:</p>
<p><img src="parsetree-func-call.svg" alt="Parse Tree"></p>
<h3 id="varinexpression">VarInExpression</h3>
<pre><code class="lang-antlr">VAR initializer (COMMA initializer)* IN expression[0]
</code></pre>
<p>The VarInExpression rule provides variable declaration, with optional initialization. The
scope of the variables is that of the expression on the right of the <code>in</code> keyword. The
<code>var ... in ...</code> expression is in many ways like a declaration of an inline function. The
variables declared are scoped to the internal implementation of the function. Once the
function produces the return value the variables no longer exist.</p>
<h3 id="conditionalexpression">ConditionalExpression</h3>
<pre><code class="lang-antlr">IF expression[0] THEN expression[0] ELSE expression[0]
</code></pre>
<p>Conditional expressions use the very common and familiar if-then-else syntax and semantics
with one notable unique quality. In Kaleidoscope <em><strong>every language construct is an
expression</strong></em>, there are no statements. Expressions all produce a value. So the result of
the conditional expression is the result of the sub-expression selected based on the
condition. The condition value is computed and if the result == 0.0 (false) the <code>else</code>
expression is used to produce the final result. Otherwise, the <code>then</code> expression is executed
to produce the result. Thus, the actual semantics are more like the ternary conditional
operator found C and other languages:</p>
<pre><code class="lang-C">condition ? thenExpression : elseExpression
</code></pre>
<p>Example:</p>
<pre><code class="lang-Kaleidoscope">def fib(x)
  if x &lt; 3 then
    1
  else
    fib(x-1)+fib(x-2);
</code></pre>
<h3 id="forinexpression">ForInExpression</h3>
<p>The ForInExpression provides support for classic for loop constructs. In particular it
provides a variable scope for a loop value, a condition to test when to exit the loop and an
optional step value for incrementing the loop value (default is 1.0).</p>
<pre><code class="lang-Kaleidoscope">extern putchard(char);
def printstar(n)
  for i = 1, i &lt; n, 1.0 in
    putchard(42);  # ascii 42 = '*'

# print 100 '*' characters
printstar(100);
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Technically, there are no statements in Kaleidoscope, everything is an expression and has
a value. putchard() implicitly returns a value as does printstar(). (e.g. there is no void
return - ALL functions implicitly return a floating point value, even if it is always 0.0).</p>
</div>
<p>For loops with mutable values support in the language may provide a result that isn't always
0.0, for example:</p>
<pre><code class="lang-Kaleidoscope"># Define ':' for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y;

# Recursive fib, we could do this before.
def fib(x)
  if (x &lt; 3) then
    1
  else
    fib(x-1)+fib(x-2);

# Iterative fib.
def fibi(x)
  var a = 1, b = 1, c in
  (for i = 3, i &lt; x in
     c = a + b :
     a = b :
     b = c) :
  b;

# Call it.
fibi(10);
</code></pre>
<h2 id="parse-tree">Parse Tree</h2>
<p>ANTLR produces a low level parse tree with nodes corresponding to each of the rules defined
in the grammar. In most cases this is extremely verbose and more details than is actually
needed for generating code. (Though, it can be used as-is in some cases.) Typically code
generation will walk the parse tree to provide a simpler Abstract Syntax Tree that
represents the actual language concepts independent of the syntax of the language. ANTLR
will generate a parser based on the grammar description input file. This generated parser
(and lexer) includes a context type for each rule of the grammar. The C# target for ANTLR
generates these types as partial classes so they are extensible from the parser assembly
without needing to derive a new type or use virtual methods etc. Thus, the
<code>Kaleidoscope.Grammar</code> assembly contains partial class extensions that provide simpler
property accessors and support methods to aid is generating the AST.</p>
<p>See <a class="xref" href="../Kaleidoscope.Grammar/ANTLR/Kaleidoscope-Parsetree-examples.html">Kaleidoscope Parse Tree Examples</a> for more
information and example diagrams of the parse tree for various language constructs.</p>
<h2 id="abstract-syntax-tree-ast">Abstract Syntax Tree (AST)</h2>
<p>To further simplify code generators the Kaleidoscope.Grammar library contains the AstBuilder
type that is an ANTLR parse tree visitor. AstBuilder will convert a raw ANTLR <code>IParseTree</code>
into a a tree of <code>IAstNode</code> elements. That is, it visits the declarations and definitions in
the parse tree to produce a full tree of declarations and definitions as they appeared in
the source. For interactive modes - the tree will have only one top level node. However,
when parsing a whole source file, the parse tree may contain multiple declarations and
definitions under a RootNode.</p>
<p>The <a class="xref" href="../Kaleidoscope.Grammar/AST/Kaleidoscope-AST.html">Kaleidoscope AST</a> is a means of simplifying the original parse
tree into constructs that are easy for the code generation to use directly and to validate
the syntax of the input source. In the case of Kaleidoscope there are a few types of nodes
that are used to generate LLVM IR. The AstBuilder class is responsible for generating an AST
from an ANTLR4 parse tree.</p>
<p>The major simplifying transformations performed in building the AST are:</p>
<ul>
<li>Convert top-level functions to a pair of FunctionDeclaration and FunctionDefinition</li>
<li>Convert user defined operator definition to simple FunctionDefinition with a special name
for the operator.</li>
<li>Convert user defined operator expressions into simple function calls to the operator
function.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>An interesting consequence of these transformations into the AST form is that the concept
of user defined operators no longer exists in the AST! The AST only deals in function
declarations, definitions and the built-in operators. All issues of precedence are
implicitly resolved in the ordering of the nodes in the AST. Thus, the code generation
doesn't need to consider the issue of user defined operators or operator precedence at
all. (<a class="xref" href="../Chapter6/Kaleidoscope-ch6.html">Chapter 6</a> covers the details of user defined operators and
how the Kaleidoscope sample language uses ANTLR to implement them.)</p>
</div>
<h2 id="basic-application-architecture">Basic Application Architecture</h2>
<p>Generally speaking, there are four main components to most of the sample chapter
applications.</p>
<ol>
<li>The main driver application (e.g. program.cs)</li>
<li>The Read-Evaluate-Print-Loop (e.g. ReplEngine.cs)</li>
<li>Runtime support (e.g. Kaliedoscope.Grammar and Kaleidoscope.Runtime libraries)</li>
<li>The code generator (e.g. CodeGenerator.cs)</li>
</ol>
<h3 id="driver">Driver</h3>
<p>While each chapter is a bit different from the others. Many of the chapters are virtually
identical for the driver. In particular Chapters 3-7 only really differ in the name of the
app and window title etc...</p>
<pre><code class="lang-csharp" name="Program.cs">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;

using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Chapter2
{
    public static class Program
    {
        #region Main

        /// &lt;summary&gt;C# version of the LLVM Kaleidoscope language tutorial (Chapter 2)&lt;/summary&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task&quot;/&gt; representing the asynchronous operation of the program&lt;/returns&gt;
        public static async Task Main( )
        {
            var repl = new ReplEngine( );

            using CancellationTokenSource cts = new();
            Console.CancelKeyPress += ( _, e ) =&gt;
            {
                e.Cancel = true;
                cts.Cancel();
            };

            string helloMsg = $&quot;Ubiquity.NET.Llvm Kaleidoscope Parse evaluator - {repl.LanguageFeatureLevel}&quot;;
            Console.Title = $&quot;{Assembly.GetExecutingAssembly().GetName()}: {helloMsg}&quot;;
            Console.WriteLine( helloMsg );
            await repl.Run( Console.In, new Visualizer( VisualizationKind.All ), cts.Token );

            Console.WriteLine();
            Console.WriteLine( &quot;good bye!&quot; );
        }
        #endregion
    }
}
</code></pre><h3 id="read-evaluate-print-loop">Read, Evaluate, Print loop</h3>
<p>The Kaleidoscope.Runtime library contains an abstract base class for building a standard
REPL engine from an input TextReader. The base class handles converting the input reader
into a sequence of statements, and parsing them into AST nodes. The nodes are provided to an
application provided generator that produces the output result. The REPL engine base uses
the abstract ShowResults method to actually show the results.</p>
<pre><code class="lang-csharp" name="Program.cs">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System;

using Kaleidoscope.Grammar;
using Kaleidoscope.Runtime;

using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Chapter2
{
    internal class ReplEngine
        : ReadEvaluatePrintLoopBase&lt;IAstNode&gt;
    {
        public ReplEngine( )
            : base( LanguageLevel.MutableVariables )
        {
        }

        public override ICodeGenerator&lt;IAstNode&gt; CreateGenerator( DynamicRuntimeState state )
        {
            return new CodeGenerator();
        }

        public override void ProcessResults( IAstNode resultValue )
        {
            Console.WriteLine( &quot;PARSED: {0}&quot;, resultValue );
        }
    }
}
</code></pre><h3 id="runtime-support">Runtime Support</h3>
<p>The Parser contains the support for parsing the Kaleidoscope language from the REPL loop
interactive input. The parser stack also maintains the global state of the runtime, which
controls the language features enabled, and if user defined operators are enabled, contains
the operators defined along with their precedence.</p>
<p>After the parser is created an enumerable sequence of statements is created for the parser
to process. This results in a sequence of AST nodes. After construction, the sequence is
used to iterate over all of the nodes generated from the user input.</p>
<p>This use of an enumerator sequences is a bit of a different approach to things for running
an interpreter Read, Evaluate Print Loop, but once you get your head around it, the sequence
provides a nice clean and flexible mechanism for building a pipeline of transformations from
the text input into the result output.</p>
<h3 id="codegenerator">CodeGenerator</h3>
<p>The code generator will transform the AST node into the final output for the program. For
the basic samples (Chapter 4-7) it indicates the value of any JITed and executed top level
expressions. In chapter 3 it indicates the name of any functions defined and the LLVM IR for
them. Chapter 2 uses a generator that simply produces the node it was given as the app
doesn't actually use LLVM (it focuses on parsing the language only and the REPL
infrastructure). This, helps to keep the samples consistent and as similar as possible to
allow direct file comparisons to show the changes for a particular feature. The separation
of concerns also aids in making the grammar, runtime and code generation unit-testable
without the driver application.</p>
<pre><code class="lang-csharp" name="ShowResults">// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using Ubiquity.NET.Runtime.Utils;

namespace Kaleidoscope.Chapter2
{
    internal sealed class CodeGenerator
        : ICodeGenerator&lt;IAstNode&gt;
    {
        public void Dispose( )
        {
        }

        public IAstNode? Generate( IAstNode ast )
        {
            return ast;
        }
    }
}
</code></pre><h3 id="special-case-for-chapter-2">Special case for Chapter 2</h3>
<p>Chapter 2 sample code, while still following the general patterns used in all of the
chapters, is a bit unique, it doesn't actually use Ubiquity.NET.Llvm at all! Instead, it is
only focused on the language and parsing. This helps in understanding the basic patterns of
the code. Furthermore, this chapter serves as an aid in understanding the language itself.
Of particular use is the ability to generate DGML and <a href="http://blockdiag.com">blockdiag</a>
representations of the parse tree for a given parse.</p>
<div class="NOTE">
<h5>Note</h5>
<p>All of the diagrams in these tutorials were created by generating the blockdiag files and
then producingthe SVG files from that. Having a nice visual representation of a parse tree
result is helpful to understanding the parsing and various parse tree node types.</p>
</div>
<p>The visual graph is also immensely valuable when making changes to the grammar so you can
see the results of a parse and more readily understand why something isn't right. In fact,
this feature was created to help track down bugs in the parsing for user defined operator
precedence that was difficult to figure out. Once the visualization was available it became
quite easy to see the problems. Thus, Chapter 2 is both a simple introductory example and a
tool for use when doing more advanced language tweaking or extension.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/src/Samples/Kaleidoscope/Chapter2/Kaleidoscope-ch2.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright (C) 2017-2025, Ubiquity.NET Contributors
          - Build: 20.1.8-rc.1
        </div>
      </div>
    </footer>
  </body>
</html>
