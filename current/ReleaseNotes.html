<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Release Notes | Ubiquity.NET.Llvm </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Release Notes | Ubiquity.NET.Llvm ">
    <meta name="generator" content="docfx 2.58.5.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="DragonSharp48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="api/index.html" title="API Documentation">API Documentation</a>
                      </li>
                      <li>
                          <a href="https://github.com/UbiquityDotNET/Llvm.NET" title="Source Repository">Source Repository</a>
                      </li>
                      <li>
                          <a href="http://LLVM.org" title="LLVM.org">LLVM.org</a>
                      </li>
                      <li>
                          <a href="http://releases.llvm.org/10.0.0/docs/index.html" title="LLVM Docs">LLVM Docs</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="release-notes">Release Notes</h1>

<h1 id="v1000-alpha">v10.0.0-alpha</h1>
<h2 id="breaking-changes">Breaking changes</h2>
<p>With the 10.* release the Ubiquity.NET.Llvm.* libs have made a number of breaking changes.
While these are mostly small and easily adapted to, they are still a breaking change. Thus,
these changes were held to only occur on a Major release. Despite the pain of updating code
we think the changes are worth the effort to create a cleaner simpler and more consistent library.</p>
<h3 id="library-name-changes">Library name changes</h3>
<p>With the 10.* release the names of the assemblies, and therefore the packages, are all changed.
This was done to unify them all under a common organization name to allow use of the facilities
provided by NuGet for organizations and to help clarify these libraries from some other similar
projects no longer maintained.</p>
<table>
<thead>
<tr>
<th>Old Name</th>
<th>New Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ubiquity.NET.Llvm.Interop</td>
<td>Ubiquity.Net.Llvm.Interop</td>
</tr>
<tr>
<td>LibLLVM.dll</td>
<td>Ubiquity.Net.LibLLVM</td>
</tr>
<tr>
<td>Ubiquity.NET.Llvm</td>
<td>Ubiquity.Net.Llvm</td>
</tr>
</tbody>
</table>
<h3 id="library-initialization">Library initialization</h3>
<p>The library initialization and target registration was changed to better reflect the requirements
and proper sequence of usage. In particular the <code>Ubiquity.Net.Llvm.Interop.Library.InitializeLLVM()</code>
static function now returns an <code>ILibLLVM</code> interface (that is still disposable). All target registration
is done through this interface. This prevents accidental use of the registration methods <strong>BEFORE</strong>
initializing the library (as that&#39;s a guaranteed app crash!)</p>
<h3 id="c8-and-non-nullable-references">C#8 and non-Nullable references</h3>
<p>With the 10.* release the Ubiquity.NET.Llvm.* libs all updated to target .NET Standard 2.1 and C#8. This allows
use of nullable types to make nullability more explicit. This necessitated a few minor breaking changes in the
object model surface.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>DebugMemberInfo</td>
<td>Removed setters of non-nullable properties and added constructor to allow building the type with non-null values</td>
</tr>
</tbody>
</table>
<h3 id="renamed-instruction-predicate-enumerator-values">Renamed instruction predicate enumerator values</h3>
<p>The comparison instruction predicates <code>Ubiquity.NET.Llvm.Instructions.[Predicate|IntPredicate]</code>were renamed for greater
consistency and clarity (Some of the float predicates had &#39;Than&#39; in the name while the integer counterparts did not. (See:
<a href="https://github.com/UbiquityDotNET/Llvm.NET/issues/152">Bug #152</a> for details.)</p>
<table>
<thead>
<tr>
<th>Old Name</th>
<th>New Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>UnsignedGreater</td>
<td>UnsignedGreaterThan</td>
</tr>
<tr>
<td>UnsignedGreaterOrEqual</td>
<td>UnsignedGreaterThanOrEqual</td>
</tr>
<tr>
<td>UnsignedLess</td>
<td>UnsignedLessThan</td>
</tr>
<tr>
<td>UnsignedLessOrEqual</td>
<td>UnsignedLessThanOrEqual</td>
</tr>
<tr>
<td>SignedGreater</td>
<td>SignedGreaterThan</td>
</tr>
<tr>
<td>SignedGreaterOrEqual</td>
<td>SignedGreaterThanOrEqual</td>
</tr>
<tr>
<td>SignedLess</td>
<td>SignedLessThan</td>
</tr>
<tr>
<td>SignedLessOrEqual</td>
<td>SignedLessThanOrEqual</td>
</tr>
</tbody>
</table>
<h3 id="renamed-apis">Renamed APIs</h3>
<p>Some APIs had inconsistent, misspelled or confusing names and were updated.</p>
<table>
<thead>
<tr>
<th>Old Name</th>
<th>New Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ubiquity.NET.Llvm.Transforms.ScalarTransforms.LowerAtomicPass&lt;T&gt;</code></td>
<td><code>Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLowerAtomicPass&lt;T&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="obsoleted-apis">Obsoleted APIs</h3>
<table>
<thead>
<tr>
<th>Obsolete API</th>
<th>Alternative API</th>
<th>Justification</th>
</tr>
</thead>
<tbody>
<tr>
<td>BitcodeModule.AddFunction</td>
<td>BitcodeModule.CreateFunction()</td>
<td>The Create vs Add between debug info and raw native was always confusing</td>
</tr>
</tbody>
</table>
<h3 id="types-no-longer-disposable">Types no longer disposable</h3>
<p>Some types are no longer disposable. The LLVMObjectRef type uses SafeHandle, which eliminates the need
for Dispose for top level global objects. The following types no longer support IDispose:</p>
<ul>
<li>Transforms.ModulePassManager</li>
<li>Transforms.FunctionPassManager</li>
<li>ObjectFile.TargetBinary</li>
</ul>
<h3 id="altered-behavior">Altered Behavior</h3>
<h4 id="contextcreatestructtype">Context.CreateStructType()</h4>
<p>As part of resolving <a href="https://github.com/UbiquityDotNET/Llvm.NET/issues/184">bug #184</a> the CreateStructType
methods were re-evaluated and found lacking in functionality (the bug) and clarity. The docs were misleading
and the implementations overly restrictive in some cases. Thus these have been re-worked to make it more clear
when a Sized vs. Opaque structure type is created, in particular, for <strong>ALL</strong> overloads taking a &#39;packed&#39; parameter
a sized type is created, even if the size is 0 because no members are provided. This allows creation of named or 
anonymous empty structs, used in many languages. To create a named opaque type then the overload with just the
name is used. This isn&#39;t expected to impact many consumers, other than the tests, but it is a breaking change.</p>
<h4 id="contextcreateconstantstring">Context.CreateConstantString()</h4>
<p>The behavior of Context.CreateConstantString(string) has changed slightly. It now constructs a valid C string with
a null terminator, which is generally what would be expected of something called &quot;string&quot;. (The (string,bool)
overload remains, to allow apps to be explicit with intent) Additionally, the ConstantDataSequential.IsString
property now reflects whether the string is a C string (terminating null but no embedded nulls) and the
ConstantDataSequential.IsI8Sequence was added to provide the previous behavior of IsString, which was simply that
the underlying sequence element type was i8 (with or without a terminator)</p>
<h3 id="removed-redundant-apis">Removed redundant APIs</h3>
<p>LLVM has made additional APIs available in the standard LLVM-C library that are either identical to or functionality
equivalent to APIs that were custom in previous versions of the Ubiquity.NET.Llvm DLLs. This is only observable at
the interop library layer where some of the custom APIs were removed and replaced with the official ones.</p>
<table>
<thead>
<tr>
<th>Removed custom API</th>
<th>New Official API</th>
</tr>
</thead>
<tbody>
<tr>
<td>LibLLVMFoo [TBD]</td>
<td>LLVMFoo [TBD]</td>
</tr>
</tbody>
</table>
<h3 id="disabled-orcjit-lazyfunction-binding">Disabled ORCJIT LazyFunction binding</h3>
<p>Unfortunately, the ORCJIT truly lazy function generation callback support is currently disabled. LLVM itself is
transitioning to the ORCJIT v2 and in the process broke the lazy function binding support (At least for Windows+COFF).
Previously a workaround for the issue of the COFF exports was applied in the Llvm.NET ORCJIT library code for symbol
lookups. However, with ORCJIT v2 the JIT itself is doing lookups and it does so only for external symbols assuming the
symbols it generates internally will be exports, but are not (at least for COFF modules anyway). For more details see
the LLVM bugs <a href="https://bugs.llvm.org/show_bug.cgi?id=25493">25493</a> and <a href="https://bugs.llvm.org/show_bug.cgi?id=28699">28699</a></p>
<h2 id="v801">v8.0.1</h2>
<h3 id="bug-fixes">Bug Fixes</h3>
<table>
<thead>
<tr>
<th>Bug</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/UbiquityDotNET/Llvm.NET/issues/151">151</a></td>
<td>Updated DebugFunctionType signature to use interface instead of concrete type</td>
</tr>
<tr>
<td><a href="https://github.com/UbiquityDotNET/Llvm.NET/issues/152">152</a></td>
<td>Corrected docs copy/paste error [renaming part of the issue is left for the next major release as that is a breaking change]</td>
</tr>
</tbody>
</table>
<h3 id="additional-changes">Additional changes</h3>
<p>Additionally the internal build scripts were updated to simplify the consistent cross solution versioning. Previously,
a complex process of building a dummy project to generate a data file was used, however that was no longer necessary
as the <a href="https://github.com/UbiquityDotNET/CSemVer.GitBuild">CSemVer.Build.Tasks </a> package can figure out all except
the CiBuildIndex, which, for this project, is an ISO-8601 formatted time-stamp (of the latest commit for automated
builds or the build start for local developer builds)</p>
<h2 id="v800">v8.0.0</h2>
<h3 id="ubiquitynetllvminterop-new-library">Ubiquity.NET.Llvm.Interop (New library)</h3>
<p>Ubiquity.NET.Llvm 8.0 adds a new library (Ubiquity.NET.Llvm.Interop)  that contains the raw P/Invoke
APIs and support needed to inter-operate with the native library. The NuGet package
for the interop library includes the native code binaries as they are tightly coupled.
This package contains the native LibLLVM.dll and the P/Invoke interop support layers.
Ubiquity.NET.Llvm uses this library to define a clean projection of LLVM for .NET consumers.
This will, hopefully, allow for future development and enhancement of the Ubiquity.NET.Llvm
object model without changing the underlying P/Invoke layers. (e.g.
the Ubiquity.NET.Llvm.Interop can &quot;snap&quot; to LLVM versions, but the Ubiquity.NET.Llvm model can have
multiple incremental releases) This isn&#39;t a hard/fast rule as it is possible that
getting new functionality in the object model requires new custom extensions. At
this point in time both libraries are built together and share build numbers.
Though, that may change in the future. </p>
<h4 id="auto-generated-pinvoke">Auto-generated P/Invoke</h4>
<p>LLVM-C API now includes most of the debug APIs so, significantly fewer custom
extensions are needed (That&#39;s a good thing!). To try and keep things simpler this
moves the interop back to using code generation for the bulk of the P/Invoke interop.
However, unlike the first use of generation, the <a href="https://github.com/UbiquityDotNET/Llvm.NET/tree/master/src/Interop/LlvmBindingsGenerator">LLVMBindingsGenerator</a>
is much more targeted and includes specialized handling to prevent the need for
additional &quot;by-hand&quot; tweaking of the generated code, such as:</p>
<ol>
<li>Marshaling of strings with the many ways to dispose (or not) a returned string</li>
<li>LLVMBool vs LLVMStatus</li>
<li>&quot;smart ref&quot; handle types, including aliases that should not be released by
client code.</li>
</ol>
<p>The generated code is combined with some fixed support classes to create a new
Ubiquity.NET.Llvm.Interop Library and NuGet Package. </p>
<h3 id="new-features">New features</h3>
<ul>
<li>ObjectFile Support<ul>
<li>Ubiquity.NET.Llvm.ObjectFile namespace contains support for processing object files using LLVM</li>
</ul>
</li>
<li>Eager compilation JIT<ul>
<li>The OrcJIT now supports eager and lazy compilation for Windows platforms</li>
</ul>
</li>
<li>Full initialization for all the latests supported targets<ul>
<li>Including - BPF, Lanai, WebAssembly, MSP430, NVPTX, AMDGPU, Hexagon, and XCore</li>
</ul>
</li>
<li>Added accessors to allow retrieval/addition of metadata on instructions</li>
</ul>
<h3 id="breaking-changes-1">Breaking Changes</h3>
<p>This is a Major release and, as such, can, and does, have breaking changes. While there
are several such changes the actual impact to a code base is fairly trivial. Most are
driven by either obsolescence of functionality in LLVM or general naming cleanup in the
Ubiquity.NET.Llvm library:</p>
<ol>
<li>New namespace and assembly for some classes (Ubiquity.NET.Llvm.Interop)<ol>
<li>Ubiquity.NET.Llvm.DisposableAction -&gt; Ubiquity.NET.Llvm.Interop.DisposableAction</li>
<li>Ubiquity.NET.Llvm.DisposableObject -&gt; Ubiquity.NET.Llvm.Interop.DisposableObject</li>
<li>Ubiquity.NET.Llvm.StaticState -&gt; Ubiquity.NET.Llvm.Interop.Library</li>
<li>Ubiquity.NET.Llvm.TargetRegistrations -&gt; Ubiquity.NET.Llvm.Interop.TargetRegistrations</li>
</ol>
</li>
<li>StaticState class is renamed to Ubiquity.NET.Llvm.Interop.Library as it is fundamentally 
part of the low level interop (and &quot;StaticState&quot; was always a bad name)</li>
<li>Instructions no longer have a SetDebugLocation, instead that is provided via a new
fluent method on the InstructionBuilder since the normal use is to set the location
on the builder and then generate a sequence of IR instructions for a given expression
in code. </li>
<li>Legacy JIT engine support is dropped. ORCJit is the only supported JIT engine<ol>
<li>Removed Ubiquity.NET.Llvm.JIT.EngineKind</li>
<li>Removed all use of Ubiquity.NET.Llvm.JIT.IJitModuleHandle. Handles are now just an integral value</li>
<li>Removed Ubiquity.NET.Llvm.LegacyExecutionEngine</li>
</ol>
</li>
<li>Context.CreateBasicBlock() now only creates detached blocks, if append to a function
is desired, there is a method on IrFunction to create and append a block.<ol>
<li>CreateBasicBlock signature changed to remove the function and block parameters </li>
</ol>
</li>
<li>PassManager, ModulePassManager, and FunctionPassManager are IDisposable to help apps
ensure that a function pass manager, which is bound to a module, is destroyed before
the module it is bound to. Failure to do so can result in app crashes from access
violations in the native LLVM code.</li>
<li><p>BitcodeModule</p>
<ol>
<li>MakeShared and shared refs of modules is removed. (This was created for
 OrcJIT use of shared_ptr under the hood, which is no longer used. OrcJit now uses the
 same ownership transfer model as the legacy engines. E.g. the ownership for the module
 is transferred to the JIT engine)</li>
<li>BitCodeModule is now Disposable backed by a safe handle, this allows for detaching and
invalidating the underlying LLVMModuleRef when the module is provided to the JIT</li>
<li>CreateFunction() signature changed, Dropped the default null node parameters
not supported by the LLVM-C implementation.</li>
</ol>
</li>
<li><p>Renamed Function class to IrFunction to avoid potential collision with common language
keywords</p>
</li>
<li>Renamed Select to SelectInstruction to avoid potential collision with language keyword
 and make consistent with ReturnInstruction, ResumeInstruction and other similar cases
 for instructions.</li>
<li>Removed transform pass functions not supported in LLVM-C<ol>
<li>SclaraTransforms.AddLateCFGSimplificationPass()</li>
</ol>
</li>
<li><code>GlobalValueExtensions.UnnameAddress&lt;T&gt;(T,bool)</code> was changed to
<code>GlobalValueExtensions.UnnameAddress&lt;T&gt;(T,UnnamedAddressKind)</code> to support changes in
underlying LLVM</li>
<li>Removed ValueExtensions.SetDugLocation() [All overloaded forms], debug location is set
in the InstructionBuilder and remains in effect for all instructions until reset or
cleared by setting it to null.</li>
<li>DIBuilder<ol>
<li>CreateFunction() signature changed, Dropped the default null node parameters
not supported by the LLVM-C implementation.</li>
<li>DIBuilder.CreateReplaceableCompositeType() and CreateUnionType() signatures changed to
include unique ID<ol>
<li>The id is set to default to string.Empty so this should largely go without actually
breaking anything</li>
</ol>
</li>
<li>CreateBasicType Added DebugIngoFlags parameter</li>
<li>CreateEnumerationType removed uniqueId string parameter as it isn&#39;t supported by LLVM-C</li>
<li>Obsoleted CreateStructType signature taking <code>DINodeArray</code> in favor of <code>IEnumerable&lt;DINode&gt;</code></li>
</ol>
</li>
<li>Ubiquity.NET.Llvm.DebugInfo.ExpressionOp names changed to correct PascalCasing and eliminate
underscores in the value names for better consistency and style compliance.</li>
<li>Renamed some Ubiquity.NET.Llvm.DebugInfo.SourceLanguage vendor specific values to conform with
underlying LLVM names<ol>
<li>RenderScript -&gt; GoogleRenderScript</li>
<li>Delphi -&gt; BorlandDelphi</li>
</ol>
</li>
<li>Renamed or removed some of the Ubiquity.NET.Llvm.DebugInfo.Tag values to better reflect underlying
LLVM names and avoid potential language keyword conflicts.<ol>
<li>Label -&gt; TagLabel</li>
<li>PtrToMemberType -&gt; PointerToMemberType</li>
<li>Removed AutoVariable, ArgVariable, Expression, UserBase, LoUser and MipsLoop as they
don&#39;t exist in the LLVM support.</li>
</ol>
</li>
<li>InstructionBuilder<ol>
<li>Obsoleted Methods that don&#39;t support opaque pointers in preparation for LLVM&#39;s transition</li>
<li>Changed MemCpy, MemMove, and MemSet signatures to remove alignment as LLVM intrinsic no
longer includes an alignment parameter. It is applied as a parameter attribute for each 
of the pointer parameters (source and destination).</li>
</ol>
</li>
<li>Ubiquity.NET.Llvm.JIT.IExecutionEngine<ol>
<li>Replaced AddModule with AddEagerlyCompiledModule to make it more explicit on the behavior</li>
</ol>
</li>
<li>Ubiquity.NET.Llvm.ILazyCompileExecutionEngine<ol>
<li>Replaced AddModule [From IExecutionEngine] with AddLazyCompiledModule to make it explicit</li>
<li>Removed DefalultSymbolResolver from interface as it should not have been in the interface
to start with.</li>
</ol>
</li>
<li>Deleted Ubiquity.NET.Llvm.LegacyExecutionEngine</li>
<li>Ubiquity.NET.Llvm.JIT.OrcJit - updated to reflect changes in the IExecutionEngine and
ILazyCompileExecutionEngine interfaces.</li>
</ol>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/docfx/current/ReleaseNotes.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (C) 2017-2020, Ubiquity.NET Contributors<br><strong>Build:</strong> 10.0.0
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
