<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>5. Kaleidoscope: Control Flow | Ubiquity.NET.Llvm </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="5. Kaleidoscope: Control Flow | Ubiquity.NET.Llvm ">
    <meta name="generator" content="docfx 2.58.5.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc">
    <meta property="docfx:tocrel" content="../../toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../DragonSharp48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../../../api/index.html" title="API Documentation">API Documentation</a>
                      </li>
                      <li>
                          <a href="https://github.com/UbiquityDotNET/Llvm.NET" title="Source Repository">Source Repository</a>
                      </li>
                      <li>
                          <a href="http://LLVM.org" title="LLVM.org">LLVM.org</a>
                      </li>
                      <li>
                          <a href="http://releases.llvm.org/10.0.0/docs/index.html" title="LLVM Docs">LLVM Docs</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Samples</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a class="">Code Generation</a>
                          </li>
                          <li class="">
                            <a href="../../CodeGenWithDebugInfo/codegeneration.html" title="CodeGenerator With Debug Information" class="">CodeGenerator With Debug Information</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Kaleidoscope</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="../../Kaleidoscope/Kaleidoscope-Overview.html" title="Chapter 1 - Language Introduction" class="">Chapter 1 - Language Introduction</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter2/Kaleidoscope-ch2.html" title="Chapter 2 - Implementing the parser" class="">Chapter 2 - Implementing the parser</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter3/Kaleidoscope-ch3.html" title="Chapter 3 - Generating LLVM IR" class="">Chapter 3 - Generating LLVM IR</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter4/Kaleidoscope-ch4.html" title="Chapter 4 - JIT and Optimizer Support" class="">Chapter 4 - JIT and Optimizer Support</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter5/Kaleidoscope-ch5.html" title="Chapter 5 - Control Flow" class="">Chapter 5 - Control Flow</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter6/Kaleidoscope-ch6.html" title="Chapter 6 - User Defined Operators" class="">Chapter 6 - User Defined Operators</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter7/Kaleidoscope-ch7.html" title="Chapter 7 - Mutable Variables" class="">Chapter 7 - Mutable Variables</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter7.1/Kaleidoscope-ch7.1.html" title="Chapter 7.1 - Extreme Lazy JIT" class="">Chapter 7.1 - Extreme Lazy JIT</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter8/Kaleidoscope-ch8.html" title="Chapter 8 - AOT Compilation" class="">Chapter 8 - AOT Compilation</a>
                          </li>
                          <li class="">
                            <a href="../../Kaleidoscope/Chapter9/Kaleidoscope-ch9.html" title="Chapter 9 - Debug Information" class="">Chapter 9 - Debug Information</a>
                          </li>
                          <li class="">
                            <span class="expand-stub"></span>
                            <a class="">Appendix</a>
                              
                              <ul class="nav level3">
                                <li class="">
                                  <a href="../../Kaleidoscope/Kaleidoscope.Runtime/Kaleidoscope-Runtime.html" title="Kaleidoscope.Runtime" class="">Kaleidoscope.Runtime</a>
                                </li>
                                <li class="">
                                  <a href="../../Kaleidoscope/Kaleidoscope.Parser/AST/Kaleidoscope-AST.html" title="Kaleidoscope AST" class="">Kaleidoscope AST</a>
                                </li>
                                <li class="">
                                  <a href="../../Kaleidoscope/Kaleidoscope.Parser/ANTLR/Kaleidoscope-ParseTreeVisitor.html" title="ParseTree Visitor" class="">ParseTree Visitor</a>
                                </li>
                                <li class="">
                                  <a href="../../Kaleidoscope/Kaleidoscope.Parser/ANTLR/Kaleidoscope-Parsetree-examples.html" title="ParseTree Examples" class="">ParseTree Examples</a>
                                </li>
                              </ul>  </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Kaleidoscope-ch5">
<h1 id="5-kaleidoscope-control-flow">5. Kaleidoscope: Control Flow</h1>

<p>This chapter focuses on adding the support necessary to implement the if-then-else and for loop control
flow support in the Kaleidoscope language. Without some sort of control flow the Kaleidoscope language
is not particularly useful. So, this chapter completes the core language support to make it a usable
language.</p>
<h2 id="if-then-else">if-then-else</h2>
<p>It is worth re-visiting the discussion of the intended syntax and semantics for conditional flow in
<a class="xref" href="../Chapter2/Kaleidoscope-ch2.html#conditionalexpression">Chapter 2</a>. This will help in understanding the language
functionality to implement.</p>
<p>The ultimate goal of the changes to support code generation for control flow constructs is to transform
Kaleidoscope code such as:</p>
<pre><code class="lang-Kaleidoscope">extern foo();
extern bar();
def baz(x) if x then foo() else bar();
</code></pre><p>and generate LLVM like this (unoptimized):</p>
<pre><code class="lang-llvm">declare double @foo()

declare double @bar()

define double @baz(double %x) {
entry:
  %ifcond = fcmp one double %x, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:       ; preds = %entry
  %calltmp = call double @foo()
  br label %ifcont

else:       ; preds = %entry
  %calltmp1 = call double @bar()
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ]
  ret double %iftmp
}
</code></pre><p>The entry code will convert the input x into an llvm i1 value to use as the condition for a branch. This
is done by comparing the input value of x to 0.0 to get the condition boolean value. Then the condition is
used to branch to either the &#39;then&#39; block or the &#39;else&#39; block. The two target blocks contain the generated
code for the expressions for each part of the conditional and a final branch to a continuation block.</p>
<p>Since the code branch could flow into the continuation block from either the &#39;else&#39; or &#39;end&#39; blocks a phi
instruction is placed at the beginning of the continuation block with appropriate values for the result
from each of the two predecessor blocks. The resulting value is then provided as the return of the function.
It is important to note that using the phi node in this fashion does not require generating all of the code
in SSA form. In fact, doing that in the front end is strongly discouraged. Generally speaking there are
only two reasons where a phi node may crop up:</p>
<ol>
<li>Mutable variables like x = 1; x = x + 1;</li>
<li>Values that are part of the structure of the language (usually for control flow)</li>
</ol>
<p><a class="xref" href="../Chapter7/Kaleidoscope-ch7.html">Chapter 7</a> Covers the mutable variables case in detail and the techniques for
generating the code without using a phi node. For cases like this one where it is straight forward and easy
to insert the phi node directly then there&#39;s no reason not to. Though, the solution provided in Chapter 7 can,
and does, eliminate the need to manually insert the phi node here as well.</p>
<h3 id="code-generation">Code Generation</h3>
<p>Generating the code for the condition expression follows the pattern shown above with the following high
level steps:</p>
<ol>
<li>Generate the code for the condition value expression</li>
<li>Emit conversion of the result of the condition to an LLVM i1 by comparing to 0.0</li>
<li>Create a block for the then expression</li>
<li>Create a block for the else expression</li>
<li>Create a block for the if continuation</li>
<li>Emit conditional branch to the then, else blocks</li>
<li>Switch to the then expression block</li>
<li>Emit code for the then expression</li>
<li>Capture the insertion block location as generating the then expression may add new blocks</li>
<li>Emit a branch to the if continuation block</li>
<li>Switch to the else block</li>
<li>Emit code for the else expression</li>
<li>Emit a branch to the if continuation block</li>
<li>Capture the insertion block location as generating the else expression may add new blocks</li>
<li>Switch to the if continuation block</li>
<li>Emit phi node with the results of the insertion blocks and result values captured after generating
each of the sub expressions</li>
<li>Use the result...</li>
</ol>
<p>That&#39;s a bit more complex than the other language constructs seen so far, but is still pretty straight
forward once you get the general gist of how LLVM IR works. There&#39;s one extra trick repeated in steps 9
and again in 14, where after generating the IR for the sub expressions, the current block insertion point
is captured. This is needed as the generation for the sub expression may include another conditional
expression, which may contain a conditional sub expression, ... Thus, the &#39;current block&#39; may well have
changed from the starting block. The phi node needs the immediate predecessor block and the value it
produced, so the current block is captured after generation, before switching the block to the next one
for generation to ensure that the correct block is used with the value.</p>
<p>The actual code follows the description pretty closely and should now be fairly easy to follow:</p>
<pre><code class="lang-csharp" name="ConditionalExpression">public override Value? Visit( ConditionalExpression conditionalExpression )
{
    conditionalExpression.ValidateNotNull( nameof( conditionalExpression ) );
    var condition = conditionalExpression.Condition.Accept( this );
    if( condition == null )
    {
        return null;
    }

    var condBool = InstructionBuilder.Compare( RealPredicate.OrderedAndNotEqual, condition, Context.CreateConstant( 0.0 ) )
                                     .RegisterName( &quot;ifcond&quot; );

    var function = InstructionBuilder.InsertFunction;
    if( function is null )
    {
        throw new InternalCodeGeneratorException( &quot;ICE: expected block that is attached to a function at this point&quot; );
    }

    var thenBlock = function.AppendBasicBlock( &quot;then&quot; );
    var elseBlock = function.AppendBasicBlock( &quot;else&quot; );
    var continueBlock = function.AppendBasicBlock( &quot;ifcont&quot; );
    InstructionBuilder.Branch( condBool, thenBlock, elseBlock );

    // generate then block instructions
    InstructionBuilder.PositionAtEnd( thenBlock );

    // InstructionBuilder.InserBlock after this point is !null
    Debug.Assert( InstructionBuilder.InsertBlock != null, &quot;expected non-null InsertBlock&quot; );
    var thenValue = conditionalExpression.ThenExpression.Accept( this );
    if( thenValue == null )
    {
        return null;
    }

    InstructionBuilder.Branch( continueBlock );

    // capture the insert in case generating else adds new blocks
    var thenResultBlock = InstructionBuilder.InsertBlock;

    // generate else block
    InstructionBuilder.PositionAtEnd( elseBlock );
    var elseValue = conditionalExpression.ElseExpression.Accept( this );
    if( elseValue == null )
    {
        return null;
    }

    InstructionBuilder.Branch( continueBlock );
    var elseResultBlock = InstructionBuilder.InsertBlock;

    // generate continue block
    InstructionBuilder.PositionAtEnd( continueBlock );
    var phiNode = InstructionBuilder.PhiNode( function.Context.DoubleType )
                                    .RegisterName( &quot;ifresult&quot; );

    phiNode.AddIncoming( (thenValue, thenResultBlock), (elseValue, elseResultBlock) );
    return phiNode;
}
</code></pre><h2 id="for-loop">For Loop</h2>
<p>Now that the basics of control flow are available it is possible to leverage the same concepts to
implement the for loop constructs for the language.</p>
<p>The general idea is to transform the loops in Kaleidoscope such as this:</p>
<pre><code class="lang-Kaliedoscope">extern putchard(char);
def printstar(n)
  for i = 1, i &lt; n, 1.0 in
    putchard(42);  # ascii 42 = &#39;*&#39;

# print 100 &#39;*&#39; characters
printstar(100);
</code></pre><p>In LLVM IR (unoptimized) that should look like this:</p>
<pre><code class="lang-llvm">declare double @putchard(double)

define double @printstar(double %n) {
entry:
  ; initial value = 1.0 (inlined into phi)
  br label %loop

loop:       ; preds = %loop, %entry
  %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]
  ; body
  %calltmp = call double @putchard(double 4.200000e+01)
  ; increment
  %nextvar = fadd double %i, 1.000000e+00

  ; termination test
  %cmptmp = fcmp ult double %i, %n
  %booltmp = uitofp i1 %cmptmp to double
  %loopcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %loopcond, label %loop, label %afterloop

afterloop:      ; preds = %loop
  ; loop always returns 0.0
  ret double 0.000000e+00
}
</code></pre><p>Thus, the basic pattern to generate the for loop code consists of the following steps:</p>
<ol>
<li>Create block for loop header</li>
<li>Switch to the loop header block</li>
<li>Emit code to Initialize start value with starting value from initialization expression</li>
<li>Create block for the loop body</li>
<li>Create block for the loop end</li>
<li>Emit unconditional branch to the loop body</li>
<li>Switch to the loop body block</li>
<li>Emit phi node for the loop value with the loop header block and initial value as first predecessor</li>
<li>Push a new scope for named values as the loop body represents a new scope</li>
<li>Add the variable for the loop to the current scope</li>
<li>Emit the body expression, which may create new blocks</li>
<li>Emit the code to compute the next value (e.g. next = current + step )</li>
<li>Emit code for the end condition</li>
<li>Emit code to convert the result of the condition to an LLVM i1 for a conditional branch</li>
<li>Capture loop end block for PHI node</li>
<li>Create after loop block</li>
<li>Emit conditional branch to the loop body block or after loop block depending on the result of the end
condition</li>
<li>Add an incoming predecessor to the phi node at the beginning of the loop body for the next loop value
and the loop end block it comes from</li>
<li>Switch to after block</li>
<li>Create constant value of 0.0 as the result expression of the for loop</li>
</ol>
<p>That&#39;s a few more steps than even the if-then-else but the basic concepts of blocks, conditional branches
and direct phi-nodes remains the same.</p>
<p>The code to generate a for loop follows this pattern pretty closely.</p>
<pre><code class="lang-csharp" name="Main">public override Value? Visit( ForInExpression forInExpression )
{
    forInExpression.ValidateNotNull( nameof( forInExpression ) );
    var function = InstructionBuilder.InsertFunction;
    if( function is null )
    {
        throw new InternalCodeGeneratorException( &quot;ICE: Expected block attached to a function at this point&quot; );
    }

    string varName = forInExpression.LoopVariable.Name;

    // Emit the start code first, without &#39;variable&#39; in scope.
    Value? startVal;
    if( forInExpression.LoopVariable.Initializer != null )
    {
        startVal = forInExpression.LoopVariable.Initializer.Accept( this );
        if( startVal is null )
        {
            return null;
        }
    }
    else
    {
        startVal = Context.CreateConstant( 0.0 );
    }

    Debug.Assert( InstructionBuilder.InsertBlock != null, &quot;expected non-null InsertBlock&quot; );

    // Make the new basic block for the loop header, inserting after current
    // block.
    var preHeaderBlock = InstructionBuilder.InsertBlock;
    var loopBlock = function.AppendBasicBlock( &quot;loop&quot; );

    // Insert an explicit fall through from the current block to the loopBlock.
    InstructionBuilder.Branch( loopBlock );

    // Start insertion in loopBlock.
    InstructionBuilder.PositionAtEnd( loopBlock );

    // Start the PHI node with an entry for Start.
    var variable = InstructionBuilder.PhiNode( Context.DoubleType )
                                     .RegisterName( varName );

    variable.AddIncoming( startVal, preHeaderBlock );

    // Within the loop, the variable is defined equal to the PHI node.
    // So, push a new scope for it and any values the body might set
    using( NamedValues.EnterScope( ) )
    {
        NamedValues[ varName ] = variable;

        // Emit the body of the loop.  This, like any other expression, can change the
        // current BB.  Note that we ignore the value computed by the body, but don&#39;t
        // allow an error.
        if( forInExpression.Body.Accept( this ) == null )
        {
            return null;
        }

        Value? stepValue = forInExpression.Step.Accept( this );
        if( stepValue == null )
        {
            return null;
        }

        var nextVar = InstructionBuilder.FAdd( variable, stepValue)
                                        .RegisterName( &quot;nextvar&quot; );

        // Compute the end condition.
        Value? endCondition = forInExpression.Condition.Accept( this );
        if( endCondition == null )
        {
            return null;
        }

        // Convert condition to a bool by comparing non-equal to 0.0.
        endCondition = InstructionBuilder.Compare( RealPredicate.OrderedAndNotEqual, endCondition, Context.CreateConstant( 0.0 ) )
                                         .RegisterName( &quot;loopcond&quot; );

        // capture loop end result block for loop variable PHI node
        var loopEndBlock = InstructionBuilder.InsertBlock;

        // Create the &quot;after loop&quot; block and insert it.
        var afterBlock = function.AppendBasicBlock( &quot;afterloop&quot; );

        // Insert the conditional branch into the end of LoopEndBB.
        InstructionBuilder.Branch( endCondition, loopBlock, afterBlock );
        InstructionBuilder.PositionAtEnd( afterBlock );

        // Add a new entry to the PHI node for the back-edge.
        variable.AddIncoming( nextVar, loopEndBlock );

        // for expression always returns 0.0 for consistency, there is no &#39;void&#39;
        return Context.DoubleType.GetNullValue( );
    }
}
</code></pre><p>The only new functionality in that is the use of the ScopeStack class to support nested scopes and the named
variables within them. <a class="xref" href="../../../../api/Ubiquity.NET.Llvm.ScopeStack-1.html">ScopeStack</a> is provided in the Ubiquity.NET.Llvm library. It is
basically a stack of name to value mapping dictionaries. The EnterScope method will push a new dictionary on
to the stack and return an IDisposable that will handle popping it back off. This allows for nested expressions
to use variables in the parent scope and to override them with its own value too. That, is the symbols available
in a loop include the loop variable and any variables in the parent scope, all the way back to the function
parameters. The stack nature allows for deeper scopes to shadow the variable of the same name in the parent,
while allowing access to all other variables from other scopes.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Control flow is certainly more complex to generate than any of the other language constructs but it relies on
a few basic primitive building block patterns. Thus, it is fairly easy to understand and implement once the
basic patterns are understood. With the inclusion of control flow the Kaleidoscope language is now a complete,
albeit simplistic, functional language.</p>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/develop/samples/Kaleidoscope/Chapter5/Kaleidoscope-ch5.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (C) 2017-2020, Ubiquity.NET Contributors<br><strong>Build:</strong> 10.0.0
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
